<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite-url","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="It&#39;s an IT blog...">
<meta property="og:type" content="website">
<meta property="og:title" content="Study Node">
<meta property="og:url" content="http://yoursite-url/index.html">
<meta property="og:site_name" content="Study Node">
<meta property="og:description" content="It&#39;s an IT blog...">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite-url/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Study Node</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Study Node</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">True mastery of any skill takes a lifetime</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hao"
      src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
  <p class="site-author-name" itemprop="name">Hao</p>
  <div class="site-description" itemprop="description">It's an IT blog...</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/byteflow666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;byteflow666" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://mail.qq.com/cgi-bin/frame_html?sid=1aPXzaqY4yWqbjhZ&r=98902ddef6ed390980f08fe54374e19b" title="E-Mail → https:&#x2F;&#x2F;mail.qq.com&#x2F;cgi-bin&#x2F;frame_html?sid&#x3D;1aPXzaqY4yWqbjhZ&amp;r&#x3D;98902ddef6ed390980f08fe54374e19b" rel="noopener" target="_blank">E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="MySQL">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/MySQL/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/MySQL/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">逻辑架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-17 22:35:34" itemprop="dateCreated datePublished" datetime="2022-01-17T22:35:34+08:00">2022-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">MySQL高级</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E9%AB%98%E7%BA%A7/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a><strong>逻辑架构</strong></h1><h2 id="逻辑架构剖析"><a href="#逻辑架构剖析" class="headerlink" title="逻辑架构剖析"></a><strong>逻辑架构剖析</strong></h2><h3 id="服务器处理客户端请求"><a href="#服务器处理客户端请求" class="headerlink" title="服务器处理客户端请求"></a><strong>服务器处理客户端请求</strong></h3><p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/asdaweawefdsss.png"></p>
<p>下面具体展开看一下：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/19W8M1J4XS5G0.png"></p>
<h3 id="Connectors"><a href="#Connectors" class="headerlink" title="Connectors"></a><strong>Connectors</strong></h3><p>Connectors,指的是不同语言中与SQL得交互。MySQL首先是一个网络程序,在TCP之上定义了自己得应用层协议。所以要用MySQL,我们可以编写代码,根MySQL Server建立TCP连接,之后按照其定义好的协议进行交互。或者比较方便的方法是调用SDK，比如Native C API，JDBC,PHP等各语言MySQL Connectors,或者通过ODBC。但通过SDK来访问MySQL ，本质上还是在TCP连接上通过MySQL协议根MySQL进行交互。</p>
<p><strong>接下来MySQL Server结构可以分为如下的三层:</strong></p>
<h3 id="第1层：连接层"><a href="#第1层：连接层" class="headerlink" title="第1层：连接层"></a><strong>第1层：连接层</strong></h3><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。</p>
<p>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p>
<ul>
<li><p><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></p>
</li>
<li><p><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></p>
</li>
</ul>
<p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<h3 id="第2层：服务层"><a href="#第2层：服务层" class="headerlink" title="第2层：服务层"></a><strong>第2层：服务层</strong></h3><ul>
<li><p><strong>SQL Interface: SQL接口</strong></p>
<ul>
<li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </li>
<li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li>
</ul>
</li>
<li><p><strong>Parser: 解析器</strong></p>
<ul>
<li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li>
<li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。</li>
</ul>
</li>
<li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p>
<ul>
<li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。</li>
<li>这个执行计划表明应该 使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li>
<li>它使用“ 选取-投影-连接 ”策略进行查询。例如：</li>
</ul>
</li>
</ul>
<p>​       </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM student WHERE gender = &#x27;女&#x27;;</span><br></pre></td></tr></table></figure>

<p>这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接 起来生成最终查询结果。</p>
<ul>
<li><strong>Caches &amp; Buffers： 查询缓存组件</strong><ul>
<li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端</li>
<li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li>
<li>这个查询缓存可以在 不同客户端之间共享 。</li>
<li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。 </li>
</ul>
</li>
</ul>
<h3 id="第3层：引擎层"><a href="#第3层：引擎层" class="headerlink" title="第3层：引擎层"></a><strong>第3层：引擎层</strong></h3><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别</strong>维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<p>MySQL 8.0.25默认支持的存储引擎如下：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/59XUUR45UEI_Z8.png"></p>
<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a><strong>存储层</strong></h3><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/QR_1IP4IS3L37NT7D27PH.png"></p>
<p>简化为三层结构：</p>
<ol>
<li><p>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</p>
</li>
<li><p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</p>
</li>
<li><p>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</p>
</li>
</ol>
<h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a><strong>SQL执行流程</strong></h2><h3 id="MySQL-中的-SQL执行流程"><a href="#MySQL-中的-SQL执行流程" class="headerlink" title="MySQL 中的 SQL执行流程"></a><strong>MySQL</strong> <strong>中的</strong> <strong>SQL执行流程</strong></h3><p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/qwesdfds.png"></p>
<p><strong>MySQL的查询流程：</strong></p>
<p><strong>1.</strong> <strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</p>
<p><strong>大多数情况查询缓存就是个鸡肋，为什么呢？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name FROM employees WHERE employee_id = 101;</span><br></pre></td></tr></table></figure>

<p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的 鲁棒性大大降 低 ，只有 相同的查询操作才会命中查询缓存 。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。</p>
<p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW ，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！</p>
<p>此外，既然是缓存，那就有它 缓存失效的时候 。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了 INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或 DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于 更新压力大的数据库 来说，查询缓存的命中率会非常低。</p>
<p><strong>2.</strong> <strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/OIP6RMA8ZE1ZEFUO.png"></p>
<p>分析器先做“ 词法分析 ”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>
<p>接着，要做“ 语法分析 ”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否 满足 MySQL 语法 。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select department_id,job_id,avg(salary) from employees group by department_id;</span><br></pre></td></tr></table></figure>

<p>如果SQL语句正确，则会生成一个这样的语法树：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/R123123W6UGUM4MK.png"></p>
<p><strong>3.</strong> <strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索 ，还是根据 索引检索 等。</p>
<p>举例：如下语句是执行两个表的 join： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test1 join test2 using(ID) where test1.name=&#x27;zhangwei&#x27; and test2.name=&#x27;mysql高级课程&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方案1：可以先从表 test1 里面取出 name=’zhangwei’的记录的 ID 值，再根据 ID 值关联到表 test2，再判 断 test2 里面 name的值是否等于 ‘mysql高级课程’。 </p>
<p>方案2：可以先从表 test2 里面取出 name=’mysql高级课程’ 的记录的 ID 值，再根据 ID 值关联到 test1， 再判断 test1 里面 name的值是否等于 zhangwei。 </p>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化 器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。 </p>
<p>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。</p>
</blockquote>
<p>在查询优化器中，可以分为 逻辑查询 优化阶段和 物理查询 优化阶段。</p>
<p><strong>4.</strong> <strong>执行器</strong>：</p>
<p>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 执行器阶段 。</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/17AGB9PDY8Q.png"></p>
<p>在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where id=1;</span><br></pre></td></tr></table></figure>

<p>比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<blockquote>
<p>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 </p>
<p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p>
</blockquote>
<p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。</p>
<p>SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/Y5126Q%600MXNSVW2R%60QBG7~D.png"></p>
<h3 id="MySQL8中SQL执行原理"><a href="#MySQL8中SQL执行原理" class="headerlink" title="MySQL8中SQL执行原理"></a><strong>MySQL8中SQL执行原理</strong></h3><p><strong>1.</strong> <strong>确认profiling是否开启</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;profiling&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/asdawraw55.png"></p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/TAEK474]4JGYM8J.png"></p>
<p>profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=1;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>多次执行相同SQL查询</strong></p>
<p>然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from employees;</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>查看profiles</strong></p>
<p>查看当前会话所产生的所有 profiles： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles; # 显示最近的几次查询</span><br></pre></td></tr></table></figure>

<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/86416541adwae.png"></p>
<p><strong>4.</strong> <strong>查看profile</strong></p>
<p>显示执行计划，查看程序的执行步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile;</span><br></pre></td></tr></table></figure>

<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/8FN6WFL1F5544QW.png"></p>
<p>当然你也可以查询指定的 Query ID，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile for query 7;</span><br></pre></td></tr></table></figure>

<p>查询 SQL 的执行时间结果和上面是一样的。</p>
<p>此外，还可以查询更丰富的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profile cpu,block io for query 6;</span><br></pre></td></tr></table></figure>

<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/asdawr324234ss.png"></p>
<p>继续</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">show</span> profile cpu,<span class="built_in">block</span> io <span class="keyword">for</span> query <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/85QAFXQ94KNLJB.png"></p>
<h3 id="MySQL5-7中SQL执行原理"><a href="#MySQL5-7中SQL执行原理" class="headerlink" title="MySQL5.7中SQL执行原理"></a><strong>MySQL5.7中SQL执行原理</strong></h3><p><strong>1.</strong> <strong>配置文件中开启查询缓存</strong> </p>
<p>在 /etc/my.cnf 中新增一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>重启mysql服务</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>开启查询执行计划</strong></p>
<p>由于重启过服务，需要重新执行如下指令，开启profiling。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set profiling=1;</span><br></pre></td></tr></table></figure>

<p><strong>4.</strong> <strong>执行语句两次：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from locations; </span><br><span class="line"></span><br><span class="line">mysql&gt; select * from locations;</span><br></pre></td></tr></table></figure>

<p>当 查看profile执行编号2时，比执行编号1时少了很多信息，可以看出查询语句直接从缓存中获取数据 这里就不演示了</p>
<h3 id="SQL语法顺序"><a href="#SQL语法顺序" class="headerlink" title="SQL语法顺序"></a><strong>SQL语法顺序</strong></h3><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。</p>
<p>需求：查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息</p>
<p>下面是经常出现的查询顺序：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/557sdgsdfsdf.png"></p>
<h3 id="Oracle中的SQL执行流程-了解"><a href="#Oracle中的SQL执行流程-了解" class="headerlink" title="Oracle中的SQL执行流程(了解)"></a><strong>Oracle中的SQL执行流程(了解)</strong></h3><p>Oracle 中采用了 共享池 来判断 SQL 语句是否存在缓存和执行计划，通过这一步骤我们可以知道应该采用硬解析还是软解析。</p>
<p>我们先来看下 SQL 在 Oracle 中的执行过程：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/PQPIUJA6QTO1DD5TK2XA.png"></p>
<p>从上面这张图中可以看出，SQL 语句在 Oracle 中经历了以下的几个步骤。</p>
<p><strong>1.语法检查</strong>：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</p>
<p><strong>2.语义检查</strong>：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</p>
<p><strong>3.权限检查</strong>：看用户是否具备访问该数据的权限。</p>
<p><strong>4.共享池检查</strong>：共享池（Shared Pool）是一块内存池，**最主要的作用是缓存 **SQL <strong>语句和该语句的执行计</strong>划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？</p>
<p>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算 ，然后根据 Hash 值在库缓存（Library Cache）中查找，如果 存在 SQL 语句的执行计划 ，就直接拿来执行，直接进入“执行器”的环节，这就是 软解析 。</p>
<p>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是 硬解析 。</p>
<p><strong>5.优化器</strong>：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</p>
<p><strong>6.执行器</strong>：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。</p>
<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要缓存 SQL 语句和执行计划。而 数据字典缓冲区 存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</p>
<p>库缓存 这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。</p>
<p>你可能会问，如何避免硬解析，尽量使用软解析呢？在 Oracle 中， 绑定变量 是它的一大特色。绑定变量就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能 提升软解 析的可能性 ，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</p>
<p>举个例子，我们可以使用下面的查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from player where player_id = 10001;</span><br></pre></td></tr></table></figure>

<p>你也可以使用绑定变量，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from player where player_id = :player_id;</span><br></pre></td></tr></table></figure>

<p>这两个查询语句的效率在 Oracle 中是完全不同的。如果你在查询 player_id = 10001 之后，还会查询10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。</p>
<p>因此，<strong>我们可以通过使用绑定变量来减少硬解析，减少</strong> <strong>Oracle</strong> <strong>的解析工作量。</strong>但是这种方式也有缺点，使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。</p>
<p><strong>Oracle的架构图：</strong></p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/X1TZP9OCWRT29I0M.png"></p>
<p><strong>简图：</strong></p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/LPFFHLBNWHKB65%60V1T15.png"></p>
<p>小结：</p>
<p>Oracle 和 MySQL 在进行 SQL 的查询上面有软件实现层面的差异。Oracle 提出了共享池的概念，通过共享池来判断是进行软解析，还是硬解析。</p>
<h2 id="数据库缓冲池-buffer-pool"><a href="#数据库缓冲池-buffer-pool" class="headerlink" title="数据库缓冲池(buffer pool)"></a><strong>数据库缓冲池(buffer pool)</strong></h2><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 占用内存来作为 数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。</p>
<p>这样做的好处是可以让磁盘活动最小化，从而 减少与磁盘直接进行 I/O 的时间 。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>
<h3 id="缓冲池-vs-查询缓存"><a href="#缓冲池-vs-查询缓存" class="headerlink" title="缓冲池 vs 查询缓存"></a><strong>缓冲池</strong> <strong>vs</strong> <strong>查询缓存</strong></h3><p><strong>缓冲池和查询缓存是一个东西吗？不是。</strong></p>
<p><strong>1.</strong> <strong>缓冲池（Buffer Pool）</strong></p>
<p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。</p>
<p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种</p>
<p>数据的缓存，如下图所示：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/STTND03RFB44PGU.png"></p>
<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p>
<p><strong>缓存池的重要性：</strong></p>
<p><strong>缓存原则：</strong></p>
<p>“ 位置 * 频次 ”这个原则，可以帮我们对 I/O 访问效率进行优化。</p>
<p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p>
<p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 优先对使用频次高 的热数据进行加载 。</p>
<p><strong>缓冲池的预读特性：</strong></p>
<p><strong>2.</strong> <strong>查询缓存</strong></p>
<p>那么什么是查询缓存呢？</p>
<p>查询缓存是提前把 查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p>
<h3 id="缓冲池如何读取数据"><a href="#缓冲池如何读取数据" class="headerlink" title="缓冲池如何读取数据"></a><strong>缓冲池如何读取数据</strong></h3><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p>
<p>缓存在数据库中的结构和作用如下图所示：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/UGRKJJX14ZKTBQ6W4RA.png"></p>
<p><strong>如果我们执行</strong> <strong>SQL</strong> <strong>语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</strong> </p>
<h3 id="查看-设置缓冲池的大小"><a href="#查看-设置缓冲池的大小" class="headerlink" title="查看/设置缓冲池的大小"></a><strong>查看/设置缓冲池的大小</strong></h3><p>如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大小。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/LAPCFBNOLKR5L1.png"></p>
<p>你能看到此时 InnoDB 的缓冲池大小只有 134217728/1024/1024=128MB。我们可以修改缓冲池大小，比如改为256MB，方法如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size = <span class="number">268435456</span>;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server] </span><br><span class="line">innodb_buffer_pool_size = 268435456</span><br></pre></td></tr></table></figure>

<p>然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB： </p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/12312czsdsa.png"></p>
<h3 id="多个Buffer-Pool实例"><a href="#多个Buffer-Pool实例" class="headerlink" title="多个Buffer Pool实例"></a><strong>多个Buffer Pool实例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server] </span><br><span class="line">innodb_buffer_pool_instances = 2</span><br></pre></td></tr></table></figure>

<p>这样就表明我们要创建2个 Buffer Pool 实例。</p>
<p>我们看下如何查看缓冲池的个数，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_instances&#x27;;</span><br></pre></td></tr></table></figure>

<p>那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size/innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure>

<p>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p>
<h3 id="引申问题"><a href="#引申问题" class="headerlink" title="引申问题"></a><strong>引申问题</strong></h3><p>Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。</p>
<p><strong>黑盒下的更新数据流程</strong></p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/12312dffsdfse.png"></p>
<p>我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？</p>
<p>答案：<strong>Redo Log &amp; Undo Log</strong></p>
<p>这份笔记是康师傅的笔记 不得不说康师傅讲的是真好 写这份笔记只是为了更好的复习<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=52&amp;spm_id_from=pageDriver%E8%A7%86%E9%A2%91%E5%9C%A8%E8%BF%99">https://www.bilibili.com/video/BV1iq4y1u7vj?p=52&amp;spm_id_from=pageDriver视频在这</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="思考">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/%E6%80%9D%E8%80%83/%E5%AF%92%E5%81%87%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%80%9D%E8%80%83/%E5%AF%92%E5%81%87%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">寒假规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-17 21:44:17" itemprop="dateCreated datePublished" datetime="2022-01-17T21:44:17+08:00">2022-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A7%84%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">规划</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="寒假规划"><a href="#寒假规划" class="headerlink" title="寒假规划"></a>寒假规划</h1><p>目前欠缺项目经验,前几天面试感觉有些东西记得不够清楚,这段时间复习一下,在学习心得知识,学习MySQL高级,Redis,SpringCloud,以及设计模式,在自己独立做一个项目。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="MySQL">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/MySQL/mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/MySQL/mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/" class="post-title-link" itemprop="url">MySQL的数据目录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-17 21:09:48" itemprop="dateCreated datePublished" datetime="2022-01-17T21:09:48+08:00">2022-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">MySQL高级</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E9%AB%98%E7%BA%A7/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这份笔记是康师傅的笔记 不得不说康师傅讲的是真好 写这份笔记只是为了更好的复习<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=52&amp;spm_id_from=pageDriver%E8%A7%86%E9%A2%91%E5%9C%A8%E8%BF%99">https://www.bilibili.com/video/BV1iq4y1u7vj?p=52&amp;spm_id_from=pageDriver视频在这</a></p>
<h1 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h1><h2 id="MySQL8的主要目录结构"><a href="#MySQL8的主要目录结构" class="headerlink" title="MySQL8的主要目录结构"></a>MySQL8的主要目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@atguigu01 ~]# find / -name mysql</span><br></pre></td></tr></table></figure>

<p>安装好MySQL 8之后，我们查看如下的目录结构：</p>
<h3 id="数据库文件的存放路劲"><a href="#数据库文件的存放路劲" class="headerlink" title="数据库文件的存放路劲"></a>数据库文件的存放路劲</h3><p>MySQL数据库文件的存放路径：/var/lib/mysql/</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;datadir&#x27;; +---------------+-----------------+</span><br><span class="line">| Variable_name | Value | +---------------+-----------------+</span><br><span class="line">| datadir | /var/lib/mysql/ | +---------------+-----------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，在我的计算机上MySQL的数据目录就是 /var/lib/mysql/ 。 </p>
<h3 id="相关命令目录"><a href="#相关命令目录" class="headerlink" title="相关命令目录"></a>相关命令目录</h3><p>相关命令目录：/usr/bin（mysqladmin、mysqlbinlog、mysqldump等命令）和/usr/sbin。</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/awdasda32.png"></p>
<h3 id="配置文件目录"><a href="#配置文件目录" class="headerlink" title="配置文件目录"></a>配置文件目录</h3><p><strong>配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）</strong> </p>
<h2 id="数据库和文件系统的关系"><a href="#数据库和文件系统的关系" class="headerlink" title="数据库和文件系统的关系"></a>数据库和文件系统的关系</h2><h3 id="查看默认数据库"><a href="#查看默认数据库" class="headerlink" title="查看默认数据库"></a>查看默认数据库</h3><p>查看一下在我的计算机上当前有哪些数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br></pre></td></tr></table></figure>

<p>可以看到有4个数据库是属于MySQL自带的系统数据库。</p>
<ul>
<li><p>mysql</p>
<p>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p>
</li>
<li><p>information_schema</p>
</li>
</ul>
<p>​    MySQL 系统自带的数据库，这个数据库保存着MySQL服务器 维护的所有其他数据库的信息 ，比如有哪些表、哪些视图、哪些触发          器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为 元数据 。在系统数据库          information_schema 中提供了一些以innodb_sys 开头的表，用于表示内部系统表。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE information_schema; Database changed mysql&gt; SHOW TABLES LIKE &#x27;innodb_sys%&#x27;; +--------------------------------------------+</span><br><span class="line">|<span class="string"> Tables_in_information_schema (innodb_sys%) </span>|</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">|<span class="string"> INNODB_SYS_DATAFILES </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_VIRTUAL </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_INDEXES </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_TABLES </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_FIELDS </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_TABLESPACES </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_FOREIGN_COLS </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_COLUMNS </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_FOREIGN </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_TABLESTATS </span>|<span class="string"> +--------------------------------------------+</span></span><br><span class="line"><span class="string">10 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>performance_schema </p>
<p>MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等信息。</p>
</li>
<li><p>sys </p>
<p>MySQL 系统自带的数据库，这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p>
</li>
</ul>
<h3 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h3><h4 id="InnoDB存储引擎模式"><a href="#InnoDB存储引擎模式" class="headerlink" title="InnoDB存储引擎模式"></a><strong>InnoDB</strong>存储引擎模式</h4><p><strong>1.</strong> <strong>表结构</strong></p>
<p>为了保存表结构， InnoDB 在 数据目录 下对应的数据库子目录下创建了一个专门用于 描述表结构的文件 ，文件名是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure>

<p>比方说我们在 atguigu 数据库下创建一个名为 test 的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE atguigu; </span><br><span class="line">Database changed </span><br><span class="line">mysql&gt; CREATE TABLE test (</span><br><span class="line">	-&gt; c1 INT</span><br><span class="line">	-&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>那在数据库 atguigu 对应的子目录下就会创建一个名为 test.frm 的用于描述表结构的文件。.frm文件的格式在不同的平台上都是相同的。这个后缀名为.frm是以 二进制格式 存储的，我们直接打开是乱码的</p>
<p><strong>2.</strong> <strong>表中数据和索引</strong></p>
<p><strong>① 系统表空间</strong>（system tablespace）</p>
<p>默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应的 系统表空间 在文件系统上的表示。怎么才12M？注意这个文件是 自扩展文件 ，当不够用的时候它会自己增加文件大小。</p>
<p>当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的 ibdata1 这个文件名难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[server] innodb_data_file_path=data1:512M;data2:512M:autoextend</span><br></pre></td></tr></table></figure>

<p><strong>② 独立表空间</strong>(file-per-table tablespace)</p>
<p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为 每 一个表建立一个独立表空间 ，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个 .ibd 的扩展名而已，所以完整的文件名称长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.ibd</span><br></pre></td></tr></table></figure>

<p>比如：我们使用了 独立表空间 去存储 atguigu 数据库下的 test 表的话，那么在该表所在数据库对应的 atguigu 目录下会为 test 表创建这两个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.frm </span><br><span class="line">test.ibd</span><br></pre></td></tr></table></figure>

<p>其中 test.ibd 文件就用来存储 test 表中的数据和索引。</p>
<p><strong>③ 系统表空间与独立表空间的设置</strong></p>
<p>我们可以自己指定使用 系统表空间 还是 独立表空间 来存储数据，这个功能由启动参数innodb_file_per_table 控制，比如说我们想刻意将表数据都存储到 系统表空间 时，可以在启动MySQL服务器的时候这样配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[server] innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间</span><br></pre></td></tr></table></figure>

<p>默认情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_file_per_table&#x27;; +-----------------------+-------+</span><br><span class="line">| Variable_name | Value | +-----------------------+-------+</span><br><span class="line">| innodb_file_per_table | ON | +-----------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>④ 其他类型的表空间</strong></p>
<p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p>
<h4 id="MyISAM存储引擎模式"><a href="#MyISAM存储引擎模式" class="headerlink" title="MyISAM存储引擎模式"></a><strong>MyISAM</strong>存储引擎模式</h4><p><strong>1.</strong> <strong>表结构</strong></p>
<p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在 数据目录 下对应的数据库子目录下创建了一个专门用于描述表结构的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>表中数据和索引</strong></p>
<p>在MyISAM中的索引全部都是 二级索引 ，该存储引擎的 数据和索引是分开存放 的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。假如 test表使用MyISAM存储引擎的话，那么在它所在数据库对应的 atguigu 目录下会为 test 表创建这三个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.frm 存储表结构 </span><br><span class="line">test.MYD 存储数据 (MYData)</span><br><span class="line">test.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure>

<p>举例：创建一个 MyISAM 表，使用 ENGINE 选项显式指定引擎。因为 InnoDB 是默认引擎。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student_myisam` (</span><br><span class="line">`id` bigint NOT NULL AUTO_INCREMENT, </span><br><span class="line">`name` varchar(64) DEFAULT NULL, </span><br><span class="line">`age` int DEFAULT NULL, </span><br><span class="line">`sex` varchar(2) DEFAULT NULL, </span><br><span class="line">PRIMARY KEY (`id`) </span><br><span class="line">)ENGINE=MYISAM AUTO_INCREMENT=0 DEFAULTCHARSET=utf8mb3;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><p>举例： 数据库a ， 表b 。 </p>
<p>1、如果表b采用 InnoDB ，data\a中会产生1个或者2个文件：</p>
<ul>
<li><p>b.frm ：描述表结构文件，字段长度等</p>
</li>
<li><p>如果采用 系统表空间 模式的，数据信息和索引信息都存储在 ibdata1 中</p>
</li>
<li><p>如果采用 独立表空间 存储模式，data\a中还会产生 b.ibd 文件（存储数据信息和索引信息）</p>
<p>此外：</p>
</li>
</ul>
<p>① MySQL5.7 中会在data/a的目录下生成 db.opt 文件用于保存数据库的相关配置。比如：字符集、比较规则。而MySQL8.0不再提供db.opt文件。</p>
<p>② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。</p>
<p>2、如果表b采用 MyISAM ，data\a中会产生3个文件：</p>
<ul>
<li><p>MySQL5.7 中： b.frm ：描述表结构文件，字段长度等。</p>
<p>MySQL8.0 中 b.xxx.sdi ：描述表结构文件，字段长度等</p>
</li>
<li><p>b.MYD (MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式) </p>
</li>
<li><p>b.MYI (MYIndex)：存放索引信息文件</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%8D%81%E7%AB%A0-ThreadPool-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%8D%81%E7%AB%A0-ThreadPool-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">JUC系列-ThreadPool 线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-19 10:02:03" itemprop="dateCreated datePublished" datetime="2021-11-19T10:02:03+08:00">2021-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ThreadPool-线程池"><a href="#ThreadPool-线程池" class="headerlink" title="ThreadPool 线程池"></a><strong>ThreadPool 线程池</strong></h1><h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a><strong>线程池简介</strong></h2><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p>
<p>例子： 10 年前单核 CPU 电脑，假的多线程，像马戏团小丑玩多个球，CPU 需要来回切换。 现在是多核电脑，多个线程各自跑在独立的 CPU 上，不用切换效率高</p>
<p><strong>线程池的优势：</strong> 线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p><strong>它的主要特点为：</strong></p>
<ul>
<li><p>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</p>
</li>
<li><p>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
<li><p><strong>Java</strong> <strong>中的线程池是通过</strong> <strong>Executor</strong> <strong>框架实现的，该框架中用到了Executor，Executors，ExecutorService</strong>，<strong>ThreadPoolExecutor</strong> <strong>这几个类</strong></p>
</li>
</ul>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/NX1E6OPFO~GALUZ2.png"></p>
<h2 id="线程池参数说明"><a href="#线程池参数说明" class="headerlink" title="线程池参数说明"></a><strong>线程池参数说明</strong></h2><p>本次介绍 5 种类型的线程池</p>
<h3 id="常用参数-重点"><a href="#常用参数-重点" class="headerlink" title="常用参数(重点)"></a><strong>常用参数(重点)</strong></h3><ul>
<li><p>corePoolSize 线程池的核心线程数</p>
</li>
<li><p>maximumPoolSize 能容纳的最大线程数</p>
</li>
<li><p>keepAliveTime 空闲线程存活时间</p>
</li>
<li><p>unit 存活的时间单位</p>
</li>
<li><p>workQueue 存放提交但未执行任务的队列</p>
</li>
<li><p>threadFactory 创建线程的工厂类</p>
</li>
<li><p>handler 等待队列满后的拒绝策略</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/09-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%83%E4%B8%AA%E5%8F%82%E6%95%B0.png"></p>
</li>
</ul>
<p>线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize -最大线程数</p>
<p>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p>
<p>总结起来，也就是一句话，<strong>当提交的任务数大于（workQueue.size() +</strong> <strong>maximumPoolSize ），就会触发线程池的拒绝策略</strong>。</p>
<h3 id="拒绝策略-重点"><a href="#拒绝策略-重点" class="headerlink" title="拒绝策略(重点)"></a><strong>拒绝策略(重点)</strong></h3><p><strong>CallerRunsPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</p>
<p><strong>AbortPolicy</strong>: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</p>
<p><strong>DiscardPolicy</strong>: 直接丢弃，其他啥都没有</p>
<p><strong>DiscardOldestPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</p>
<h2 id="线程池的种类与创建"><a href="#线程池的种类与创建" class="headerlink" title="线程池的种类与创建"></a><strong>线程池的种类与创建</strong></h2><h3 id="newCachedThreadPool-常用"><a href="#newCachedThreadPool-常用" class="headerlink" title="newCachedThreadPool(常用)"></a><strong>newCachedThreadPool(常用)</strong></h3><p><strong>作用</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</p>
<p><strong>特点</strong>: </p>
<ul>
<li><p>线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE） </p>
</li>
<li><p>线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</p>
</li>
<li><p>当线程池中，没有可用线程，会重新创建一个线程</p>
</li>
</ul>
<p><strong>创建方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可缓存线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * corePoolSize 线程池的核心线程数</span></span><br><span class="line"><span class="comment"> * maximumPoolSize 能容纳的最大线程数</span></span><br><span class="line"><span class="comment"> * keepAliveTime 空闲线程存活时间</span></span><br><span class="line"><span class="comment"> * unit 存活的时间单位</span></span><br><span class="line"><span class="comment"> * workQueue 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="comment"> * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class="line"><span class="comment"> * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,</span><br><span class="line">            Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景:</strong> 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景</p>
<h3 id="newFixedThreadPool-常用"><a href="#newFixedThreadPool-常用" class="headerlink" title="newFixedThreadPool(常用)"></a><strong>newFixedThreadPool(常用)</strong></h3><p><strong>作用</strong>：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>
<p><strong>特征：</strong></p>
<ul>
<li><p>线程池中的线程处于一定的量，可以很好的控制线程的并发量</p>
</li>
<li><p>线程可以重复被使用，在显示关闭之前，都将一直存在</p>
</li>
<li><p>超出一定量的线程被提交时候需在队列中等待</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定长度线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * corePoolSize 线程池的核心线程数</span></span><br><span class="line"><span class="comment"> * maximumPoolSize 能容纳的最大线程数</span></span><br><span class="line"><span class="comment"> * keepAliveTime 空闲线程存活时间</span></span><br><span class="line"><span class="comment"> * unit 存活的时间单位</span></span><br><span class="line"><span class="comment"> * workQueue 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="comment"> * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class="line"><span class="comment"> * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">0L</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景:</strong> 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景</p>
<h3 id="newSingleThreadExecutor-常用"><a href="#newSingleThreadExecutor-常用" class="headerlink" title="newSingleThreadExecutor(常用)"></a><strong>newSingleThreadExecutor(常用)</strong></h3><p><strong>作用</strong>：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p>
<p><strong>特征：</strong> 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行</p>
<p><strong>创建方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单一线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * corePoolSize 线程池的核心线程数</span></span><br><span class="line"><span class="comment"> * maximumPoolSize 能容纳的最大线程数</span></span><br><span class="line"><span class="comment"> * keepAliveTime 空闲线程存活时间</span></span><br><span class="line"><span class="comment"> * unit 存活的时间单位</span></span><br><span class="line"><span class="comment"> * workQueue 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="comment"> * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class="line"><span class="comment"> * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">0L</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景:</strong> 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景</p>
<h3 id="newScheduleThreadPool-了解"><a href="#newScheduleThreadPool-了解" class="headerlink" title="newScheduleThreadPool(了解)"></a><strong>newScheduleThreadPool(了解)</strong></h3><p><strong>作用:</strong> 线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池</p>
<p><strong>特征:</strong> </p>
<p>（1）线程池中具有指定数量的线程，即便是空线程也将保留 </p>
<p>（2）可定时或者延迟执行线程活动</p>
<p><strong>创建方式:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span></span></span></span><br><span class="line"><span class="params"><span class="function">corePoolSize, </span></span></span><br><span class="line"><span class="params"><span class="function">ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, </span><br><span class="line">threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景:</strong> 适用于需要多个后台线程执行周期任务的场景</p>
<h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a><strong>newWorkStealingPool</strong></h3><p>jdk1.8 提供的线程池，底层使用的是 ForkJoinPool 实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务</p>
<p><strong>创建方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * parallelism：并行级别，通常默认为 JVM 可用的处理器个数</span></span><br><span class="line"><span class="comment"> * factory：用于创建 ForkJoinPool 中使用的线程。</span></span><br><span class="line"><span class="comment"> * handler：用于处理工作线程未处理的异常，默认为 null</span></span><br><span class="line"><span class="comment"> * asyncMode：用于控制 WorkQueue 的工作模式:队列---反队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism,</span><br><span class="line">            ForkJoinPool.defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景:</strong> 适用于大耗时，可并行执行的场景</p>
<h2 id="线程池入门案例"><a href="#线程池入门案例" class="headerlink" title="线程池入门案例"></a><strong>线程池入门案例</strong></h2><p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义线程池的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//执行</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池底层工作原理-重要"><a href="#线程池底层工作原理-重要" class="headerlink" title="线程池底层工作原理(重要)"></a><strong>线程池底层工作原理(重要)</strong></h2><ol>
<li><p>在创建了线程池后，线程池中的线程数为零</p>
</li>
<li><p>当调用 execute()方法添加一个请求任务时，线程池会做出如下判断： </p>
<p>  2.1 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p>
</li>
</ol>
<p>​         2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p>
<p>​         2.3 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p>
<p>​         2.4 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</p>
<ol start="3">
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p>
</li>
<li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p>
</li>
</ol>
<p>​        4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。 </p>
<p>​        4.2 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/MVHC8Z%60_WAQLC_HX.png"></p>
<h2 id="注意事项-重要"><a href="#注意事项-重要" class="headerlink" title="注意事项(重要)"></a><strong>注意事项(重要)</strong></h2><ol>
<li><p>项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参数，自定义线程池</p>
</li>
<li><p>创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建</p>
</li>
</ol>
<p>o corePoolSize 线程池的核心线程数</p>
<p>o maximumPoolSize 能容纳的最大线程数</p>
<p>o keepAliveTime 空闲线程存活时间</p>
<p>o unit 存活的时间单位</p>
<p>o workQueue 存放提交但未执行任务的队列</p>
<p>o threadFactory 创建线程的工厂类</p>
<p>o handler 等待队列满后的拒绝策略</p>
<ol start="3">
<li>为什么不允许适用不允许 Executors.的方式手动创建线程池,如下图</li>
</ol>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/~ZC%7DKX7O11V40S2TZGE.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="思考">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/%E6%80%9D%E8%80%83/%E5%9B%A2%E9%98%9F%E7%B2%BE%E7%A5%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%80%9D%E8%80%83/%E5%9B%A2%E9%98%9F%E7%B2%BE%E7%A5%9E/" class="post-title-link" itemprop="url">团队精神</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-17 13:50:25" itemprop="dateCreated datePublished" datetime="2021-11-17T13:50:25+08:00">2021-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%A2%E9%98%9F/" itemprop="url" rel="index"><span itemprop="name">团队</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="团队精神"><a href="#团队精神" class="headerlink" title="团队精神"></a>团队精神</h1><p>为什么要谈这个话题 因为最近读了一本叫做浪潮之巅的书籍 有所思考 首先团队精神是什么呢？</p>
<p>百度百科中是这样解释的</p>
<blockquote>
<p>团队精神是大局意识、协作精神和服务精神的集中体现，核心是协同合作，反映的是个体利益和整体利益的统一，并进而保证组织的高效率运转。 团队精神的形成并不要求团队成员牺牲自我，相反，挥洒个性、表现特长保证了成员共同完成任务目标，而明确的协作意愿和协作方式则产生了真正的内心动力。</p>
</blockquote>
<p> 一个团队首先要有一个优秀的领导者，比如IBM的郭士纳,苹果公司的乔布斯,惠普公司的马克赫德。</p>
<p>优秀的领导者能做什么呢？我认为一个优秀的领导者可以带领你前进的方向，让你的方向正确。我们通常说选择大于努力</p>
<p>可能也是因为这个吧。</p>
<blockquote>
<p>例如现在的it行业培训机构 我认为就是只是培训 而一个行业如果想要做好 不付出是不可能的。大家如果都只是来随便讲讲课</p>
<p>聊聊天,那么这种培训机构宁愿不要去。老师应该去教会别人怎样去思考,而不是一味的去叫一门技术,难道五年后技术变革之后在</p>
<p>没人报一个培训班吗？显然不可能</p>
</blockquote>
<p> 第二点就是要有“叛逆”精神大家没必要觉得老师说的都是对的,他只不过比我们多学了10几年而已。我们作为二十一实际的年轻人,应该具有思辨性。不应该全部听从老师的,我们应该去多于团队之间的人间交流,进行思维的碰撞。让自己的认知得到提高</p>
<p>我认为好的团队就是一下几点</p>
<ul>
<li>有一个优秀的领导者</li>
<li>团队氛围(积极的进行思维的交流于碰撞)</li>
</ul>
<p>当然这些太过于理想化,如果一个团队有我想象中的这么美好。我相信一定是战无不胜的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">JUC系列-阻塞队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-17 10:02:03" itemprop="dateCreated datePublished" datetime="2021-11-17T10:02:03+08:00">2021-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a><strong>阻塞队列</strong></h1><h2 id="BlockingQueue-简介"><a href="#BlockingQueue-简介" class="headerlink" title="BlockingQueue 简介"></a><strong>BlockingQueue 简介</strong></h2><p>Concurrent 包中，BlockingQueue 很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了 BlockingQueue 家庭中的所有成员，包括他们各自的功能以及常见使用场景。</p>
<p>阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/07-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png"></p>
<p>当队列是空的，从队列中获取元素的操作将会被阻塞</p>
<p>当队列是满的，从队列中添加元素的操作将会被阻塞</p>
<p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</p>
<p>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</p>
<p>常用的队列主要有以下两种：</p>
<ul>
<li><p>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性</p>
</li>
<li><p>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)</p>
</li>
</ul>
<p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p>
<p>为什么需要 BlockingQueue</p>
<p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都给你一手包办了</p>
<p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细</p>
<p>节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<p>多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和 “消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。</p>
<ul>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），</li>
</ul>
<p>直到有数据放入队列</p>
<ul>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），</li>
</ul>
<p>直到队列中有空的位置，线程被自动唤醒</p>
<h2 id="BlockingQueue-核心方法"><a href="#BlockingQueue-核心方法" class="headerlink" title="BlockingQueue 核心方法"></a><strong>BlockingQueue 核心方法</strong></h2><p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/2SZZBY7T3L~[P3]YPH.png"></p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/37DFEN2P99JCAYRGAP.png"></p>
<p><strong>BlockingQueue 的核心方法</strong>：</p>
<p><strong>1.放入数据</strong></p>
<ul>
<li><p>offer(anObject):表示如果可能的话,将 anObject 加BlockingQueue 里,即如果 BlockingQueue 可以容纳,则返回 true,否则返回 false.<strong>（本方法不阻塞当前执行方法的线程）</strong></p>
</li>
<li><p>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败</p>
</li>
<li><p>put(anObject):把 anObject 加到 BlockingQueue 里,如果 BlockQueue 没有空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续.</p>
</li>
</ul>
<p><strong>2.获取数据</strong></p>
<ul>
<li><p>poll(time): 取走 BlockingQueue 里排在首位的对象,若不能立即取出,<strong>则可以等****time 参数规定的时间,取不到时返回 null</strong></p>
</li>
<li><p>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</p>
</li>
<li><p>take(): 取走 BlockingQueue 里排在首位的对象,BlockingQueue 为空,<strong>阻断进入等待状态直到 BlockingQueue 有新的数据被加入</strong>; </p>
</li>
<li><p>drainTo(): 一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p>
</li>
</ul>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a><strong>入门案例</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.blockingqueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// List list = new ArrayList();</span></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//第一组</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.add(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.add(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.add(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.element());</span></span><br><span class="line"><span class="comment">//System.out.println(blockingQueue.add(&quot;x&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;x&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// 第三组</span></span><br><span class="line"><span class="comment">// blockingQueue.put(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">// blockingQueue.put(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">// blockingQueue.put(&quot;c&quot;);</span></span><br><span class="line"><span class="comment">// //blockingQueue.put(&quot;x&quot;);</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// 第四组</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>,<span class="number">3L</span>, TimeUnit.SECONDS));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见的-BlockingQueue"><a href="#常见的-BlockingQueue" class="headerlink" title="常见的 BlockingQueue"></a><strong>常见的 BlockingQueue</strong></h2><h3 id="ArrayBlockingQueue-常用"><a href="#ArrayBlockingQueue-常用" class="headerlink" title="ArrayBlockingQueue(常用)"></a><strong>ArrayBlockingQueue(常用)</strong></h3><p>基于数组的阻塞队列实现，在 ArrayBlockingQueue 内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p>
<p>ArrayBlockingQueue 在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue 完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea 之所以没这样去做，也许是因为 ArrayBlockingQueue 的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue 和LinkedBlockingQueue 间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node 对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC 的影响还是存在一定的区别。而在创建 ArrayBlockingQueue 时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<p><strong>一句话总结: 由数组结构组成的有界阻塞队列。</strong></p>
<h3 id="LinkedBlockingQueue-常用"><a href="#LinkedBlockingQueue-常用" class="headerlink" title="LinkedBlockingQueue(常用)"></a><strong>LinkedBlockingQueue(常用)</strong></h3><p>基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue 可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>
<p><strong>ArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</strong></p>
<p><strong>一句话总结: 由链表结构组成的有界（但大小默认值integer.MAX_VALUE）阻塞队列。</strong></p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><strong>DelayQueue</strong></h3><p>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
<p><strong>一句话总结: 使用优先级队列实现的延迟无界阻塞队列。</strong></p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><strong>PriorityBlockingQueue</strong></h3><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的 Compator 对象来决定），但需要注意的是 PriorityBlockingQueue 并<strong>不会阻塞数据生产者，而****只会在没有可消费的数据时，阻塞数据的消费者</strong>。</p>
<p>因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费****数据的速度</strong>，否则时间一长，会最终耗尽所有的可用堆内存空间。</p>
<p>在实现 PriorityBlockingQueue 时，内部控制线程同步的锁采用的是<strong>公平锁</strong>。</p>
<p><strong>一句话总结: 支持优先级排序的无界阻塞队列。</strong></p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><strong>SynchronousQueue</strong></h3><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p>
<p>声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的行为</p>
<p><strong>公平模式和非公平模式的区别:</strong> </p>
<ul>
<li><p>公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</p>
</li>
<li><p>非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
</li>
</ul>
<p><strong>一句话总结: 不存储元素的阻塞队列，也即单个元素的队列。</strong></p>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a><strong>LinkedTransferQueue</strong></h3><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和transfer 方法。</p>
<p>LinkedTransferQueue 采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。</p>
<p><strong>一句话总结: 由链表组成的无界阻塞队列。</strong></p>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a><strong>LinkedBlockingDeque</strong></h3><p>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。</p>
<p>对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况 </p>
<ul>
<li><p>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异 常 </p>
</li>
<li><p>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</p>
</li>
</ul>
<p><strong>一句话总结: 由链表组成的双向阻塞队列</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><strong>1. 在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</strong></p>
<p><strong>2. 为什么需要 BlockingQueue?</strong> 在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给你一手包办了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%AF%BB%E5%86%99%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%AF%BB%E5%86%99%E9%94%81/" class="post-title-link" itemprop="url">JUC系列-读写锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-16 22:09:03" itemprop="dateCreated datePublished" datetime="2021-11-16T22:09:03+08:00">2021-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><strong>回顾悲观锁和乐观锁的概念</strong><br><strong>悲观锁</strong>：单独每个人完成事情的时候，执行上锁解锁。解决并发中的问题，不支持并发操作，只能一个一个操作，效率低<br><strong>乐观锁</strong>：每执行一件事情，都会比较数据版本号，谁先提交，谁先提交版本号</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/05-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.png"></p>
<p>新概念：<br>表锁：整个表操作，不会发生死锁<br>行锁：每个表中的单独一行进行加锁，会发生死锁<br>读锁：共享锁（可以有多个人读），会发生死锁<br>写锁：独占锁（只能有一个人写），会发生死锁</p>
<p>读写锁：一个资源可以被多个读线程访问，也可以被一个写线程访问，但不能同时存在读写线程，读写互斥，读读共享</p>
<p>读写锁ReentrantReadWriteLock<br>读锁为ReentrantReadWriteLock.ReadLock，readLock()方法<br>写锁为ReentrantReadWriteLock.WriteLock，writeLock()方法</p>
<p>创建读写锁对象private ReadWriteLock rwLock = new ReentrantReadWriteLock();<br>写锁 加锁 rwLock.writeLock().lock();，解锁为rwLock.writeLock().unlock();<br>读锁 加锁rwLock.readLock().lock();，解锁为rwLock.readLock().unlock();</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/08-%E8%AF%BB%E5%86%99%E9%94%81.png"></p>
<h2 id="读写锁介绍"><a href="#读写锁介绍" class="headerlink" title="读写锁介绍"></a><strong>读写锁介绍</strong></h2><p>现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。</p>
<p>针对这种场景，<strong>JAVA 的并发包提供了读写锁 ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁</strong></p>
<ol>
<li>线程进入读锁的前提条件：</li>
</ol>
<ul>
<li><p>没有其他线程的写锁</p>
</li>
<li><p>没有写请求, 或者==有写请求，但调用线程和持有锁的线程是同一个(可重入锁)。</p>
</li>
</ul>
<ol start="2">
<li>线程进入写锁的前提条件：</li>
</ol>
<ul>
<li><p>没有其他线程的读锁</p>
</li>
<li><p>没有其他线程的写锁</p>
</li>
</ul>
<p>而读写锁有以下三个重要的特性：</p>
<p>（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公</p>
<p>平优于公平。</p>
<p>（2）重进入：读锁和写锁都支持线程重进入。</p>
<p>（3）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为</p>
<p>读锁。</p>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a><strong>ReentrantReadWriteLock</strong></h2><p>ReentrantReadWriteLock 类的整体结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>,</span></span><br><span class="line"><span class="class">        <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 读锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** 写锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用默认（非公平）的排序属性创建一个新的</span></span><br><span class="line"><span class="comment">     ReentrantReadWriteLock */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回用于写入操作的锁 */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span></span><br><span class="line">            writerLock; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回用于读取操作的锁 */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock <span class="title">readLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span></span><br><span class="line">            readerLock; &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，ReentrantReadWriteLock 实现了 ReadWriteLock 接口，ReadWriteLock 接口定义了获取读锁和写锁的规范，具体需要实现类去实现；同时其还实现了 Serializable 接口，表示可以进行序列化，在源代码中可以看到 ReentrantReadWriteLock 实现了自己的序列化逻辑。</p>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a><strong>入门案例</strong></h2><p><strong>场景: 使用 ReentrantReadWriteLock 对一个 hashmap 进行读和写操作</strong></p>
<p>实现案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.readwrite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建map集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建读写锁的对象</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//添加写锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;正在写操作&quot;</span> + key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停一会</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="comment">//放数据</span></span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写完了&quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//添加读锁</span></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在取操作&quot;</span>);</span><br><span class="line">        <span class="comment">//暂停一会</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取完 &quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放读锁</span></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="comment">//创建线程放数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                myCache.put(num+<span class="string">&quot;&quot;</span>,num+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建线程取数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                myCache.get(num+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结-重要"><a href="#小结-重要" class="headerlink" title="小结(重要)"></a><strong>小结(重要)</strong></h2><ul>
<li><p>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。 </p>
</li>
<li><p>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p>
</li>
</ul>
<p>原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%83%E7%AB%A0-JUC-%E4%B8%89%E5%A4%A7%E8%BE%85%E5%8A%A9%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%83%E7%AB%A0-JUC-%E4%B8%89%E5%A4%A7%E8%BE%85%E5%8A%A9%E7%B1%BB/" class="post-title-link" itemprop="url">JUC系列-JUC 三大辅助类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-16 20:03:03" itemprop="dateCreated datePublished" datetime="2021-11-16T20:03:03+08:00">2021-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JUC-三大辅助类"><a href="#JUC-三大辅助类" class="headerlink" title="JUC 三大辅助类"></a><strong>JUC 三大辅助类</strong></h1><p>JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时 Lock 锁的频繁操作。这三种辅助类为：</p>
<p>• CountDownLatch: 减少计数</p>
<p>• CyclicBarrier: 循环栅栏</p>
<p>• Semaphore: 信号灯</p>
<p>下面我们分别进行详细的介绍和学习</p>
<h2 id="减少计数-CountDownLatch"><a href="#减少计数-CountDownLatch" class="headerlink" title="减少计数 CountDownLatch"></a><strong>减少计数 CountDownLatch</strong></h2><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。</p>
<ul>
<li>CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，这</li>
</ul>
<p>些线程会阻塞</p>
<ul>
<li>其它线程调用 countDown 方法会将计数器减 1(调用 countDown 方法的线程</li>
</ul>
<p>不会阻塞) </p>
<ul>
<li>当计数器的值变为 0 时，因 await 方法阻塞的线程会被唤醒，继续执行</li>
</ul>
<p><strong>场景: 6 个同学陆续离开教室后值班同学才可以关门。</strong></p>
<p>CountDownLatchDemo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示CountDownLatch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//六个同学陆续离开教室之后,班长锁门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建CountDownLatch对象m设置初始值</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//六个同学陆续离开教室之后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;号同学离开了教室&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计数</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;班长锁门走人了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环栅栏-CyclicBarrier"><a href="#循环栅栏-CyclicBarrier" class="headerlink" title="循环栅栏 CyclicBarrier"></a><strong>循环栅栏 CyclicBarrier</strong></h2><p>CyclicBarrier 看英文单词可以看出大概就是循环阻塞的意思，在使用中CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</p>
<p>该类是一个同步辅助类，允许一组县城互相等到，直到到达某个公共屏障点，在设计一组固定大小的线程的程序中，这些线程必须互相等待，这个类很有用，因为barrier在释放等待线程后可以重用，所以称为循环barrier</p>
<p>常用的构造方法有：<br>CyclicBarrier(int parties，Runnable barrierAction)创建一个新的CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动barrier时执行给定的屏障操作，该操作由最后一个进入barrier的线程操作</p>
<p>常用的方法有：</p>
<blockquote>
<p>await()在所有的参与者都已 经在此barrier上调用await方法之前一直等待</p>
</blockquote>
<p><strong>场景: 集齐 7 颗龙珠就可以召唤神龙</strong></p>
<p>CyclicBarrierDemo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集齐7颗龙珠可以召唤神龙</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建固定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUMBER,()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;集齐7颗龙珠就可以召唤神龙&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//集齐七颗龙珠过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;星龙珠收集到了&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong><br>CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</p>
<h2 id="信号灯-Semaphore"><a href="#信号灯-Semaphore" class="headerlink" title="信号灯 Semaphore"></a><strong>信号灯 Semaphore</strong></h2><p>Semaphore 的构造方法中传入的第一个参数是最大信号量（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证。使用 acquire 方法获得许可证，release 方法释放许可</p>
<p>场景: 抢车位, 6 部汽车 3 个停车位</p>
<p>SemaphoreDemo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//六辆汽车,停三个停车位</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Semaphore,设置许可数量</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟六辆汽车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//抢占</span></span><br><span class="line">                   semaphore.acquire();</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到了车位&quot;</span>);</span><br><span class="line">                   <span class="comment">//设置随机停车时间</span></span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;------离开了车位&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">//释放</span></span><br><span class="line">                   semaphore.release();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%85%AD%E7%AB%A0-Callable-Future-%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%85%AD%E7%AB%A0-Callable-Future-%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">JUC系列-Callable&Future 接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-16 17:03:03" itemprop="dateCreated datePublished" datetime="2021-11-16T17:03:03+08:00">2021-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Callable-amp-Future-接口"><a href="#Callable-amp-Future-接口" class="headerlink" title="Callable&amp;Future 接口"></a><strong>Callable&amp;Future 接口</strong></h1><h2 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a><strong>Callable 接口</strong></h2><p>目前我们学习了有两种创建线程的方法-一种是通过创建 Thread 类，另一种是通过使用 Runnable 创建线程。但是，Runnable 缺少的一项功能是，当线程终止时（即 run（）完成时），我们无法使线程返回结果。为了支持此功能，</p>
<p>Java 中提供了 Callable 接口。</p>
<p>==<strong>现在我们学习的是创建线程的第三种方案—Callable 接口</strong>==</p>
<p><strong>Callable 接口的特点如下(重点)</strong> </p>
<ul>
<li>为了实现 Runnable，需要实现不返回任何内容的 run（）方法，而对于</li>
</ul>
<p>Callable，需要实现在完成时返回结果的 call（）方法。</p>
<ul>
<li><p> call（）方法可以引发异常，而 run（）则不能。</p>
</li>
<li><p>为实现 Callable 而必须重写 call 方法</p>
</li>
<li><p>不能直接替换 runnable,因为 Thread 类的构造方法根本没有 Callable</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">创建新类 MyThread1 实现 runnable 接口</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现Callable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a><strong>Future 接口</strong></h2><p>当 call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用 Future 对象。</p>
<p>将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦Callable 返回）。Future 基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下: </p>
<p>• <strong>public boolean cancel（boolean mayInterrupt）：</strong>用于停止任务。</p>
<p>==如果尚未启动，它将停止任务。如果已启动，则仅在 mayInterrupt 为 true时才会中断任务。==</p>
<p>• <strong>public Object get（）抛出 InterruptedException，ExecutionException：</strong>用于获取任务的结果。</p>
<p>==如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。</p>
<p>==</p>
<p>• <strong>public boolean isDone（）：</strong>如果任务完成，则返回 true，否则返回 false可以看到 Callable 和 Future 做两件事-Callable 与 Runnable 类似，因为它封装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结果。实际上，future 也可以与 Runnable 一起使用。</p>
<p>要创建线程，需要 Runnable。为了获得结果，需要 future。 </p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a><strong>FutureTask</strong></h2><p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建Thread 对象。因此，间接地使用 Callable 创建线程。</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/06-futureTask.png"></p>
<p><strong>核心原理:(重点)</strong></p>
<p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成</p>
<ul>
<li><p>当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执行状态</p>
</li>
<li><p> 一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>
</li>
<li><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法</p>
</li>
<li><p>一旦计算完成，就不能再重新开始或取消计算</p>
</li>
<li><p>get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常</p>
</li>
<li><p>get 只计算一次,因此 get 方法放到最后</p>
</li>
</ul>
<p><strong>demo 案例</strong></p>
<h2 id="使用-Callable-和-Future"><a href="#使用-Callable-和-Future" class="headerlink" title="使用 Callable 和 Future"></a><strong>使用 Callable 和 Future</strong></h2><p>CallableDemo 案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两个接口</span></span><br><span class="line"><span class="comment">//实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现Callable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//Runnable接口创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1(),<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Callable接口创建线程</span></span><br><span class="line">        <span class="comment">//new Thread(new MyThread2(),&quot;BB&quot;).start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//FutureTask</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lam表达式</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;come in callable&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask2,<span class="string">&quot;luck&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!futureTask2.isDone())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;wait.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用FutureTask的get方法</span></span><br><span class="line">        System.out.println(futureTask2.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;come over&quot;</span>);</span><br><span class="line">        <span class="comment">//FutureTask原理  未来任务</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.老师来了,口渴了,去买水不合适,讲课线程继续</span></span><br><span class="line"><span class="comment">         * 单开启线程找班上班长帮我买水,把水买回来,需要时直接get</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2.4个同学, 1同学 1+2...5 , 2同学 10+11+12...50 3同学 60+61+62， 4同学 100+200</span></span><br><span class="line"><span class="comment">         *  第二个同学计算量比较大,</span></span><br><span class="line"><span class="comment">         *  FutureTask单开启线程给2同学计算,先汇总 1 3 4, 最后等2同学计算位完成,统一汇总</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3.考试, 做会做的题目,最后看不会做的题目</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 汇总一次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="小结-重点"><a href="#小结-重点" class="headerlink" title="小结(重点)"></a><strong>小结(重点)</strong></h2><ul>
<li><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成, 当主线程将来需要时，就可以通过 Future对象获得后台作业的计算结果或者执行状态</p>
</li>
<li><p>  一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果</p>
</li>
<li><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</p>
</li>
<li><p> 只计算一次</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/" class="post-title-link" itemprop="url">JUC系列-多线程锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-15 17:03:03" itemprop="dateCreated datePublished" datetime="2021-11-15T17:03:03+08:00">2021-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="多线程锁"><a href="#多线程锁" class="headerlink" title="多线程锁"></a>多线程锁</h1><h2 id="锁的八个问题演示"><a href="#锁的八个问题演示" class="headerlink" title="锁的八个问题演示"></a><strong>锁的八个问题演示</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//停留4秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------getHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用锁的对象机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock_8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// phone.sendEmail();</span></span><br><span class="line">               <span class="comment">// phone.getHello();</span></span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体八种情况为</p>
<blockquote>
<p>1 标准访问，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>2 停4秒在短信方法内，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>3 新增普通的hello方法，是先打短信还是hello<br>——getHello<br>——sendSMS<br>4 现在有两部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS<br>5 两个静态同步方法，1部手机，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>6 两个静态同步方法，2部手机，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>7 1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS<br>8 1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS</p>
</blockquote>
<p><strong>结论</strong><strong>:</strong></p>
<p>一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，</p>
<p>其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized 方法</p>
<p>锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized 方法</p>
<p>加个普通方法后发现和同步锁无关</p>
<p>换成两个对象后，不是同一把锁了，情况立刻变化。</p>
<p>synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。</p>
<p><strong>具体表现为以下</strong> <strong>3</strong> <strong>种形式。</strong></p>
<p><strong>对于普通同步方法，锁是当前实例对象。</strong></p>
<p><strong>对于静态同步方法，锁是当前类的</strong> <strong>Class</strong> <strong>对象。</strong></p>
<p><strong>对于同步方法块，锁是</strong> <strong>Synchonized</strong> <strong>括号里配置的对象</strong></p>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，</p>
<p>可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</p>
<p>但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><ul>
<li><strong>公平锁</strong>：效率相对低</li>
<li><strong>非公平锁</strong>：效率高，但是线程容易饿死</li>
</ul>
<p>通过查看源码<br>带有参数的<code>ReentrantLock(true)</code>为<strong>公平锁</strong><br><code>ReentrantLock(false)</code>为<strong>非公平锁</strong><br>主要是调用<code>NonfairSync()</code>与<code>FairSync()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>具体其非公平锁与公平锁的源码<br>查看公平锁的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Acquires only if reentrant or queue is empty.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initialTryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Thread current = Thread.currentThread();</span><br><span class="line">   <span class="keyword">int</span> c = getState();</span><br><span class="line">   <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!hasQueuedThreads() &amp;&amp; compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">     setExclusiveOwnerThread(current);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getExclusiveOwnerThread() == current) &#123;</span><br><span class="line">      <span class="keyword">if</span> (++c &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(c);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过代码实例具体操作</p>
<p>在最前面售票代码中<br>继续引用前面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步  创建资源类，定义属性和和操作方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LTicket</span> </span>&#123;</span><br><span class="line">    <span class="comment">//票数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//卖票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否有票</span></span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ：卖出&quot;</span>+(number--)+<span class="string">&quot; 剩余：&quot;</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LSaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第二步 创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="comment">//创建三个线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LTicket ticket = <span class="keyword">new</span> LTicket();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        ticket.sale();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都是A线程执行，而BC线程都没执行到，出现了<strong>非公平锁</strong><br>具体改变其设置可以通过可重入锁中的一个有参构造方法</p>
<p>修改代码为<code>private final ReentrantLock lock = new ReentrantLock(true);</code><br>代码截图为</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/R07HNGWKR.png"></p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>synchronized和lock都是可重入锁</p>
<ul>
<li>sychronized是隐式锁，不用手工上锁与解锁，而lock为显示锁，需要手工上锁与解锁</li>
<li>可重入锁也叫递归锁</li>
</ul>
<p>而且有了可重入锁之后，破解第一把之后就可以一直进入到内层结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 外层&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 中层&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 内层&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p><code>synchronized (o)</code>代表锁住当前<code>&#123; &#125;</code>内的代码块</p>
<p>以上都是synchronized锁机制<br>下面讲解lock锁机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Lock演示可重入锁</span></span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//上锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 外层&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//上锁</span></span><br><span class="line">                    lock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 内层&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放做</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在同一把锁中的嵌套锁，内部嵌套锁没解锁还是可以输出，但是如果跳出该线程，执行另外一个线程就会造成死锁<br>要把握上锁与解锁的概念，都要写上</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/16-%E6%AD%BB%E9%94%81.png"></p>
<p><strong>产生死锁的原因：</strong></p>
<ol>
<li>系统资源不足</li>
<li>系统资源分配不当</li>
<li>进程运行顺序不当</li>
</ol>
<p><strong>验证是否是死锁</strong></p>
<ol>
<li>jps 类似于linux中的<code>ps -ef</code>查看进程号</li>
<li>jstack 自带的堆栈跟踪工具</li>
</ol>
<p>通过用idea自带的命令行输入 <code>jps -l</code><br>查看其编译代码的进程号后<code>jstack 进程号</code></p>
<p><strong>具体死锁的操作代码实列</strong><br>可理解背下来，大厂面试可考，死锁的简单案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个对象</span></span><br><span class="line">    <span class="keyword">static</span> Object a = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object b = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 持有锁a，试图获取锁b&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获取锁b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 持有锁b，试图获取锁a&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获取锁a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/archives/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/archives/4/">4</a><a class="extend next" rel="next" href="/archives/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
