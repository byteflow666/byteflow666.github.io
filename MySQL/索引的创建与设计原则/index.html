<!DOCTYPE html>
<html lang="MySQL">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite-url","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="索引的声明与使用索引的分类MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。  从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引 按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。 按照 作用字段个数 进行划分，分成单列索引和联合索引。  1. 普通索引 2. 唯一性索引 3. 主键索引 4. 单列索引 5. 多">
<meta property="og:type" content="article">
<meta property="og:title" content="索引的创建与设计原则">
<meta property="og:url" content="http://yoursite-url/MySQL/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/index.html">
<meta property="og:site_name" content="Study Node">
<meta property="og:description" content="索引的声明与使用索引的分类MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。  从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引 按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。 按照 作用字段个数 进行划分，分成单列索引和联合索引。  1. 普通索引 2. 唯一性索引 3. 主键索引 4. 单列索引 5. 多">
<meta property="og:locale">
<meta property="og:image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/VW2I77ZC3MEC%600_ILWYOZ1F.png">
<meta property="og:image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/1321sdfsdfsdf.png">
<meta property="article:published_time" content="2022-02-10T14:10:44.000Z">
<meta property="article:modified_time" content="2022-02-10T14:10:44.000Z">
<meta property="article:author" content="Hao">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/VW2I77ZC3MEC%600_ILWYOZ1F.png">


<link rel="canonical" href="http://yoursite-url/MySQL/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"MySQL","comments":true,"permalink":"http://yoursite-url/MySQL/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","path":"MySQL/索引的创建与设计原则/","title":"索引的创建与设计原则"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>索引的创建与设计原则 | Study Node</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Study Node</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">True mastery of any skill takes a lifetime</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">索引的声明与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">索引的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">1.2.</span> <span class="nav-text">创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">创建表的时候创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%E4%B8%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">在已经存在的表上创建索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.</span> <span class="nav-text">删除索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL8-0%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">MySQL8.0索引新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.</span> <span class="nav-text">支持降序索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.</span> <span class="nav-text">隐藏索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">3.</span> <span class="nav-text">索引的设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="nav-number">3.1.</span> <span class="nav-text">数据准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.</span> <span class="nav-text">哪些情况适合创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E5%80%BC%E6%9C%89%E5%94%AF%E4%B8%80%E6%80%A7%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. 字段的数值有唯一性的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%A2%91%E7%B9%81%E4%BD%9C%E4%B8%BA-WHERE-%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. 频繁作为 WHERE 查询条件的字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BB%8F%E5%B8%B8-GROUP-BY-%E5%92%8C-ORDER-BY-%E7%9A%84%E5%88%97"><span class="nav-number">3.2.3.</span> <span class="nav-text">3. 经常 GROUP BY 和 ORDER BY 的列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-UPDATE%E3%80%81DELETE-%E7%9A%84WHERE-%E6%9D%A1%E4%BB%B6%E5%88%97"><span class="nav-number">3.2.4.</span> <span class="nav-text">4. UPDATE、DELETE 的WHERE 条件列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-DISTINCT-%E5%AD%97%E6%AE%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.5.</span> <span class="nav-text">5.DISTINCT 字段需要创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%A4%9A%E8%A1%A8-JOIN-%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.2.6.</span> <span class="nav-text">6. 多表 JOIN 连接操作时，创建索引注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BD%BF%E7%94%A8%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.7.</span> <span class="nav-text">7. 使用列的类型小的创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.8.</span> <span class="nav-text">8. 使用字符串前缀创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%8C%BA%E5%88%86%E5%BA%A6%E9%AB%98-%E6%95%A3%E5%88%97%E6%80%A7%E9%AB%98-%E7%9A%84%E5%88%97%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.9.</span> <span class="nav-text">9. 区分度高(散列性高)的列适合作为索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E4%BD%BF%E7%94%A8%E6%9C%80%E9%A2%91%E7%B9%81%E7%9A%84%E5%88%97%E6%94%BE%E5%88%B0%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A6%E4%BE%A7"><span class="nav-number">3.2.10.</span> <span class="nav-text">10. 使用最频繁的列放到联合索引的左侧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E9%83%BD%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BC%98%E4%BA%8E%E5%8D%95%E5%80%BC%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.11.</span> <span class="nav-text">11. 在多个字段都要创建索引的情况下，联合索引优于单值索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="nav-number">3.3.</span> <span class="nav-text">限制索引的数目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.</span> <span class="nav-text">哪些情况不适合创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9C%A8where%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%88%B0%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%AE%BE%E7%BD%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.1.</span> <span class="nav-text">1. 在where中使用不到的字段，不要设置索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B0%8F%E7%9A%84%E8%A1%A8%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.2.</span> <span class="nav-text">2. 数据量小的表最好不要使用索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9C%89%E5%A4%A7%E9%87%8F%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%97%E4%B8%8A%E4%B8%8D%E8%A6%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.3.</span> <span class="nav-text">3. 有大量重复数据的列上不要建立索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%81%BF%E5%85%8D%E5%AF%B9%E7%BB%8F%E5%B8%B8%E6%9B%B4%E6%96%B0%E7%9A%84%E8%A1%A8%E5%88%9B%E5%BB%BA%E8%BF%87%E5%A4%9A%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.4.</span> <span class="nav-text">4. 避免对经常更新的表创建过多的索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8%E6%97%A0%E5%BA%8F%E7%9A%84%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.5.</span> <span class="nav-text">5. 不建议用无序的值作为索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%88%A0%E9%99%A4%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8%E6%88%96%E8%80%85%E5%BE%88%E5%B0%91%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.6.</span> <span class="nav-text">6. 删除不再使用或者很少使用的索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%B8%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E5%86%97%E4%BD%99%E6%88%96%E9%87%8D%E5%A4%8D%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.7.</span> <span class="nav-text">7. 不要定义冗余或重复的索引</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hao"
      src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
  <p class="site-author-name" itemprop="name">Hao</p>
  <div class="site-description" itemprop="description">It's an IT blog...</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/byteflow666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;byteflow666" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://mail.qq.com/cgi-bin/frame_html?sid=1aPXzaqY4yWqbjhZ&r=98902ddef6ed390980f08fe54374e19b" title="E-Mail → https:&#x2F;&#x2F;mail.qq.com&#x2F;cgi-bin&#x2F;frame_html?sid&#x3D;1aPXzaqY4yWqbjhZ&amp;r&#x3D;98902ddef6ed390980f08fe54374e19b" rel="noopener" target="_blank">E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="MySQL">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/MySQL/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          索引的创建与设计原则
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-10 22:10:44" itemprop="dateCreated datePublished" datetime="2022-02-10T22:10:44+08:00">2022-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">MySQL高级</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E9%AB%98%E7%BA%A7/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="索引的声明与使用"><a href="#索引的声明与使用" class="headerlink" title="索引的声明与使用"></a><strong>索引的声明与使用</strong></h1><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p>
<ul>
<li>从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引</li>
<li>按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。</li>
<li>按照 作用字段个数 进行划分，分成单列索引和联合索引。</li>
</ul>
<p><strong>1.</strong> <strong>普通索引</strong></p>
<p><strong>2.</strong> <strong>唯一性索引</strong></p>
<p><strong>3.</strong> <strong>主键索引</strong></p>
<p><strong>4.</strong> <strong>单列索引</strong></p>
<p><strong>5.</strong> <strong>多列(组合、联合)索引</strong></p>
<p><strong>6.</strong> <strong>全文索引</strong></p>
<p><strong>7.</strong> <strong>补充：空间索引</strong></p>
<p><strong>小结：不同的存储引擎支持的索引类型也不一样</strong> <strong>InnoDB</strong> <strong>：</strong>支持 B-tree、Full-text 等索引，不支持 Hash索引； <strong>MyISAM</strong> <strong>：</strong> 支持 B-tree、Full-text 等索引，不支持 Hash 索引； <strong>Memory</strong> <strong>：</strong>支持 B-tree、Hash 等索引，不支持 Full-text 索引； <strong>NDB</strong> <strong>：</strong>支持 Hash 索引，不支持 B-tree、Full-text 等索引； <strong>Archive</strong> <strong>：</strong>不支持 B-tree、Hash、Full-text 等索引；</p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a><strong>创建索引</strong></h2><h3 id="创建表的时候创建索引"><a href="#创建表的时候创建索引" class="headerlink" title="创建表的时候创建索引"></a><strong>创建表的时候创建索引</strong></h3><p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE dept( </span><br><span class="line">dept_id INT PRIMARY KEY AUTO_INCREMENT, </span><br><span class="line">dept_name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp( </span><br><span class="line">emp_id INT PRIMARY KEY AUTO_INCREMENT, </span><br><span class="line">emp_name VARCHAR(20) UNIQUE, </span><br><span class="line">dept_id INT, </span><br><span class="line">CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id) );</span><br></pre></td></tr></table></figure>

<p>但是，如果显式创建表时创建索引的话，基本语法格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type] </span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br></pre></td></tr></table></figure>

<ul>
<li>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；</li>
<li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；</li>
<li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li>
<li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li>
<li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li>
<li>ASC 或 DESC 指定升序或者降序的索引值存储。</li>
</ul>
<p><strong>1.</strong> <strong>创建普通索引</strong></p>
<p>在book表中的year_publication字段上建立普通索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE book( </span><br><span class="line">book_id INT , </span><br><span class="line">book_name VARCHAR(100), </span><br><span class="line">authors VARCHAR(100), </span><br><span class="line">info VARCHAR(100) , </span><br><span class="line">comment VARCHAR(100), </span><br><span class="line">year_publication YEAR, </span><br><span class="line">INDEX(year_publication) </span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>创建唯一索引</strong></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test1( </span><br><span class="line">id INT NOT NULL, </span><br><span class="line">name varchar(30) NOT NULL, </span><br><span class="line">UNIQUE INDEX uk_idx_id(id) </span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test1 \G</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>主键索引</strong></p>
<p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法：</p>
<ul>
<li>随表一起建索引：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student ( </span><br><span class="line">id INT(10) UNSIGNED AUTO_INCREMENT , </span><br><span class="line">student_no VARCHAR(200), </span><br><span class="line">student_name VARCHAR(200), </span><br><span class="line">PRIMARY KEY(id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除主键索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student </span><br><span class="line">drop PRIMARY KEY ;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引</li>
</ul>
<p><strong>4.</strong> <strong>创建单列索引</strong></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test2( </span><br><span class="line">id INT NOT NULL, </span><br><span class="line">name CHAR(50) NULL, </span><br><span class="line">INDEX single_idx_name(name(20)) </span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test2 \G</span><br></pre></td></tr></table></figure>

<p><strong>5.</strong> <strong>创建组合索引</strong></p>
<p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test3( </span><br><span class="line">id INT(11) NOT NULL, </span><br><span class="line">name CHAR(30) NOT NULL, </span><br><span class="line">age INT(11) NOT NULL, </span><br><span class="line">info VARCHAR(255), </span><br><span class="line">INDEX multi_idx(id,name,age) </span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW INDEX 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test3 \G</span><br></pre></td></tr></table></figure>

<p><strong>6.</strong> <strong>创建全文索引</strong></p>
<p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test4( </span><br><span class="line">id INT NOT NULL, </span><br><span class="line">name CHAR(30) NOT NULL, </span><br><span class="line">age INT NOT NULL, </span><br><span class="line">info VARCHAR(255), </span><br><span class="line">FULLTEXT INDEX futxt_idx_info(info) </span><br><span class="line">) ENGINE=MyISAM; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</p>
</blockquote>
<p>举例2： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE articles ( </span><br><span class="line">id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, </span><br><span class="line">title VARCHAR (200), </span><br><span class="line">body TEXT, </span><br><span class="line">FULLTEXT index (title, body) </span><br><span class="line">) ENGINE = INNODB ;</span><br></pre></td></tr></table></figure>

<p>创建了一个给title和body字段添加全文索引的表。</p>
<p>举例3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `papers` ( </span><br><span class="line">`id` int(10) unsigned NOT NULL AUTO_INCREMENT, </span><br><span class="line">`title` varchar(200) DEFAULT NULL, </span><br><span class="line">`content` text, </span><br><span class="line">PRIMARY KEY (`id`), </span><br><span class="line">FULLTEXT KEY `title` (`title`,`content`) </span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8; </span><br></pre></td></tr></table></figure>

<p>不同于like方式的的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;</span><br></pre></td></tr></table></figure>

<p>全文索引用match+against方式查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意点</p>
<ol>
<li><p>使用全文索引前，搞清楚版本支持情况；</p>
</li>
<li><p>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</p>
</li>
<li><p>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</p>
</li>
</ol>
</blockquote>
<p><strong>7.</strong> <strong>创建空间索引</strong></p>
<p>空间索引创建中，要求空间类型的字段必须为 非空 。</p>
<p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test5( </span><br><span class="line">geo GEOMETRY NOT NULL, </span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo) </span><br><span class="line">) ENGINE=MyISAM; </span><br></pre></td></tr></table></figure>

<h3 id="在已经存在的表上创建索引"><a href="#在已经存在的表上创建索引" class="headerlink" title="在已经存在的表上创建索引"></a><strong>在已经存在的表上创建索引</strong></h3><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。</p>
<p><strong>1.</strong> <strong>使用ALTER TABLE语句创建索引</strong> ALTER TABLE语句创建索引的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>使用CREATE INDEX创建索引</strong> CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>

<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a><strong>删除索引</strong></h2><p><strong>1.</strong> <strong>使用ALTER TABLE删除索引</strong> ALTER TABLE删除索引的基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>使用DROP INDEX语句删除索引</strong> DROP INDEX删除索引的基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p>
</blockquote>
<h1 id="MySQL8-0索引新特性"><a href="#MySQL8-0索引新特性" class="headerlink" title="MySQL8.0索引新特性"></a><strong>MySQL8.0索引新特性</strong></h1><h2 id="支持降序索引"><a href="#支持降序索引" class="headerlink" title="支持降序索引"></a><strong>支持降序索引</strong></h2><p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));</span><br></pre></td></tr></table></figure>

<p>在MySQL 5.7版本中查看数据表ts1的结构，结果如下：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/VW2I77ZC3MEC%600_ILWYOZ1F.png"></p>
<p>从结果可以看出，索引仍然是默认的升序。</p>
<p>在MySQL 8.0版本中查看数据表ts1的结构，结果如下：</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/1321sdfsdfsdf.png"></p>
<p>从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。</p>
<p>分别在MySQL5.7版本和MySQL8.0版本的数据表ts1中插入800条随机数据，执行语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER // </span><br><span class="line">CREATE PROCEDURE ts_insert() </span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1; </span><br><span class="line">WHILE i &lt; 800 </span><br><span class="line">DO </span><br><span class="line">insert into ts1 select rand()*80000,rand()*80000; </span><br><span class="line">SET i = i + 1; </span><br><span class="line">END WHILE; </span><br><span class="line">commit; </span><br><span class="line">END // </span><br><span class="line">DELIMITER ; </span><br><span class="line">#调用</span><br><span class="line">CALL ts_insert();</span><br></pre></td></tr></table></figure>

<p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。</p>
<blockquote>
<p>提示 Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。</p>
</blockquote>
<p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用Using filesort。</p>
<blockquote>
<p>注意 降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。</p>
</blockquote>
<p>将排序条件修改为order by a desc, b desc后，下面来对比不同版本中执行计划的效果。 在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM ts1 ORDER BY a DESC,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure>

<p>在MySQL 8.0版本中查看数据表ts1的执行计划。</p>
<p>从结果可以看出，修改后MySQL 5.7的执行计划要明显好于MySQL 8.0</p>
<h2 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a><strong>隐藏索引</strong></h2><p>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>
<p>从MySQL 8.x开始支持 隐藏索引（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除 。 </p>
<p><strong>1.</strong> <strong>创建表时直接创建</strong> 在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tablename( </span><br><span class="line">propname1 type1[CONSTRAINT1], </span><br><span class="line">propname2 type2[CONSTRAINT2], </span><br><span class="line">……</span><br><span class="line">propnamen typen, </span><br><span class="line">INDEX [indexname](propname1 [(length)]) INVISIBLE </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。</p>
<p><strong>2.</strong> <strong>在已经存在的表上创建</strong></p>
<p>可以为已经存在的表设置隐藏索引，其语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexname </span><br><span class="line">ON tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>通过ALTER TABLE语句创建</strong></p>
<p>语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename </span><br><span class="line">ADD INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<p><strong>4.</strong> <strong>切换索引可见状态</strong> 已存在的索引可通过如下语句切换可见状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 </span><br><span class="line">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure>

<p>如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。</p>
<blockquote>
<p>注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>
</blockquote>
<p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p>
<p><strong>5.</strong> <strong>使隐藏索引对查询优化器可见</strong></p>
<p>在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关（use_invisible_indexes）来打开某个设置，使隐藏索引对查询优化器可见。如果 use_invisible_indexes设置为off(默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。</p>
<p>（1）在MySQL命令行执行如下命令查看查询优化器的开关设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G</span><br></pre></td></tr></table></figure>

<p>在输出的结果信息中找到如下属性配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes=off</span><br></pre></td></tr></table></figure>

<p>此属性配置值为off，说明隐藏索引默认对查询优化器不可见。</p>
<p>（2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=on&quot;; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>SQL语句执行成功，再次查看查询优化器的开关设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch \G </span><br><span class="line">*************************** 1. row *************************** </span><br><span class="line">@@optimizer_switch: </span><br><span class="line">index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_ </span><br><span class="line">intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_co </span><br><span class="line">st_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on </span><br><span class="line">,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on </span><br><span class="line">,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_ind </span><br><span class="line">exes=on,skip_scan=on,hash_join=on </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>此时，在输出结果中可以看到如下属性配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes=on</span><br></pre></td></tr></table></figure>

<p>use_invisible_indexes属性的值为on，说明此时隐藏索引对查询优化器可见。</p>
<p>（3）使用EXPLAIN查看以字段invisible_column作为查询条件时的索引使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from classes where cname = &#x27;高一2班&#x27;;</span><br></pre></td></tr></table></figure>

<p>查询优化器会使用隐藏索引来查询数据。</p>
<p>（4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=off&quot;; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>再次查看查询优化器的开关设置。</p>
<p>mysql&gt; select @@optimizer_switch \G </p>
<p>此时，use_invisible_indexes属性的值已经被设置为“off”。 </p>
<h1 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a><strong>索引的设计原则</strong></h1><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a><strong>数据准备</strong></h2><p><strong>第1步：创建数据库、创建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE atguigudb1; </span><br><span class="line">USE atguigudb1; </span><br><span class="line">#1.创建学生表和课程表 </span><br><span class="line">CREATE TABLE `student_info` ( </span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT, </span><br><span class="line">`student_id` INT NOT NULL , </span><br><span class="line">`name` VARCHAR(20) DEFAULT NULL, </span><br><span class="line">`course_id` INT NOT NULL , </span><br><span class="line">`class_id` INT(11) DEFAULT NULL, </span><br><span class="line">`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, </span><br><span class="line">PRIMARY KEY (`id`) </span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; </span><br><span class="line">CREATE TABLE `course` ( </span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT, </span><br><span class="line">`course_id` INT NOT NULL , </span><br><span class="line">`course_name` VARCHAR(40) DEFAULT NULL, </span><br><span class="line">PRIMARY KEY (`id`) </span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; </span><br></pre></td></tr></table></figure>

<p><strong>第2步：创建模拟数据必需的存储函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#函数1：创建随机产生字符串函数 </span><br><span class="line">DELIMITER // </span><br><span class="line">CREATE FUNCTION rand_string(n INT) </span><br><span class="line">RETURNS VARCHAR(255) #该函数会返回一个字符串 </span><br><span class="line">BEGIN</span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT </span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;; </span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">#函数1：创建随机产生字符串函数 </span><br><span class="line">DELIMITER // </span><br><span class="line">CREATE FUNCTION rand_string(n INT) </span><br><span class="line">RETURNS VARCHAR(255) #该函数会返回一个字符串 </span><br><span class="line">BEGIN</span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT </span><br><span class="line">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;; </span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#函数2：创建随机数函数 </span><br><span class="line">DELIMITER // </span><br><span class="line">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11) </span><br><span class="line">BEGIN </span><br><span class="line">DECLARE i INT DEFAULT 0; </span><br><span class="line">SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ; </span><br><span class="line">RETURN i; </span><br><span class="line">END // </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>创建函数，假如报错：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function has <span class="literal">none</span> of DETERMINISTIC<span class="params">...</span><span class="params">...</span></span><br></pre></td></tr></table></figure>

<p>由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。</p>
<p>主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。</p>
<ul>
<li>查看mysql是否允许创建函数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;log_bin_trust_function_creators&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>命令开启：允许创建函数设置：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>mysqld重启，上述参数又会消失。永久方法：</p>
<ul>
<li><p>windows下：my.ini[mysqld]加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure></li>
<li><p>linux下：/etc/my.cnf下my.cnf[mysqld]加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    log_bin_trust_function_creators=1</span><br><span class="line"></span><br><span class="line">​		</span><br><span class="line"></span><br><span class="line">第3步：创建插入模拟数据的存储过程</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line"># 存储过程1：创建插入课程表存储过程 </span><br><span class="line">DELIMITER // </span><br><span class="line">CREATE PROCEDURE insert_course( max_num INT ) </span><br><span class="line">BEGIN </span><br><span class="line">DECLARE i INT DEFAULT 0; </span><br><span class="line">SET autocommit = 0; #设置手动提交事务 </span><br><span class="line">REPEAT #循环 </span><br><span class="line">SET i = i + 1; #赋值 </span><br><span class="line">INSERT INTO course (course_id, course_name ) VALUES </span><br><span class="line">(rand_num(10000,10100),rand_string(6)); </span><br><span class="line">UNTIL i = max_num</span><br><span class="line">END REPEAT; </span><br><span class="line">COMMIT; #提交事务 </span><br><span class="line">END // </span><br><span class="line">DELIMITER ; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程2：创建插入学生信息表存储过程 </span><br><span class="line">DELIMITER // </span><br><span class="line">CREATE PROCEDURE insert_stu( max_num INT ) </span><br><span class="line">BEGIN </span><br><span class="line">DECLARE i INT DEFAULT 0; </span><br><span class="line">SET autocommit = 0; #设置手动提交事务 </span><br><span class="line">REPEAT #循环 </span><br><span class="line">SET i = i + 1; #赋值 </span><br><span class="line">INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES </span><br><span class="line">(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6)); </span><br><span class="line">UNTIL i = max_num </span><br><span class="line">END REPEAT; </span><br><span class="line">COMMIT; #提交事务 </span><br><span class="line">END // </span><br><span class="line">DELIMITER ; </span><br></pre></td></tr></table></figure>

<p>第4步：调用存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_course(100); </span><br><span class="line"></span><br><span class="line">CALL insert_stu(1000000);</span><br></pre></td></tr></table></figure>



<h2 id="哪些情况适合创建索引"><a href="#哪些情况适合创建索引" class="headerlink" title="哪些情况适合创建索引"></a>哪些情况适合创建索引</h2><h3 id="1-字段的数值有唯一性的限制"><a href="#1-字段的数值有唯一性的限制" class="headerlink" title="1. 字段的数值有唯一性的限制"></a><strong>1.</strong> <strong>字段的数值有唯一性的限制</strong></h3><blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
</blockquote>
<h3 id="2-频繁作为-WHERE-查询条件的字段"><a href="#2-频繁作为-WHERE-查询条件的字段" class="headerlink" title="2. 频繁作为 WHERE 查询条件的字段"></a><strong>2.</strong> <strong>频繁作为</strong> <strong>WHERE</strong> <strong>查询条件的字段</strong></h3><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<p>比如student_info数据表（含100万条数据），假设我们想要查询 student_id=123110 的用户信息。</p>
<h3 id="3-经常-GROUP-BY-和-ORDER-BY-的列"><a href="#3-经常-GROUP-BY-和-ORDER-BY-的列" class="headerlink" title="3. 经常 GROUP BY 和 ORDER BY 的列"></a><strong>3. 经常</strong> <strong>GROUP BY</strong> <strong>和</strong> <strong>ORDER BY</strong> 的列</h3><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。</p>
<h3 id="4-UPDATE、DELETE-的WHERE-条件列"><a href="#4-UPDATE、DELETE-的WHERE-条件列" class="headerlink" title="4. UPDATE、DELETE 的WHERE 条件列"></a><strong>4. UPDATE、DELETE 的WHERE</strong> <strong>条件列</strong></h3><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p>
<h3 id="5-DISTINCT-字段需要创建索引"><a href="#5-DISTINCT-字段需要创建索引" class="headerlink" title="5.DISTINCT 字段需要创建索引"></a><strong>5.DISTINCT</strong> 字段需要创建索引</h3><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>
<p>比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure>

<p>运行结果（600637 条记录，运行时间 0.683s ）：</p>
<p>如果我们对 student_id 创建索引，再执行 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure>

<p>运行结果（600637 条记录，运行时间 0.010s ）：</p>
<p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p>
<h3 id="6-多表-JOIN-连接操作时，创建索引注意事项"><a href="#6-多表-JOIN-连接操作时，创建索引注意事项" class="headerlink" title="6. 多表 JOIN 连接操作时，创建索引注意事项"></a><strong>6.</strong> <strong>多表 JOIN 连接操作时，创建索引注意事项</strong></h3><p>首先， 连接表的数量尽量不要超过 3 张 ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p>
<p>其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p>
<p>最后， 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p>
<p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT course_id, name, student_info.student_id, course_name </span><br><span class="line">FROM student_info JOIN course </span><br><span class="line">ON student_info.course_id = course.course_id </span><br><span class="line">WHERE name = &#x27;462eed7ac6e791292a79&#x27;; </span><br></pre></td></tr></table></figure>

<p>运行结果（1 条数据，运行时间 0.189s ）：</p>
<p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。 </p>
<h3 id="7-使用列的类型小的创建索引"><a href="#7-使用列的类型小的创建索引" class="headerlink" title="7. 使用列的类型小的创建索引"></a><strong>7.</strong> <strong>使用列的类型小的创建索引</strong></h3><h3 id="8-使用字符串前缀创建索引"><a href="#8-使用字符串前缀创建索引" class="headerlink" title="8. 使用字符串前缀创建索引"></a><strong>8.</strong> <strong>使用字符串前缀创建索引</strong></h3><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table shop(address varchar(120) not null); </span><br><span class="line"></span><br><span class="line">alter table shop add index(address(12));</span><br></pre></td></tr></table></figure>

<p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。<strong>怎么计算不同的长度的选择性呢？</strong></p>
<p>先看一下字段在全部数据中的选择度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct address) / count(*) from shop;</span><br></pre></td></tr></table></figure>

<p>通过不同长度去计算，与全表的选择性对比：</p>
<p>公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度 </span><br><span class="line">count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度 </span><br><span class="line">count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度 </span><br><span class="line">count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度 </span><br><span class="line">from shop; </span><br></pre></td></tr></table></figure>

<p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p>
<p><strong>拓展：Alibaba《Java开发手册》</strong></p>
<p>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p>
<h3 id="9-区分度高-散列性高-的列适合作为索引"><a href="#9-区分度高-散列性高-的列适合作为索引" class="headerlink" title="9. 区分度高(散列性高)的列适合作为索引"></a><strong>9.</strong> <strong>区分度高(散列性高)的列适合作为索引</strong></h3><h3 id="10-使用最频繁的列放到联合索引的左侧"><a href="#10-使用最频繁的列放到联合索引的左侧" class="headerlink" title="10. 使用最频繁的列放到联合索引的左侧"></a><strong>10. 使用最频繁的列放到联合索引的左侧</strong></h3><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率</p>
<h3 id="11-在多个字段都要创建索引的情况下，联合索引优于单值索引"><a href="#11-在多个字段都要创建索引的情况下，联合索引优于单值索引" class="headerlink" title="11. 在多个字段都要创建索引的情况下，联合索引优于单值索引"></a><strong>11.</strong> <strong>在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></h3><h2 id="限制索引的数目"><a href="#限制索引的数目" class="headerlink" title="限制索引的数目"></a><strong>限制索引的数目</strong></h2><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过6个。原因:</p>
<p>①每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。</p>
<p>②索引会影响INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</p>
<p>③优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</p>
<h2 id="哪些情况不适合创建索引"><a href="#哪些情况不适合创建索引" class="headerlink" title="哪些情况不适合创建索引"></a><strong>哪些情况不适合创建索引</strong></h2><h3 id="1-在where中使用不到的字段，不要设置索引"><a href="#1-在where中使用不到的字段，不要设置索引" class="headerlink" title="1. 在where中使用不到的字段，不要设置索引"></a><strong>1.</strong> <strong>在where中使用不到的字段，不要设置索引</strong></h3><h3 id="2-数据量小的表最好不要使用索引"><a href="#2-数据量小的表最好不要使用索引" class="headerlink" title="2. 数据量小的表最好不要使用索引"></a><strong>2.</strong> <strong>数据量小的表最好不要使用索引</strong></h3><p>结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。</p>
<h3 id="3-有大量重复数据的列上不要建立索引"><a href="#3-有大量重复数据的列上不要建立索引" class="headerlink" title="3. 有大量重复数据的列上不要建立索引"></a><strong>3.</strong> <strong>有大量重复数据的列上不要建立索引</strong></h3><p>举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p>
<p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。</p>
<p>学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student_gender( </span><br><span class="line">student_id INT(11) NOT NULL, </span><br><span class="line">student_name VARCHAR(50) NOT NULL, </span><br><span class="line">student_gender TINYINT(1) NOT NULL, </span><br><span class="line">PRIMARY KEY(student_id) </span><br><span class="line">)ENGINE = INNODB; </span><br></pre></td></tr></table></figure>

<p>如果我们要筛选出这个学生表中的男性，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student_gender WHERE student_gender = 1</span><br></pre></td></tr></table></figure>

<p>运行结果（10 条数据，运行时间 0.696s ）：</p>
<blockquote>
<p>结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引</p>
</blockquote>
<h3 id="4-避免对经常更新的表创建过多的索引"><a href="#4-避免对经常更新的表创建过多的索引" class="headerlink" title="4. 避免对经常更新的表创建过多的索引"></a><strong>4.</strong> <strong>避免对经常更新的表创建过多的索引</strong></h3><h3 id="5-不建议用无序的值作为索引"><a href="#5-不建议用无序的值作为索引" class="headerlink" title="5. 不建议用无序的值作为索引"></a><strong>5.</strong> <strong>不建议用无序的值作为索引</strong></h3><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>
<h3 id="6-删除不再使用或者很少使用的索引"><a href="#6-删除不再使用或者很少使用的索引" class="headerlink" title="6. 删除不再使用或者很少使用的索引"></a><strong>6.</strong> <strong>删除不再使用或者很少使用的索引</strong></h3><h3 id="7-不要定义冗余或重复的索引"><a href="#7-不要定义冗余或重复的索引" class="headerlink" title="7. 不要定义冗余或重复的索引"></a><strong>7.</strong> <strong>不要定义冗余或重复的索引</strong></h3><p><strong>① 冗余索引</strong></p>
<p>举例：建表语句如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_info( </span><br><span class="line">id INT UNSIGNED NOT NULL AUTO_INCREMENT, </span><br><span class="line">name VARCHAR(100) NOT NULL, </span><br><span class="line">birthday DATE NOT NULL, </span><br><span class="line">phone_number CHAR(11) NOT NULL, </span><br><span class="line">country varchar(100) NOT NULL, </span><br><span class="line">PRIMARY KEY (id), </span><br><span class="line">KEY idx_name_birthday_phone_number (name(10), birthday, phone_number), </span><br><span class="line">KEY idx_name (name(10)) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一个专门针对 name 列的索引就算是一个 冗余索引 ，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p>
<p><strong>② 重复索引</strong></p>
<p>另一种情况，我们可能会对某个列 重复建立索引 ，比方说这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE repeat_index_demo ( </span><br><span class="line">col1 INT PRIMARY KEY, </span><br><span class="line">col2 INT, </span><br><span class="line">UNIQUE uk_idx_c1 (col1), </span><br><span class="line">INDEX idx_c1 (col1) </span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/MySQL/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="prev" title="索引的数据结构">
                  <i class="fa fa-chevron-left"></i> 索引的数据结构
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/MySQL/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" rel="next" title="索引优化与查询优化">
                  索引优化与查询优化 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
