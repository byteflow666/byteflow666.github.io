<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite-url","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="It&#39;s an IT blog...">
<meta property="og:type" content="website">
<meta property="og:title" content="Study Node">
<meta property="og:url" content="http://yoursite-url/archives/2/index.html">
<meta property="og:site_name" content="Study Node">
<meta property="og:description" content="It&#39;s an IT blog...">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite-url/archives/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"archives/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Study Node</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Study Node</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">True mastery of any skill takes a lifetime</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hao"
      src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
  <p class="site-author-name" itemprop="name">Hao</p>
  <div class="site-description" itemprop="description">It's an IT blog...</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/byteflow666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;byteflow666" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://mail.qq.com/cgi-bin/frame_html?sid=1aPXzaqY4yWqbjhZ&r=98902ddef6ed390980f08fe54374e19b" title="E-Mail → https:&#x2F;&#x2F;mail.qq.com&#x2F;cgi-bin&#x2F;frame_html?sid&#x3D;1aPXzaqY4yWqbjhZ&amp;r&#x3D;98902ddef6ed390980f08fe54374e19b" rel="noopener" target="_blank">E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="思考">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/%E6%80%9D%E8%80%83/%E5%AF%92%E5%81%87%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%80%9D%E8%80%83/%E5%AF%92%E5%81%87%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">寒假规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-17 21:44:17" itemprop="dateCreated datePublished" datetime="2022-01-17T21:44:17+08:00">2022-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%A7%84%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">规划</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="寒假规划"><a href="#寒假规划" class="headerlink" title="寒假规划"></a>寒假规划</h1><p>目前欠缺项目经验,前几天面试感觉有些东西记得不够清楚,这段时间复习一下,在学习心得知识,学习MySQL高级,Redis,SpringCloud,以及设计模式,在自己独立做一个项目。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="MySQL">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/MySQL/mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/MySQL/mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/" class="post-title-link" itemprop="url">MySQL的数据目录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-17 21:09:48" itemprop="dateCreated datePublished" datetime="2022-01-17T21:09:48+08:00">2022-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E9%AB%98%E7%BA%A7/" itemprop="url" rel="index"><span itemprop="name">MySQL高级</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL%E9%AB%98%E7%BA%A7/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p> 这份笔记是康师傅的笔记 不得不说康师傅讲的是真好 自己整理这份笔记只是为了更好的复习，MySQL篇都是所以后面就不一一标注了<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=52&amp;spm_id_from=pageDriver%E8%A7%86%E9%A2%91%E5%9C%A8%E8%BF%99">https://www.bilibili.com/video/BV1iq4y1u7vj?p=52&amp;spm_id_from=pageDriver视频在这</a></p>
</blockquote>
<h1 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h1><h2 id="MySQL8的主要目录结构"><a href="#MySQL8的主要目录结构" class="headerlink" title="MySQL8的主要目录结构"></a>MySQL8的主要目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@atguigu01 ~]# find / -name mysql</span><br></pre></td></tr></table></figure>

<p>安装好MySQL 8之后，我们查看如下的目录结构：</p>
<h3 id="数据库文件的存放路劲"><a href="#数据库文件的存放路劲" class="headerlink" title="数据库文件的存放路劲"></a>数据库文件的存放路劲</h3><p>MySQL数据库文件的存放路径：/var/lib/mysql/</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;datadir&#x27;; +---------------+-----------------+</span><br><span class="line">| Variable_name | Value | +---------------+-----------------+</span><br><span class="line">| datadir | /var/lib/mysql/ | +---------------+-----------------+</span><br><span class="line">1 row in set (0.04 sec)</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，在我的计算机上MySQL的数据目录就是 /var/lib/mysql/ 。 </p>
<h3 id="相关命令目录"><a href="#相关命令目录" class="headerlink" title="相关命令目录"></a>相关命令目录</h3><p>相关命令目录：/usr/bin（mysqladmin、mysqlbinlog、mysqldump等命令）和/usr/sbin。</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/awdasda32.png"></p>
<h3 id="配置文件目录"><a href="#配置文件目录" class="headerlink" title="配置文件目录"></a>配置文件目录</h3><p><strong>配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）</strong> </p>
<h2 id="数据库和文件系统的关系"><a href="#数据库和文件系统的关系" class="headerlink" title="数据库和文件系统的关系"></a>数据库和文件系统的关系</h2><h3 id="查看默认数据库"><a href="#查看默认数据库" class="headerlink" title="查看默认数据库"></a>查看默认数据库</h3><p>查看一下在我的计算机上当前有哪些数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br></pre></td></tr></table></figure>

<p>可以看到有4个数据库是属于MySQL自带的系统数据库。</p>
<ul>
<li><p>mysql</p>
<p>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p>
</li>
<li><p>information_schema</p>
</li>
</ul>
<p>​    MySQL 系统自带的数据库，这个数据库保存着MySQL服务器 维护的所有其他数据库的信息 ，比如有哪些表、哪些视图、哪些触发          器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为 元数据 。在系统数据库          information_schema 中提供了一些以innodb_sys 开头的表，用于表示内部系统表。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE information_schema; Database changed mysql&gt; SHOW TABLES LIKE &#x27;innodb_sys%&#x27;; +--------------------------------------------+</span><br><span class="line">|<span class="string"> Tables_in_information_schema (innodb_sys%) </span>|</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">|<span class="string"> INNODB_SYS_DATAFILES </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_VIRTUAL </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_INDEXES </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_TABLES </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_FIELDS </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_TABLESPACES </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_FOREIGN_COLS </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_COLUMNS </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_FOREIGN </span>|<span class="string"> </span>|<span class="string"> INNODB_SYS_TABLESTATS </span>|<span class="string"> +--------------------------------------------+</span></span><br><span class="line"><span class="string">10 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>performance_schema </p>
<p>MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等信息。</p>
</li>
<li><p>sys </p>
<p>MySQL 系统自带的数据库，这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p>
</li>
</ul>
<h3 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h3><h4 id="InnoDB存储引擎模式"><a href="#InnoDB存储引擎模式" class="headerlink" title="InnoDB存储引擎模式"></a><strong>InnoDB</strong>存储引擎模式</h4><p><strong>1.</strong> <strong>表结构</strong></p>
<p>为了保存表结构， InnoDB 在 数据目录 下对应的数据库子目录下创建了一个专门用于 描述表结构的文件 ，文件名是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure>

<p>比方说我们在 atguigu 数据库下创建一个名为 test 的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE atguigu; </span><br><span class="line">Database changed </span><br><span class="line">mysql&gt; CREATE TABLE test (</span><br><span class="line">	-&gt; c1 INT</span><br><span class="line">	-&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>那在数据库 atguigu 对应的子目录下就会创建一个名为 test.frm 的用于描述表结构的文件。.frm文件的格式在不同的平台上都是相同的。这个后缀名为.frm是以 二进制格式 存储的，我们直接打开是乱码的</p>
<p><strong>2.</strong> <strong>表中数据和索引</strong></p>
<p><strong>① 系统表空间</strong>（system tablespace）</p>
<p>默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应的 系统表空间 在文件系统上的表示。怎么才12M？注意这个文件是 自扩展文件 ，当不够用的时候它会自己增加文件大小。</p>
<p>当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的 ibdata1 这个文件名难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[server] innodb_data_file_path=data1:512M;data2:512M:autoextend</span><br></pre></td></tr></table></figure>

<p><strong>② 独立表空间</strong>(file-per-table tablespace)</p>
<p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为 每 一个表建立一个独立表空间 ，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个 .ibd 的扩展名而已，所以完整的文件名称长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.ibd</span><br></pre></td></tr></table></figure>

<p>比如：我们使用了 独立表空间 去存储 atguigu 数据库下的 test 表的话，那么在该表所在数据库对应的 atguigu 目录下会为 test 表创建这两个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.frm </span><br><span class="line">test.ibd</span><br></pre></td></tr></table></figure>

<p>其中 test.ibd 文件就用来存储 test 表中的数据和索引。</p>
<p><strong>③ 系统表空间与独立表空间的设置</strong></p>
<p>我们可以自己指定使用 系统表空间 还是 独立表空间 来存储数据，这个功能由启动参数innodb_file_per_table 控制，比如说我们想刻意将表数据都存储到 系统表空间 时，可以在启动MySQL服务器的时候这样配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[server] innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间</span><br></pre></td></tr></table></figure>

<p>默认情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_file_per_table&#x27;; +-----------------------+-------+</span><br><span class="line">| Variable_name | Value | +-----------------------+-------+</span><br><span class="line">| innodb_file_per_table | ON | +-----------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>④ 其他类型的表空间</strong></p>
<p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p>
<h4 id="MyISAM存储引擎模式"><a href="#MyISAM存储引擎模式" class="headerlink" title="MyISAM存储引擎模式"></a><strong>MyISAM</strong>存储引擎模式</h4><p><strong>1.</strong> <strong>表结构</strong></p>
<p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在 数据目录 下对应的数据库子目录下创建了一个专门用于描述表结构的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名.frm</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong> <strong>表中数据和索引</strong></p>
<p>在MyISAM中的索引全部都是 二级索引 ，该存储引擎的 数据和索引是分开存放 的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。假如 test表使用MyISAM存储引擎的话，那么在它所在数据库对应的 atguigu 目录下会为 test 表创建这三个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.frm 存储表结构 </span><br><span class="line">test.MYD 存储数据 (MYData)</span><br><span class="line">test.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure>

<p>举例：创建一个 MyISAM 表，使用 ENGINE 选项显式指定引擎。因为 InnoDB 是默认引擎。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student_myisam` (</span><br><span class="line">`id` bigint NOT NULL AUTO_INCREMENT, </span><br><span class="line">`name` varchar(64) DEFAULT NULL, </span><br><span class="line">`age` int DEFAULT NULL, </span><br><span class="line">`sex` varchar(2) DEFAULT NULL, </span><br><span class="line">PRIMARY KEY (`id`) </span><br><span class="line">)ENGINE=MYISAM AUTO_INCREMENT=0 DEFAULTCHARSET=utf8mb3;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><p>举例： 数据库a ， 表b 。 </p>
<p>1、如果表b采用 InnoDB ，data\a中会产生1个或者2个文件：</p>
<ul>
<li><p>b.frm ：描述表结构文件，字段长度等</p>
</li>
<li><p>如果采用 系统表空间 模式的，数据信息和索引信息都存储在 ibdata1 中</p>
</li>
<li><p>如果采用 独立表空间 存储模式，data\a中还会产生 b.ibd 文件（存储数据信息和索引信息）</p>
<p>此外：</p>
</li>
</ul>
<p>① MySQL5.7 中会在data/a的目录下生成 db.opt 文件用于保存数据库的相关配置。比如：字符集、比较规则。而MySQL8.0不再提供db.opt文件。</p>
<p>② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。</p>
<p>2、如果表b采用 MyISAM ，data\a中会产生3个文件：</p>
<ul>
<li><p>MySQL5.7 中： b.frm ：描述表结构文件，字段长度等。</p>
<p>MySQL8.0 中 b.xxx.sdi ：描述表结构文件，字段长度等</p>
</li>
<li><p>b.MYD (MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式) </p>
</li>
<li><p>b.MYI (MYIndex)：存放索引信息文件</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%8D%81%E7%AB%A0-ThreadPool-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%8D%81%E7%AB%A0-ThreadPool-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">JUC系列-ThreadPool 线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-19 10:02:03" itemprop="dateCreated datePublished" datetime="2021-11-19T10:02:03+08:00">2021-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ThreadPool-线程池"><a href="#ThreadPool-线程池" class="headerlink" title="ThreadPool 线程池"></a><strong>ThreadPool 线程池</strong></h1><h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a><strong>线程池简介</strong></h2><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p>
<p>例子： 10 年前单核 CPU 电脑，假的多线程，像马戏团小丑玩多个球，CPU 需要来回切换。 现在是多核电脑，多个线程各自跑在独立的 CPU 上，不用切换效率高</p>
<p><strong>线程池的优势：</strong> 线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p><strong>它的主要特点为：</strong></p>
<ul>
<li><p>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</p>
</li>
<li><p>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
<li><p><strong>Java</strong> <strong>中的线程池是通过</strong> <strong>Executor</strong> <strong>框架实现的，该框架中用到了Executor，Executors，ExecutorService</strong>，<strong>ThreadPoolExecutor</strong> <strong>这几个类</strong></p>
</li>
</ul>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/NX1E6OPFO~GALUZ2.png"></p>
<h2 id="线程池参数说明"><a href="#线程池参数说明" class="headerlink" title="线程池参数说明"></a><strong>线程池参数说明</strong></h2><p>本次介绍 5 种类型的线程池</p>
<h3 id="常用参数-重点"><a href="#常用参数-重点" class="headerlink" title="常用参数(重点)"></a><strong>常用参数(重点)</strong></h3><ul>
<li><p>corePoolSize 线程池的核心线程数</p>
</li>
<li><p>maximumPoolSize 能容纳的最大线程数</p>
</li>
<li><p>keepAliveTime 空闲线程存活时间</p>
</li>
<li><p>unit 存活的时间单位</p>
</li>
<li><p>workQueue 存放提交但未执行任务的队列</p>
</li>
<li><p>threadFactory 创建线程的工厂类</p>
</li>
<li><p>handler 等待队列满后的拒绝策略</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/09-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%83%E4%B8%AA%E5%8F%82%E6%95%B0.png"></p>
</li>
</ul>
<p>线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize -最大线程数</p>
<p>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p>
<p>总结起来，也就是一句话，<strong>当提交的任务数大于（workQueue.size() +</strong> <strong>maximumPoolSize ），就会触发线程池的拒绝策略</strong>。</p>
<h3 id="拒绝策略-重点"><a href="#拒绝策略-重点" class="headerlink" title="拒绝策略(重点)"></a><strong>拒绝策略(重点)</strong></h3><p><strong>CallerRunsPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</p>
<p><strong>AbortPolicy</strong>: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</p>
<p><strong>DiscardPolicy</strong>: 直接丢弃，其他啥都没有</p>
<p><strong>DiscardOldestPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</p>
<h2 id="线程池的种类与创建"><a href="#线程池的种类与创建" class="headerlink" title="线程池的种类与创建"></a><strong>线程池的种类与创建</strong></h2><h3 id="newCachedThreadPool-常用"><a href="#newCachedThreadPool-常用" class="headerlink" title="newCachedThreadPool(常用)"></a><strong>newCachedThreadPool(常用)</strong></h3><p><strong>作用</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</p>
<p><strong>特点</strong>: </p>
<ul>
<li><p>线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE） </p>
</li>
<li><p>线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</p>
</li>
<li><p>当线程池中，没有可用线程，会重新创建一个线程</p>
</li>
</ul>
<p><strong>创建方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可缓存线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * corePoolSize 线程池的核心线程数</span></span><br><span class="line"><span class="comment"> * maximumPoolSize 能容纳的最大线程数</span></span><br><span class="line"><span class="comment"> * keepAliveTime 空闲线程存活时间</span></span><br><span class="line"><span class="comment"> * unit 存活的时间单位</span></span><br><span class="line"><span class="comment"> * workQueue 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="comment"> * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class="line"><span class="comment"> * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,</span><br><span class="line">            Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景:</strong> 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景</p>
<h3 id="newFixedThreadPool-常用"><a href="#newFixedThreadPool-常用" class="headerlink" title="newFixedThreadPool(常用)"></a><strong>newFixedThreadPool(常用)</strong></h3><p><strong>作用</strong>：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>
<p><strong>特征：</strong></p>
<ul>
<li><p>线程池中的线程处于一定的量，可以很好的控制线程的并发量</p>
</li>
<li><p>线程可以重复被使用，在显示关闭之前，都将一直存在</p>
</li>
<li><p>超出一定量的线程被提交时候需在队列中等待</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定长度线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * corePoolSize 线程池的核心线程数</span></span><br><span class="line"><span class="comment"> * maximumPoolSize 能容纳的最大线程数</span></span><br><span class="line"><span class="comment"> * keepAliveTime 空闲线程存活时间</span></span><br><span class="line"><span class="comment"> * unit 存活的时间单位</span></span><br><span class="line"><span class="comment"> * workQueue 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="comment"> * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class="line"><span class="comment"> * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">0L</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景:</strong> 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景</p>
<h3 id="newSingleThreadExecutor-常用"><a href="#newSingleThreadExecutor-常用" class="headerlink" title="newSingleThreadExecutor(常用)"></a><strong>newSingleThreadExecutor(常用)</strong></h3><p><strong>作用</strong>：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p>
<p><strong>特征：</strong> 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行</p>
<p><strong>创建方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单一线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * corePoolSize 线程池的核心线程数</span></span><br><span class="line"><span class="comment"> * maximumPoolSize 能容纳的最大线程数</span></span><br><span class="line"><span class="comment"> * keepAliveTime 空闲线程存活时间</span></span><br><span class="line"><span class="comment"> * unit 存活的时间单位</span></span><br><span class="line"><span class="comment"> * workQueue 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="comment"> * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class="line"><span class="comment"> * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">0L</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景:</strong> 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景</p>
<h3 id="newScheduleThreadPool-了解"><a href="#newScheduleThreadPool-了解" class="headerlink" title="newScheduleThreadPool(了解)"></a><strong>newScheduleThreadPool(了解)</strong></h3><p><strong>作用:</strong> 线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池</p>
<p><strong>特征:</strong> </p>
<p>（1）线程池中具有指定数量的线程，即便是空线程也将保留 </p>
<p>（2）可定时或者延迟执行线程活动</p>
<p><strong>创建方式:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span></span></span></span><br><span class="line"><span class="params"><span class="function">corePoolSize, </span></span></span><br><span class="line"><span class="params"><span class="function">ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, </span><br><span class="line">threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景:</strong> 适用于需要多个后台线程执行周期任务的场景</p>
<h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a><strong>newWorkStealingPool</strong></h3><p>jdk1.8 提供的线程池，底层使用的是 ForkJoinPool 实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务</p>
<p><strong>创建方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * parallelism：并行级别，通常默认为 JVM 可用的处理器个数</span></span><br><span class="line"><span class="comment"> * factory：用于创建 ForkJoinPool 中使用的线程。</span></span><br><span class="line"><span class="comment"> * handler：用于处理工作线程未处理的异常，默认为 null</span></span><br><span class="line"><span class="comment"> * asyncMode：用于控制 WorkQueue 的工作模式:队列---反队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism,</span><br><span class="line">            ForkJoinPool.defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景:</strong> 适用于大耗时，可并行执行的场景</p>
<h2 id="线程池入门案例"><a href="#线程池入门案例" class="headerlink" title="线程池入门案例"></a><strong>线程池入门案例</strong></h2><p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义线程池的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//执行</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池底层工作原理-重要"><a href="#线程池底层工作原理-重要" class="headerlink" title="线程池底层工作原理(重要)"></a><strong>线程池底层工作原理(重要)</strong></h2><ol>
<li><p>在创建了线程池后，线程池中的线程数为零</p>
</li>
<li><p>当调用 execute()方法添加一个请求任务时，线程池会做出如下判断： </p>
<p>  2.1 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p>
</li>
</ol>
<p>​         2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p>
<p>​         2.3 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p>
<p>​         2.4 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</p>
<ol start="3">
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p>
</li>
<li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p>
</li>
</ol>
<p>​        4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。 </p>
<p>​        4.2 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/MVHC8Z%60_WAQLC_HX.png"></p>
<h2 id="注意事项-重要"><a href="#注意事项-重要" class="headerlink" title="注意事项(重要)"></a><strong>注意事项(重要)</strong></h2><ol>
<li><p>项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参数，自定义线程池</p>
</li>
<li><p>创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建</p>
</li>
</ol>
<p>o corePoolSize 线程池的核心线程数</p>
<p>o maximumPoolSize 能容纳的最大线程数</p>
<p>o keepAliveTime 空闲线程存活时间</p>
<p>o unit 存活的时间单位</p>
<p>o workQueue 存放提交但未执行任务的队列</p>
<p>o threadFactory 创建线程的工厂类</p>
<p>o handler 等待队列满后的拒绝策略</p>
<ol start="3">
<li>为什么不允许适用不允许 Executors.的方式手动创建线程池,如下图</li>
</ol>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/~ZC%7DKX7O11V40S2TZGE.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="思考">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/%E6%80%9D%E8%80%83/%E5%9B%A2%E9%98%9F%E7%B2%BE%E7%A5%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%80%9D%E8%80%83/%E5%9B%A2%E9%98%9F%E7%B2%BE%E7%A5%9E/" class="post-title-link" itemprop="url">团队精神</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-17 13:50:25" itemprop="dateCreated datePublished" datetime="2021-11-17T13:50:25+08:00">2021-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%A2%E9%98%9F/" itemprop="url" rel="index"><span itemprop="name">团队</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="团队精神"><a href="#团队精神" class="headerlink" title="团队精神"></a>团队精神</h1><p>为什么要谈这个话题 因为最近读了一本叫做浪潮之巅的书籍 有所思考 首先团队精神是什么呢？</p>
<p>百度百科中是这样解释的</p>
<blockquote>
<p>团队精神是大局意识、协作精神和服务精神的集中体现，核心是协同合作，反映的是个体利益和整体利益的统一，并进而保证组织的高效率运转。 团队精神的形成并不要求团队成员牺牲自我，相反，挥洒个性、表现特长保证了成员共同完成任务目标，而明确的协作意愿和协作方式则产生了真正的内心动力。</p>
</blockquote>
<p> 一个团队首先要有一个优秀的领导者，比如IBM的郭士纳,苹果公司的乔布斯,惠普公司的马克赫德。</p>
<p>优秀的领导者能做什么呢？我认为一个优秀的领导者可以带领你前进的方向，让你的方向正确。我们通常说选择大于努力</p>
<p>可能也是因为这个吧。</p>
<blockquote>
<p>例如现在的it行业培训机构 我认为就是只是培训 而一个行业如果想要做好 不付出是不可能的。大家如果都只是来随便讲讲课</p>
<p>聊聊天,那么这种培训机构宁愿不要去。老师应该去教会别人怎样去思考,而不是一味的去叫一门技术,难道五年后技术变革之后在</p>
<p>没人报一个培训班吗？显然不可能</p>
</blockquote>
<p> 第二点就是要有“叛逆”精神大家没必要觉得老师说的都是对的,他只不过比我们多学了10几年而已。我们作为二十一实际的年轻人,应该具有思辨性。不应该全部听从老师的,我们应该去多于团队之间的人间交流,进行思维的碰撞。让自己的认知得到提高</p>
<p>我认为好的团队就是一下几点</p>
<ul>
<li>有一个优秀的领导者</li>
<li>团队氛围(积极的进行思维的交流于碰撞)</li>
</ul>
<p>当然这些太过于理想化,如果一个团队有我想象中的这么美好。我相信一定是战无不胜的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">JUC系列-阻塞队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-17 10:02:03" itemprop="dateCreated datePublished" datetime="2021-11-17T10:02:03+08:00">2021-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a><strong>阻塞队列</strong></h1><h2 id="BlockingQueue-简介"><a href="#BlockingQueue-简介" class="headerlink" title="BlockingQueue 简介"></a><strong>BlockingQueue 简介</strong></h2><p>Concurrent 包中，BlockingQueue 很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了 BlockingQueue 家庭中的所有成员，包括他们各自的功能以及常见使用场景。</p>
<p>阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/07-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png"></p>
<p>当队列是空的，从队列中获取元素的操作将会被阻塞</p>
<p>当队列是满的，从队列中添加元素的操作将会被阻塞</p>
<p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</p>
<p>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</p>
<p>常用的队列主要有以下两种：</p>
<ul>
<li><p>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性</p>
</li>
<li><p>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)</p>
</li>
</ul>
<p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p>
<p>为什么需要 BlockingQueue</p>
<p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都给你一手包办了</p>
<p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细</p>
<p>节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<p>多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和 “消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。</p>
<ul>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），</li>
</ul>
<p>直到有数据放入队列</p>
<ul>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），</li>
</ul>
<p>直到队列中有空的位置，线程被自动唤醒</p>
<h2 id="BlockingQueue-核心方法"><a href="#BlockingQueue-核心方法" class="headerlink" title="BlockingQueue 核心方法"></a><strong>BlockingQueue 核心方法</strong></h2><p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/2SZZBY7T3L~[P3]YPH.png"></p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/37DFEN2P99JCAYRGAP.png"></p>
<p><strong>BlockingQueue 的核心方法</strong>：</p>
<p><strong>1.放入数据</strong></p>
<ul>
<li><p>offer(anObject):表示如果可能的话,将 anObject 加BlockingQueue 里,即如果 BlockingQueue 可以容纳,则返回 true,否则返回 false.<strong>（本方法不阻塞当前执行方法的线程）</strong></p>
</li>
<li><p>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败</p>
</li>
<li><p>put(anObject):把 anObject 加到 BlockingQueue 里,如果 BlockQueue 没有空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续.</p>
</li>
</ul>
<p><strong>2.获取数据</strong></p>
<ul>
<li><p>poll(time): 取走 BlockingQueue 里排在首位的对象,若不能立即取出,<strong>则可以等****time 参数规定的时间,取不到时返回 null</strong></p>
</li>
<li><p>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</p>
</li>
<li><p>take(): 取走 BlockingQueue 里排在首位的对象,BlockingQueue 为空,<strong>阻断进入等待状态直到 BlockingQueue 有新的数据被加入</strong>; </p>
</li>
<li><p>drainTo(): 一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p>
</li>
</ul>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a><strong>入门案例</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.blockingqueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// List list = new ArrayList();</span></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//第一组</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.add(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.add(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.add(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.element());</span></span><br><span class="line"><span class="comment">//System.out.println(blockingQueue.add(&quot;x&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;x&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// 第三组</span></span><br><span class="line"><span class="comment">// blockingQueue.put(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">// blockingQueue.put(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">// blockingQueue.put(&quot;c&quot;);</span></span><br><span class="line"><span class="comment">// //blockingQueue.put(&quot;x&quot;);</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// 第四组</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>,<span class="number">3L</span>, TimeUnit.SECONDS));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见的-BlockingQueue"><a href="#常见的-BlockingQueue" class="headerlink" title="常见的 BlockingQueue"></a><strong>常见的 BlockingQueue</strong></h2><h3 id="ArrayBlockingQueue-常用"><a href="#ArrayBlockingQueue-常用" class="headerlink" title="ArrayBlockingQueue(常用)"></a><strong>ArrayBlockingQueue(常用)</strong></h3><p>基于数组的阻塞队列实现，在 ArrayBlockingQueue 内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p>
<p>ArrayBlockingQueue 在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue 完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea 之所以没这样去做，也许是因为 ArrayBlockingQueue 的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue 和LinkedBlockingQueue 间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node 对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC 的影响还是存在一定的区别。而在创建 ArrayBlockingQueue 时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<p><strong>一句话总结: 由数组结构组成的有界阻塞队列。</strong></p>
<h3 id="LinkedBlockingQueue-常用"><a href="#LinkedBlockingQueue-常用" class="headerlink" title="LinkedBlockingQueue(常用)"></a><strong>LinkedBlockingQueue(常用)</strong></h3><p>基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue 可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>
<p><strong>ArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</strong></p>
<p><strong>一句话总结: 由链表结构组成的有界（但大小默认值integer.MAX_VALUE）阻塞队列。</strong></p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><strong>DelayQueue</strong></h3><p>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
<p><strong>一句话总结: 使用优先级队列实现的延迟无界阻塞队列。</strong></p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><strong>PriorityBlockingQueue</strong></h3><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的 Compator 对象来决定），但需要注意的是 PriorityBlockingQueue 并<strong>不会阻塞数据生产者，而****只会在没有可消费的数据时，阻塞数据的消费者</strong>。</p>
<p>因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费****数据的速度</strong>，否则时间一长，会最终耗尽所有的可用堆内存空间。</p>
<p>在实现 PriorityBlockingQueue 时，内部控制线程同步的锁采用的是<strong>公平锁</strong>。</p>
<p><strong>一句话总结: 支持优先级排序的无界阻塞队列。</strong></p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><strong>SynchronousQueue</strong></h3><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p>
<p>声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的行为</p>
<p><strong>公平模式和非公平模式的区别:</strong> </p>
<ul>
<li><p>公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</p>
</li>
<li><p>非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
</li>
</ul>
<p><strong>一句话总结: 不存储元素的阻塞队列，也即单个元素的队列。</strong></p>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a><strong>LinkedTransferQueue</strong></h3><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和transfer 方法。</p>
<p>LinkedTransferQueue 采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。</p>
<p><strong>一句话总结: 由链表组成的无界阻塞队列。</strong></p>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a><strong>LinkedBlockingDeque</strong></h3><p>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。</p>
<p>对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况 </p>
<ul>
<li><p>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异 常 </p>
</li>
<li><p>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</p>
</li>
</ul>
<p><strong>一句话总结: 由链表组成的双向阻塞队列</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><strong>1. 在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</strong></p>
<p><strong>2. 为什么需要 BlockingQueue?</strong> 在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给你一手包办了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%AF%BB%E5%86%99%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%AF%BB%E5%86%99%E9%94%81/" class="post-title-link" itemprop="url">JUC系列-读写锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-16 22:09:03" itemprop="dateCreated datePublished" datetime="2021-11-16T22:09:03+08:00">2021-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><strong>回顾悲观锁和乐观锁的概念</strong><br><strong>悲观锁</strong>：单独每个人完成事情的时候，执行上锁解锁。解决并发中的问题，不支持并发操作，只能一个一个操作，效率低<br><strong>乐观锁</strong>：每执行一件事情，都会比较数据版本号，谁先提交，谁先提交版本号</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/05-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.png"></p>
<p>新概念：<br>表锁：整个表操作，不会发生死锁<br>行锁：每个表中的单独一行进行加锁，会发生死锁<br>读锁：共享锁（可以有多个人读），会发生死锁<br>写锁：独占锁（只能有一个人写），会发生死锁</p>
<p>读写锁：一个资源可以被多个读线程访问，也可以被一个写线程访问，但不能同时存在读写线程，读写互斥，读读共享</p>
<p>读写锁ReentrantReadWriteLock<br>读锁为ReentrantReadWriteLock.ReadLock，readLock()方法<br>写锁为ReentrantReadWriteLock.WriteLock，writeLock()方法</p>
<p>创建读写锁对象private ReadWriteLock rwLock = new ReentrantReadWriteLock();<br>写锁 加锁 rwLock.writeLock().lock();，解锁为rwLock.writeLock().unlock();<br>读锁 加锁rwLock.readLock().lock();，解锁为rwLock.readLock().unlock();</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/08-%E8%AF%BB%E5%86%99%E9%94%81.png"></p>
<h2 id="读写锁介绍"><a href="#读写锁介绍" class="headerlink" title="读写锁介绍"></a><strong>读写锁介绍</strong></h2><p>现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。</p>
<p>针对这种场景，<strong>JAVA 的并发包提供了读写锁 ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁</strong></p>
<ol>
<li>线程进入读锁的前提条件：</li>
</ol>
<ul>
<li><p>没有其他线程的写锁</p>
</li>
<li><p>没有写请求, 或者==有写请求，但调用线程和持有锁的线程是同一个(可重入锁)。</p>
</li>
</ul>
<ol start="2">
<li>线程进入写锁的前提条件：</li>
</ol>
<ul>
<li><p>没有其他线程的读锁</p>
</li>
<li><p>没有其他线程的写锁</p>
</li>
</ul>
<p>而读写锁有以下三个重要的特性：</p>
<p>（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公</p>
<p>平优于公平。</p>
<p>（2）重进入：读锁和写锁都支持线程重进入。</p>
<p>（3）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为</p>
<p>读锁。</p>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a><strong>ReentrantReadWriteLock</strong></h2><p>ReentrantReadWriteLock 类的整体结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>,</span></span><br><span class="line"><span class="class">        <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 读锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** 写锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用默认（非公平）的排序属性创建一个新的</span></span><br><span class="line"><span class="comment">     ReentrantReadWriteLock */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回用于写入操作的锁 */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span></span><br><span class="line">            writerLock; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回用于读取操作的锁 */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock <span class="title">readLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span></span><br><span class="line">            readerLock; &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，ReentrantReadWriteLock 实现了 ReadWriteLock 接口，ReadWriteLock 接口定义了获取读锁和写锁的规范，具体需要实现类去实现；同时其还实现了 Serializable 接口，表示可以进行序列化，在源代码中可以看到 ReentrantReadWriteLock 实现了自己的序列化逻辑。</p>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a><strong>入门案例</strong></h2><p><strong>场景: 使用 ReentrantReadWriteLock 对一个 hashmap 进行读和写操作</strong></p>
<p>实现案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.readwrite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建map集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建读写锁的对象</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//添加写锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;正在写操作&quot;</span> + key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停一会</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="comment">//放数据</span></span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写完了&quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//添加读锁</span></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在取操作&quot;</span>);</span><br><span class="line">        <span class="comment">//暂停一会</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取完 &quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放读锁</span></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="comment">//创建线程放数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                myCache.put(num+<span class="string">&quot;&quot;</span>,num+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建线程取数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                myCache.get(num+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结-重要"><a href="#小结-重要" class="headerlink" title="小结(重要)"></a><strong>小结(重要)</strong></h2><ul>
<li><p>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。 </p>
</li>
<li><p>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p>
</li>
</ul>
<p>原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%83%E7%AB%A0-JUC-%E4%B8%89%E5%A4%A7%E8%BE%85%E5%8A%A9%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%83%E7%AB%A0-JUC-%E4%B8%89%E5%A4%A7%E8%BE%85%E5%8A%A9%E7%B1%BB/" class="post-title-link" itemprop="url">JUC系列-JUC 三大辅助类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-16 20:03:03" itemprop="dateCreated datePublished" datetime="2021-11-16T20:03:03+08:00">2021-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JUC-三大辅助类"><a href="#JUC-三大辅助类" class="headerlink" title="JUC 三大辅助类"></a><strong>JUC 三大辅助类</strong></h1><p>JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时 Lock 锁的频繁操作。这三种辅助类为：</p>
<p>• CountDownLatch: 减少计数</p>
<p>• CyclicBarrier: 循环栅栏</p>
<p>• Semaphore: 信号灯</p>
<p>下面我们分别进行详细的介绍和学习</p>
<h2 id="减少计数-CountDownLatch"><a href="#减少计数-CountDownLatch" class="headerlink" title="减少计数 CountDownLatch"></a><strong>减少计数 CountDownLatch</strong></h2><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。</p>
<ul>
<li>CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，这</li>
</ul>
<p>些线程会阻塞</p>
<ul>
<li>其它线程调用 countDown 方法会将计数器减 1(调用 countDown 方法的线程</li>
</ul>
<p>不会阻塞) </p>
<ul>
<li>当计数器的值变为 0 时，因 await 方法阻塞的线程会被唤醒，继续执行</li>
</ul>
<p><strong>场景: 6 个同学陆续离开教室后值班同学才可以关门。</strong></p>
<p>CountDownLatchDemo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示CountDownLatch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//六个同学陆续离开教室之后,班长锁门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建CountDownLatch对象m设置初始值</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//六个同学陆续离开教室之后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;号同学离开了教室&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计数</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;班长锁门走人了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环栅栏-CyclicBarrier"><a href="#循环栅栏-CyclicBarrier" class="headerlink" title="循环栅栏 CyclicBarrier"></a><strong>循环栅栏 CyclicBarrier</strong></h2><p>CyclicBarrier 看英文单词可以看出大概就是循环阻塞的意思，在使用中CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</p>
<p>该类是一个同步辅助类，允许一组县城互相等到，直到到达某个公共屏障点，在设计一组固定大小的线程的程序中，这些线程必须互相等待，这个类很有用，因为barrier在释放等待线程后可以重用，所以称为循环barrier</p>
<p>常用的构造方法有：<br>CyclicBarrier(int parties，Runnable barrierAction)创建一个新的CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动barrier时执行给定的屏障操作，该操作由最后一个进入barrier的线程操作</p>
<p>常用的方法有：</p>
<blockquote>
<p>await()在所有的参与者都已 经在此barrier上调用await方法之前一直等待</p>
</blockquote>
<p><strong>场景: 集齐 7 颗龙珠就可以召唤神龙</strong></p>
<p>CyclicBarrierDemo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">//集齐7颗龙珠可以召唤神龙</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建固定值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUMBER,()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;集齐7颗龙珠就可以召唤神龙&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//集齐七颗龙珠过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;星龙珠收集到了&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong><br>CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</p>
<h2 id="信号灯-Semaphore"><a href="#信号灯-Semaphore" class="headerlink" title="信号灯 Semaphore"></a><strong>信号灯 Semaphore</strong></h2><p>Semaphore 的构造方法中传入的第一个参数是最大信号量（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证。使用 acquire 方法获得许可证，release 方法释放许可</p>
<p>场景: 抢车位, 6 部汽车 3 个停车位</p>
<p>SemaphoreDemo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//六辆汽车,停三个停车位</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Semaphore,设置许可数量</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟六辆汽车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//抢占</span></span><br><span class="line">                   semaphore.acquire();</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到了车位&quot;</span>);</span><br><span class="line">                   <span class="comment">//设置随机停车时间</span></span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;------离开了车位&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">//释放</span></span><br><span class="line">                   semaphore.release();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%85%AD%E7%AB%A0-Callable-Future-%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%85%AD%E7%AB%A0-Callable-Future-%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">JUC系列-Callable&Future 接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-16 17:03:03" itemprop="dateCreated datePublished" datetime="2021-11-16T17:03:03+08:00">2021-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Callable-amp-Future-接口"><a href="#Callable-amp-Future-接口" class="headerlink" title="Callable&amp;Future 接口"></a><strong>Callable&amp;Future 接口</strong></h1><h2 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a><strong>Callable 接口</strong></h2><p>目前我们学习了有两种创建线程的方法-一种是通过创建 Thread 类，另一种是通过使用 Runnable 创建线程。但是，Runnable 缺少的一项功能是，当线程终止时（即 run（）完成时），我们无法使线程返回结果。为了支持此功能，</p>
<p>Java 中提供了 Callable 接口。</p>
<p>==<strong>现在我们学习的是创建线程的第三种方案—Callable 接口</strong>==</p>
<p><strong>Callable 接口的特点如下(重点)</strong> </p>
<ul>
<li>为了实现 Runnable，需要实现不返回任何内容的 run（）方法，而对于</li>
</ul>
<p>Callable，需要实现在完成时返回结果的 call（）方法。</p>
<ul>
<li><p> call（）方法可以引发异常，而 run（）则不能。</p>
</li>
<li><p>为实现 Callable 而必须重写 call 方法</p>
</li>
<li><p>不能直接替换 runnable,因为 Thread 类的构造方法根本没有 Callable</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">创建新类 MyThread1 实现 runnable 接口</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现Callable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a><strong>Future 接口</strong></h2><p>当 call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用 Future 对象。</p>
<p>将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦Callable 返回）。Future 基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下: </p>
<p>• <strong>public boolean cancel（boolean mayInterrupt）：</strong>用于停止任务。</p>
<p>==如果尚未启动，它将停止任务。如果已启动，则仅在 mayInterrupt 为 true时才会中断任务。==</p>
<p>• <strong>public Object get（）抛出 InterruptedException，ExecutionException：</strong>用于获取任务的结果。</p>
<p>==如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。</p>
<p>==</p>
<p>• <strong>public boolean isDone（）：</strong>如果任务完成，则返回 true，否则返回 false可以看到 Callable 和 Future 做两件事-Callable 与 Runnable 类似，因为它封装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结果。实际上，future 也可以与 Runnable 一起使用。</p>
<p>要创建线程，需要 Runnable。为了获得结果，需要 future。 </p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a><strong>FutureTask</strong></h2><p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建Thread 对象。因此，间接地使用 Callable 创建线程。</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/06-futureTask.png"></p>
<p><strong>核心原理:(重点)</strong></p>
<p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成</p>
<ul>
<li><p>当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执行状态</p>
</li>
<li><p> 一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>
</li>
<li><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法</p>
</li>
<li><p>一旦计算完成，就不能再重新开始或取消计算</p>
</li>
<li><p>get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常</p>
</li>
<li><p>get 只计算一次,因此 get 方法放到最后</p>
</li>
</ul>
<p><strong>demo 案例</strong></p>
<h2 id="使用-Callable-和-Future"><a href="#使用-Callable-和-Future" class="headerlink" title="使用 Callable 和 Future"></a><strong>使用 Callable 和 Future</strong></h2><p>CallableDemo 案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两个接口</span></span><br><span class="line"><span class="comment">//实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现Callable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//Runnable接口创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1(),<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Callable接口创建线程</span></span><br><span class="line">        <span class="comment">//new Thread(new MyThread2(),&quot;BB&quot;).start();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//FutureTask</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lam表达式</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;come in callable&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask2,<span class="string">&quot;luck&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!futureTask2.isDone())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;wait.....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用FutureTask的get方法</span></span><br><span class="line">        System.out.println(futureTask2.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;come over&quot;</span>);</span><br><span class="line">        <span class="comment">//FutureTask原理  未来任务</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.老师来了,口渴了,去买水不合适,讲课线程继续</span></span><br><span class="line"><span class="comment">         * 单开启线程找班上班长帮我买水,把水买回来,需要时直接get</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2.4个同学, 1同学 1+2...5 , 2同学 10+11+12...50 3同学 60+61+62， 4同学 100+200</span></span><br><span class="line"><span class="comment">         *  第二个同学计算量比较大,</span></span><br><span class="line"><span class="comment">         *  FutureTask单开启线程给2同学计算,先汇总 1 3 4, 最后等2同学计算位完成,统一汇总</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3.考试, 做会做的题目,最后看不会做的题目</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 汇总一次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="小结-重点"><a href="#小结-重点" class="headerlink" title="小结(重点)"></a><strong>小结(重点)</strong></h2><ul>
<li><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成, 当主线程将来需要时，就可以通过 Future对象获得后台作业的计算结果或者执行状态</p>
</li>
<li><p>  一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果</p>
</li>
<li><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</p>
</li>
<li><p> 只计算一次</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/" class="post-title-link" itemprop="url">JUC系列-多线程锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-15 17:03:03" itemprop="dateCreated datePublished" datetime="2021-11-15T17:03:03+08:00">2021-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="多线程锁"><a href="#多线程锁" class="headerlink" title="多线程锁"></a>多线程锁</h1><h2 id="锁的八个问题演示"><a href="#锁的八个问题演示" class="headerlink" title="锁的八个问题演示"></a><strong>锁的八个问题演示</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//停留4秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------getHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用锁的对象机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock_8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// phone.sendEmail();</span></span><br><span class="line">               <span class="comment">// phone.getHello();</span></span><br><span class="line">                phone2.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体八种情况为</p>
<blockquote>
<p>1 标准访问，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>2 停4秒在短信方法内，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>3 新增普通的hello方法，是先打短信还是hello<br>——getHello<br>——sendSMS<br>4 现在有两部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS<br>5 两个静态同步方法，1部手机，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>6 两个静态同步方法，2部手机，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>7 1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS<br>8 1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS</p>
</blockquote>
<p><strong>结论</strong><strong>:</strong></p>
<p>一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，</p>
<p>其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized 方法</p>
<p>锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized 方法</p>
<p>加个普通方法后发现和同步锁无关</p>
<p>换成两个对象后，不是同一把锁了，情况立刻变化。</p>
<p>synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。</p>
<p><strong>具体表现为以下</strong> <strong>3</strong> <strong>种形式。</strong></p>
<p><strong>对于普通同步方法，锁是当前实例对象。</strong></p>
<p><strong>对于静态同步方法，锁是当前类的</strong> <strong>Class</strong> <strong>对象。</strong></p>
<p><strong>对于同步方法块，锁是</strong> <strong>Synchonized</strong> <strong>括号里配置的对象</strong></p>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，</p>
<p>可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</p>
<p>但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><ul>
<li><strong>公平锁</strong>：效率相对低</li>
<li><strong>非公平锁</strong>：效率高，但是线程容易饿死</li>
</ul>
<p>通过查看源码<br>带有参数的<code>ReentrantLock(true)</code>为<strong>公平锁</strong><br><code>ReentrantLock(false)</code>为<strong>非公平锁</strong><br>主要是调用<code>NonfairSync()</code>与<code>FairSync()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>具体其非公平锁与公平锁的源码<br>查看公平锁的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Acquires only if reentrant or queue is empty.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initialTryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Thread current = Thread.currentThread();</span><br><span class="line">   <span class="keyword">int</span> c = getState();</span><br><span class="line">   <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!hasQueuedThreads() &amp;&amp; compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">     setExclusiveOwnerThread(current);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getExclusiveOwnerThread() == current) &#123;</span><br><span class="line">      <span class="keyword">if</span> (++c &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(c);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过代码实例具体操作</p>
<p>在最前面售票代码中<br>继续引用前面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步  创建资源类，定义属性和和操作方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LTicket</span> </span>&#123;</span><br><span class="line">    <span class="comment">//票数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//卖票方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否有票</span></span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ：卖出&quot;</span>+(number--)+<span class="string">&quot; 剩余：&quot;</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LSaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第二步 创建多个线程，调用资源类的操作方法</span></span><br><span class="line">    <span class="comment">//创建三个线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LTicket ticket = <span class="keyword">new</span> LTicket();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        ticket.sale();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;CC&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都是A线程执行，而BC线程都没执行到，出现了<strong>非公平锁</strong><br>具体改变其设置可以通过可重入锁中的一个有参构造方法</p>
<p>修改代码为<code>private final ReentrantLock lock = new ReentrantLock(true);</code><br>代码截图为</p>
<p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/R07HNGWKR.png"></p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>synchronized和lock都是可重入锁</p>
<ul>
<li>sychronized是隐式锁，不用手工上锁与解锁，而lock为显示锁，需要手工上锁与解锁</li>
<li>可重入锁也叫递归锁</li>
</ul>
<p>而且有了可重入锁之后，破解第一把之后就可以一直进入到内层结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(o) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 外层&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 中层&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 内层&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p><code>synchronized (o)</code>代表锁住当前<code>&#123; &#125;</code>内的代码块</p>
<p>以上都是synchronized锁机制<br>下面讲解lock锁机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Lock演示可重入锁</span></span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//上锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 外层&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//上锁</span></span><br><span class="line">                    lock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 内层&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放做</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在同一把锁中的嵌套锁，内部嵌套锁没解锁还是可以输出，但是如果跳出该线程，执行另外一个线程就会造成死锁<br>要把握上锁与解锁的概念，都要写上</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/16-%E6%AD%BB%E9%94%81.png"></p>
<p><strong>产生死锁的原因：</strong></p>
<ol>
<li>系统资源不足</li>
<li>系统资源分配不当</li>
<li>进程运行顺序不当</li>
</ol>
<p><strong>验证是否是死锁</strong></p>
<ol>
<li>jps 类似于linux中的<code>ps -ef</code>查看进程号</li>
<li>jstack 自带的堆栈跟踪工具</li>
</ol>
<p>通过用idea自带的命令行输入 <code>jps -l</code><br>查看其编译代码的进程号后<code>jstack 进程号</code></p>
<p><strong>具体死锁的操作代码实列</strong><br>可理解背下来，大厂面试可考，死锁的简单案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个对象</span></span><br><span class="line">    <span class="keyword">static</span> Object a = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object b = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 持有锁a，试图获取锁b&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获取锁b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 持有锁b，试图获取锁a&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获取锁a&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="JUC">
    <link itemprop="mainEntityOfPage" href="http://yoursite-url/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/}VRZRM08TG_W9[WMAD}69[O.png">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="It's an IT blog...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Study Node">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">JUC系列-集合的线程安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-15 14:03:03" itemprop="dateCreated datePublished" datetime="2021-11-15T14:03:03+08:00">2021-11-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="集合的线程安全"><a href="#集合的线程安全" class="headerlink" title="集合的线程安全"></a>集合的线程安全</h1><h2 id="集合操作-Demo"><a href="#集合操作-Demo" class="headerlink" title="集合操作 Demo"></a><strong>集合操作 Demo</strong></h2><p>NotSafeDemo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个线程同时对集合进行修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString());</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常内容</p>
<p>java.util.ConcurrentModificationException</p>
<p><strong>问题: 为什么会出现并发修改异常?</strong></p>
<p>查看 ArrayList 的 add 方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line">	elementData[size++] = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==<strong>那么我们如何去解决 List 类型的线程安全问题?</strong>==</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><strong>Vector</strong></h2><p>Vector 是<strong>矢量队列</strong>，它是 JDK1.0 版本添加的类。继承于 AbstractList，实现了 List, RandomAccess, Cloneable 这些接口。 Vector 继承了 AbstractList，实现了 List；所以，<strong>它是一个队列，支持相关的添加、删除、修改、遍历等功能</strong>。 Vector 实现了 RandmoAccess 接口，即<strong>提供了随机访问功能</strong>。</p>
<p>RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在Vector 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 Vector 实现了 Cloneable 接口，即实现 clone()函数。它能被克隆。</p>
<p><strong>==和 ArrayList 不同，Vector 中的操作是线程安全的。==</strong></p>
<p>NotSafeDemo 代码修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合线程安全案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个线程同时对集合进行修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> Vector();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString());</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现在没有运行出现并发异常,为什么?</strong></p>
<p>查看 Vector 的 add 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this Vector.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this Vector</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	modCount++;</span><br><span class="line">	ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">	elementData[elementCount++] = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>add 方法被 synchronized 同步修辞,线程安全!因此没有并发异常</strong></p>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a><strong>Collections</strong></h2><p>Collections 提供了方法 synchronizedList 保证 list 是同步线程安全的</p>
<p>NotSafeDemo 代码修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合线程安全案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个线程同时对集合进行修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString());</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有并发修改异常</p>
<p>查看方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a synchronized (thread-safe) list backed by the specified</span></span><br><span class="line"><span class="comment">* list. In order to guarantee serial access, it is critical that</span></span><br><span class="line"><span class="comment">* &lt;strong&gt;all&lt;/strong&gt; access to the backing list is accomplished</span></span><br><span class="line"><span class="comment">* through the returned list.&lt;p&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* It is imperative that the user manually synchronize on the returned</span></span><br><span class="line"><span class="comment">* list when iterating over it:</span></span><br><span class="line"><span class="comment">* &lt;pre&gt;</span></span><br><span class="line"><span class="comment">* List list = Collections.synchronizedList(new ArrayList());</span></span><br><span class="line"><span class="comment">* ...</span></span><br><span class="line"><span class="comment">* synchronized (list) &#123;</span></span><br><span class="line"><span class="comment">* Iterator i = list.iterator(); // Must be in synchronized block</span></span><br><span class="line"><span class="comment">* while (i.hasNext())</span></span><br><span class="line"><span class="comment">* foo(i.next());</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">* &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">* Failure to follow this advice may result in non-deterministic behavior.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;The returned list will be serializable if the specified list is</span></span><br><span class="line"><span class="comment">* serializable.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; the class of the objects in the list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> list the list to be &quot;wrapped&quot; in a synchronized list.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> a synchronized view of the specified list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line"><span class="keyword">new</span> SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line"><span class="keyword">new</span> SynchronizedList&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CopyOnWriteArrayList-重点"><a href="#CopyOnWriteArrayList-重点" class="headerlink" title="CopyOnWriteArrayList(重点)"></a><strong>CopyOnWriteArrayList(重点)</strong></h2><p>首先我们对 CopyOnWriteArrayList 进行学习,其特点如下:</p>
<p>它相当于线程安全的 ArrayList。和 ArrayList 一样，它是个可变数组；但是和</p>
<p>ArrayList 不同的时，它具有以下特性：</p>
<ol>
<li>它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多</li>
</ol>
<p>于可变操作，需要在遍历期间防止线程间的冲突。</p>
<ol start="2">
<li><p>它是线程安全的。</p>
</li>
<li><p>因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() </p>
</li>
</ol>
<p>等等）的开销很大。</p>
<ol start="4">
<li><p>迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。</p>
</li>
<li><p>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代</p>
</li>
</ol>
<p>器时，迭代器依赖于不变的数组快照。</p>
<p><strong>1. 独占锁效率低：采用读写分离思想解决</strong></p>
<p><strong>2. 写线程获取到锁，其他写线程阻塞</strong></p>
<p><strong>3. 复制思想</strong></p>
<p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p>
<p><strong>这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来</strong></p>
<p><strong>得及写会内存，其他的线程就会读到了脏数据。</strong></p>
<p>==<strong>这就是 CopyOnWriteArrayList 的思想和原理。就是拷贝一份。</strong>==</p>
<p>NotSafeDemo 代码修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hao.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合线程安全案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个线程同时对集合进行修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString());</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有线程安全问题</p>
<p><strong>原因分析</strong>(<strong>重点</strong>):==<strong>动态数组与线程安全</strong>==</p>
<p>下面从“动态数组”和“线程安全”两个方面进一步对</p>
<p>CopyOnWriteArrayList 的原理进行说明。</p>
<p><strong>“动态数组”机制</strong></p>
<ul>
<li>它内部有个“volatile 数组”(array)来保持数据。在“添加/修改/删除”数据</li>
</ul>
<p>时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该</p>
<p>数组赋值给“volatile 数组”, 这就是它叫做 CopyOnWriteArrayList 的原因</p>
<ul>
<li><strong>由于它在“添加/修改/删除”数据时，都会新建数组，所以涉及到修改数据的</strong></li>
</ul>
<p><strong>操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，</strong></p>
<p><strong>效率比较高。</strong></p>
<p><strong>“线程安全”机制</strong></p>
<ul>
<li><p>通过 volatile 和互斥锁来实现的。</p>
</li>
<li><p>通过“volatile 数组”来保存数据的。一个线程读取 volatile 数组时，总能看</p>
</li>
</ul>
<p>到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了“读</p>
<p>取到的数据总是最新的”这个机制的保证。</p>
<ul>
<li>通过互斥锁来保护数据。在“添加/修改/删除”数据时，会先“获取互斥锁”，</li>
</ul>
<p>再修改完毕之后，先将数据更新到“volatile 数组”中，然后再“释放互斥</p>
<p>锁”，就达到了保护数据的目的。</p>
<h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h2><p>该类是HashSet的实现类<br>同样使用HashSet类，也会出现线程不安全<br>java Set<String> set = new HashSet&lt;&gt;();<br>需要将上面的代码改为<br>Set<String> set = new CopyOnWriteArraySet&lt;&gt;();</p>
<p>具体操作代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//向集合添加内容</span></span><br><span class="line">        set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">        <span class="comment">//从集合获取内容</span></span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;,String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code>类是HashMap的实现类<br>先讲述其线程不安全实列</p>
<p>HashMap不安全线程也同理<code>Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</code><br>具体实现代码是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span>; i++) &#123;</span><br><span class="line">    String key = String.valueOf(i);</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//向集合添加内容</span></span><br><span class="line">        map.put(key,UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">        <span class="comment">//从集合获取内容</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;,String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其代码修改为<br><code>Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();</code><br>通过这行代码可以编程线程安全</p>
<h2 id="小结-重点"><a href="#小结-重点" class="headerlink" title="小结(重点)"></a><strong>小结(重点)</strong></h2><p><strong>1.线程安全与线程不安全集合</strong></p>
<p>集合类型中存在线程安全与线程不安全的两种,常见例如:</p>
<p>ArrayList —– Vector</p>
<p>HashMap —–HashTable</p>
<p>但是以上都是通过 synchronized 关键字实现,效率较低</p>
<p><strong>2.Collections 构建的线程安全集合</strong></p>
<p><strong>3.java.util.concurrent 并发包下</strong></p>
<p>CopyOnWriteArrayList CopyOnWriteArraySet 类型,通过动态数组与线程安</p>
<p>全个方面保证线程安全</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/archives/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/archives/5/">5</a><a class="extend next" rel="next" href="/archives/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
