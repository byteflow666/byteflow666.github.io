[{"title":"JVM系列-第2章-类加载子系统","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/","content":"<h1 id=\"JVM类加载子系统\"><a href=\"#JVM类加载子系统\" class=\"headerlink\" title=\"JVM类加载子系统\"></a>JVM类加载子系统</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><img src=\"https://raw.githubusercontent.com/byteflow666/images/main/124124124.png\"></p>\n<p>完整图如下</p>\n<p><img src=\"https://raw.githubusercontent.com/byteflow666/images/main/asdasdasdsadasd.png\"></p>\n<p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p>\n<ul>\n<li><p>类加载器</p>\n</li>\n<li><p>执行引擎</p>\n</li>\n</ul>\n<h2 id=\"类加载子系统作用\"><a href=\"#类加载子系统作用\" class=\"headerlink\" title=\"类加载子系统作用\"></a>类加载子系统作用</h2><p>类加载子系统负责从文件系统或者网络中加载class文件,class文件在文件开头有特定的文件标识</p>\n<p>ClassLoader只负责class文件的加载,至于它是否可以运行，则由Execution engine决定</p>\n<p>加载的类信息存放在一块称为方法区的内存空间。除了类信息外,方法区中还会存放运行时常量池信息,可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/V7R2RHMH1W[~KY$NNQU$]DM.png\"></p>\n<ul>\n<li><p>class file存在本地硬盘上,可以理解为设计师画在纸上的模板,而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</p>\n</li>\n<li><p>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</p>\n</li>\n<li><p>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</p>\n</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/OCH9ZRGD[%7BAEG37KXU[KC27.png\"></p>\n<h2 id=\"类的加载过程\"><a href=\"#类的加载过程\" class=\"headerlink\" title=\"类的加载过程\"></a>类的加载过程</h2><p>例如下面的一段简单的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我已经被加载啦&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>它的加载过程是怎么样的呢?</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/0@%I%7DA$[JIX$XSX%7B5Y42]FB.png\"></p>\n<p>完整的流程图如下所示</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/_XLU[%60_XJLFK03531@8J]DM.png\"></p>\n<h2 id=\"加载阶段\"><a href=\"#加载阶段\" class=\"headerlink\" title=\"加载阶段\"></a>加载阶段</h2><p>通过一个类的全限定名获取定义此类的二进制字节流</p>\n<p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>\n<p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>\n<h3 id=\"加载class文件的方式\"><a href=\"#加载class文件的方式\" class=\"headerlink\" title=\"加载class文件的方式\"></a>加载class文件的方式</h3><ul>\n<li>从本地系统中直接加载</li>\n<li>通过网络获取，典型场景：Web Applet</li>\n<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>\n<li>运行时计算生成，使用最多的是：动态代理技术</li>\n<li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class</li>\n<li>文件，比较少见</li>\n<li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li>\n</ul>\n<h3 id=\"验证-Verify\"><a href=\"#验证-Verify\" class=\"headerlink\" title=\"验证 Verify\"></a>验证 Verify</h3><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p>\n<p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>\n<p> <em>工具：Binary Viewer查看</em></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/]5I~HF[BP]@82U3KSGTJCMG.png\"></p>\n<p>如果出现不合法的字节码文件，那么将会验证不通过</p>\n<p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/qwesc.png\"></p>\n<p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p>\n<h3 id=\"准备-Prepare\"><a href=\"#准备-Prepare\" class=\"headerlink\" title=\"准备 Prepare\"></a>准备 Prepare</h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloApp</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;  <span class=\"comment\">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的变量a在准备阶段会赋初始值，但不是1，而是0。</p>\n<p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p>\n<p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p>\n<p>例如下面这段代码</p>\n<h3 id=\"解析-Resolve\"><a href=\"#解析-Resolve\" class=\"headerlink\" title=\"解析 Resolve\"></a>解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p>\n<p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>\n<p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>\n<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>初始化阶段就是执行类构造器法（）的过程。</p>\n<p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p>\n<ul>\n<li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li>\n</ul>\n<p>构造器方法中指令按语句在源文件中出现的顺序执行。</p>\n<p>（）不同于类的构造器。（关联：构造器是虚拟机视角下的（））若该类具有父类，JVM会保证子类的（）执行前，父类的（）已经执行完毕。</p>\n<ul>\n<li><p>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassInitTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> num = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        num = <span class=\"number\">2</span>;</span><br><span class=\"line\">        number = <span class=\"number\">20</span>;</span><br><span class=\"line\">        System.out.println(num);</span><br><span class=\"line\">        System.out.println(number);  <span class=\"comment\">//报错，非法的前向引用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> number = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(ClassInitTest.num); <span class=\"comment\">// 2</span></span><br><span class=\"line\">        System.out.println(ClassInitTest.number); <span class=\"comment\">// 10</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 关于涉及到父类时候的变量赋值过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClinitTest1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> A = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">            A = <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b = A;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(Son.b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然</p>\n<p>后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化</p>\n<p>，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来</p>\n<p>的值被赋值成1，然后又被复制成2，最后返回</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">iconst_1</span><br><span class=\"line\"></span><br><span class=\"line\">putstatic #<span class=\"number\">2</span> &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">iconst_2</span><br><span class=\"line\"></span><br><span class=\"line\">putstatic #<span class=\"number\">2</span> &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>虚拟机必须保证一个类的（）方法在多线程下被同步加锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;\\t 线程t1开始&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">new</span> DeadThread();</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;\\t 线程t2开始&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">new</span> DeadThread();</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadThread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;\\t 初始化当前类&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，输出结果为</p>\n<p>线程t1开始</p>\n<p>线程t2开始</p>\n<p>线程t2 初始化当前类</p>\n<p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p>\n<h2 id=\"类加载器的分类\"><a href=\"#类加载器的分类\" class=\"headerlink\" title=\"类加载器的分类\"></a>类加载器的分类</h2><h3 id=\"虚拟机自带的加载器\"><a href=\"#虚拟机自带的加载器\" class=\"headerlink\" title=\"虚拟机自带的加载器\"></a>虚拟机自带的加载器</h3><p><strong>启动类加载器(引导类加载器,Bootstrap ClassLoader)</strong></p>\n<ul>\n<li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li>\n<li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>\n<li>并不继承自ava.lang.ClassLoader，没有父加载器。</li>\n<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>\n<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的</li>\n</ul>\n<h3 id=\"扩展类加载器（Extension-ClassLoader）\"><a href=\"#扩展类加载器（Extension-ClassLoader）\" class=\"headerlink\" title=\"扩展类加载器（Extension ClassLoader）\"></a>扩展类加载器（Extension ClassLoader）</h3><ul>\n<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>\n<li>派生于ClassLoader类</li>\n<li>父类加载器为启动类加载器</li>\n<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>\n</ul>\n<h3 id=\"应用程序类加载器（系统类加载器，AppClassLoader）\"><a href=\"#应用程序类加载器（系统类加载器，AppClassLoader）\" class=\"headerlink\" title=\"应用程序类加载器（系统类加载器，AppClassLoader）\"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul>\n<li>avI语言编写，由sun.misc.LaunchersAppClassLoader实现</li>\n<li>派生于ClassLoader类</li>\n<li>父类加载器为扩展类加载器</li>\n<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>\n<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>\n<li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li>\n</ul>\n<h3 id=\"用户自定义类加载器\"><a href=\"#用户自定义类加载器\" class=\"headerlink\" title=\"用户自定义类加载器\"></a>用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p>\n<ul>\n<li>隔离加载类</li>\n<li>修改类加载的方式</li>\n<li>扩展加载源</li>\n<li>防止源码泄漏</li>\n</ul>\n<p>用户自定义类加载器实现步骤：</p>\n<ul>\n<li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>\n<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li>\n<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>\n</ul>\n<h3 id=\"查看根加载器所能加载的目录\"><a href=\"#查看根加载器所能加载的目录\" class=\"headerlink\" title=\"查看根加载器所能加载的目录\"></a>查看根加载器所能加载的目录</h3><p>刚刚我们通过概念了解到了，根加载器只能够加载 java /lib目录下的class，我们通过下面代码验证一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassLoaderTest1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;*********启动类加载器************&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取BootstrapClassLoader 能够加载的API的路径</span></span><br><span class=\"line\">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (URL url : urls) &#123;</span><br><span class=\"line\">            System.out.println(url.toExternalForm());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span></span><br><span class=\"line\">        ClassLoader classLoader = Provider.class.getClassLoader();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>得到的结果</p>\n<p><em><strong><strong><strong><strong>启动类加载器</strong></strong></strong></strong></em>***</p>\n<p> file:/E:/Software/JDK1.8/Java/jre/lib/resources.jar file:/E:/Software/JDK1.8/Java/jre/lib/rt.jar file:/E:/Software/JDK1.8/Java/jre/lib/sunrsasign.jar file:/E:/Software/JDK1.8/Java/jre/lib/jsse.jar file:/E:/Software/JDK1.8/Java/jre/lib/jce.jar file:/E:/Software/JDK1.8/Java/jre/lib/charsets.jar file:/E:/Software/JDK1.8/Java/jre/lib/jfr.jar file:/E:/Software/JDK1.8/Java/jre/classes null</p>\n<h3 id=\"关于ClassLoader\"><a href=\"#关于ClassLoader\" class=\"headerlink\" title=\"关于ClassLoader\"></a>关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/hao1.png\"></p>\n<p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/ON]]36ZK232H7]V~OZ358.png\"></p>\n<p>获取ClassLoader的途径</p>\n<ul>\n<li><p>获取当前ClassLoader：clazz.getClassLoader()</p>\n</li>\n<li><p>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</p>\n</li>\n<li><p>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</p>\n</li>\n<li><p>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</p>\n</li>\n</ul>\n<h2 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><ul>\n<li><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</p>\n</li>\n<li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</p>\n</li>\n<li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/%7D(XZSELGT$5N[)Y3C~Z]NSS.png\"></p>\n</li>\n</ul>\n<h3 id=\"双亲委派机制举例\"><a href=\"#双亲委派机制举例\" class=\"headerlink\" title=\"双亲委派机制举例\"></a>双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/422.png\"></p>\n<h3 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h3><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>\n<h3 id=\"双亲委派机制的优势\"><a href=\"#双亲委派机制的优势\" class=\"headerlink\" title=\"双亲委派机制的优势\"></a>双亲委派机制的优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p>\n<ul>\n<li>避免类的重复加载</li>\n<li>保护程序安全，防止核心API被随意篡改<ul>\n<li>自定义类：java.lang.String</li>\n<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"如何判断两个class对象是否相同\"><a href=\"#如何判断两个class对象是否相同\" class=\"headerlink\" title=\"如何判断两个class对象是否相同\"></a>如何判断两个class对象是否相同</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>\n<ul>\n<li>类的完整类名必须一致，包括包名。</li>\n<li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li>\n</ul>\n<p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p>\n<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>\n<h3 id=\"类的主动使用和被动使用\"><a href=\"#类的主动使用和被动使用\" class=\"headerlink\" title=\"类的主动使用和被动使用\"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：王动使用和被动使用。 主动使用，又分为七种情况：</p>\n<ul>\n<li>创建类的实例</li>\n<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>\n<li>调用类的静态方法I</li>\n<li>反射（比如：Class.forName（”com.atguigu.Test”））</li>\n<li>初始化一个类的子类</li>\n<li>Java虚拟机启动时被标明为启动类的类</li>\n<li>JDK7开始提供的动态语言支持：</li>\n<li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li>\n</ul>\n<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第1章-JVM与Java体系结构","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC1%E7%AB%A0-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"<blockquote>\n<p>1、本系列博客，主要是面向Java8的虚拟机。如有特殊说明，会进行标注。</p>\n<p>2、本系列博客主要参考<strong>尚硅谷的JVM视频教程</strong>，整理不易，所以图片打上了一些水印，还请读者见谅。后续可能会加上一些补充的东西。</p>\n</blockquote>\n<h1 id=\"第1章-JVM和Java体系架构\"><a href=\"#第1章-JVM和Java体系架构\" class=\"headerlink\" title=\"第1章-JVM和Java体系架构\"></a>第1章-JVM和Java体系架构</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>你是否也遇到过这些问题？</p>\n<ol>\n<li> 运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！</li>\n<li> 想解决线上JVM GC问题，但却无从下手。</li>\n<li> 新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了。</li>\n<li> 每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li>\n</ol>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/H8]3%7DFLKTIQ@1CUY[O8G~8.png\"></p>\n<p>大部分Java开发人员，除会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p>\n<p>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</p>\n<p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/LM%60J85N6AJ41@K2KYNYR%F.png\"></p>\n<h2 id=\"架构师每天都在思考什么？\"><a href=\"#架构师每天都在思考什么？\" class=\"headerlink\" title=\"架构师每天都在思考什么？\"></a>架构师每天都在思考什么？</h2><ul>\n<li>应该如何让我的系统更快？</li>\n<li>如何避免系统出现瓶颈？</li>\n</ul>\n<p>知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？</p>\n<ul>\n<li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li>\n<li>根据业务场景和需求，决定技术方向，做技术选型</li>\n<li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li>\n<li>解决各类潜在系统风险，核心功能的架构与代码编写</li>\n<li>分析系统瓶颈，解决各种疑难杂症，性能调优等</li>\n</ul>\n<h2 id=\"为什么要学习JVM\"><a href=\"#为什么要学习JVM\" class=\"headerlink\" title=\"为什么要学习JVM\"></a>为什么要学习JVM</h2><ul>\n<li>面试的需要（BATJ、TMD，PKQ等面试都爱问）</li>\n<li>中高级程序员必备技能<ul>\n<li>项目管理、调优的需求</li>\n</ul>\n</li>\n<li>追求极客的精神<ul>\n<li>比如：垃圾回收算法、JIT（及时编译器）、底层原理</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java-vs-C\"><a href=\"#Java-vs-C\" class=\"headerlink\" title=\"Java vs C++\"></a>Java vs C++</h2><p>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/XHN1VXM61][~TA7ZFYXLKT8.png\"></p>\n<p>C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。</p>\n<h2 id=\"推荐书籍\"><a href=\"#推荐书籍\" class=\"headerlink\" title=\"推荐书籍\"></a>推荐书籍</h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/BO4JS0FIW7G%7BCY_OL2DW%7BRJ.png\"></p>\n<h2 id=\"Java生态圈\"><a href=\"#Java生态圈\" class=\"headerlink\" title=\"Java生态圈\"></a>Java生态圈</h2><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p>\n<ul>\n<li>作为一个平台，Java虚拟机扮演着举足轻重的作用<ul>\n<li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li>\n</ul>\n</li>\n<li>作为灯种文化，Java几乎成为了“开源”的代名词。<ul>\n<li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li>\n<li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li>\n</ul>\n</li>\n<li>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/0NG(~36CI53N9Q)]]BWF8Q7.png\"></p>\n<p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/sdf134.png\"></p>\n<p>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</p>\n<p>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>\n<h2 id=\"字节码\"><a href=\"#字节码\" class=\"headerlink\" title=\"字节码\"></a>字节码</h2><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</p>\n<p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>\n<p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p>\n<h2 id=\"多语言混合编程\"><a href=\"#多语言混合编程\" class=\"headerlink\" title=\"多语言混合编程\"></a>多语言混合编程</h2><p>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p>\n<p>试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</p>\n<p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</p>\n<h2 id=\"Java发展的重大事件\"><a href=\"#Java发展的重大事件\" class=\"headerlink\" title=\"Java发展的重大事件\"></a>Java发展的重大事件</h2><ul>\n<li><p>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java</p>\n</li>\n<li><p>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</p>\n</li>\n<li><p>1996年1月23日sun Microsystems发布了JDK 1.0。</p>\n</li>\n<li><p>1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</p>\n</li>\n<li><p>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</p>\n</li>\n<li><p>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</p>\n</li>\n<li><p>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</p>\n</li>\n<li><p>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</p>\n</li>\n<li><p>2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。</p>\n</li>\n<li><p>2007年，Java平台迎来了新伙伴Clojure。</p>\n</li>\n<li><p>2008年，oracle收购了BEA，得到了JRockit虚拟机。</p>\n</li>\n<li><p>2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。</p>\n</li>\n<li><p>2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit</p>\n</li>\n<li><p>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</p>\n</li>\n<li><p>2017年，JDK9发布。将G1设置为默认Gc，替代CMS</p>\n</li>\n<li><p>同年，IBM的J9开源，形成了现在的open J9社区</p>\n</li>\n<li><p>2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元</p>\n</li>\n<li><p>同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</p>\n</li>\n<li><p>同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可</p>\n</li>\n<li><p>2019年，JDK12发布，加入RedHat领导开发的shenandoah GC</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/6SG4O%60EF4NWLHJ[Z@C1]CPH.png\"></p>\n</li>\n</ul>\n<p>在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。</p>\n<h2 id=\"虚拟机与Java虚拟机\"><a href=\"#虚拟机与Java虚拟机\" class=\"headerlink\" title=\"虚拟机与Java虚拟机\"></a>虚拟机与Java虚拟机</h2><h3 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h3><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>\n<ul>\n<li>大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li>\n<li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li>\n</ul>\n<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>\n<h3 id=\"Java虚拟机\"><a href=\"#Java虚拟机\" class=\"headerlink\" title=\"Java虚拟机\"></a>Java虚拟机</h3><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p>\n<p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>\n<p>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</p>\n<p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>\n<p>特点：</p>\n<ul>\n<li>一次编译，到处运行</li>\n<li>自动内存管理</li>\n<li>自动垃圾回收功能</li>\n</ul>\n<h2 id=\"JVM的位置\"><a href=\"#JVM的位置\" class=\"headerlink\" title=\"JVM的位置\"></a>JVM的位置</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/%Z%60KY[BDR3YQN27D0K65.png\"></p>\n<p>Java的体系结构</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/VFT3UC%7DB]K.png\"></p>\n<h2 id=\"JVM整体结构\"><a href=\"#JVM整体结构\" class=\"headerlink\" title=\"JVM整体结构\"></a>JVM整体结构</h2><ul>\n<li><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</p>\n</li>\n<li><p>它采用解释器与即时编译器并存的架构。</p>\n</li>\n<li><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</p>\n</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/@1B_DX_~RTC3~%7B_CEDG8ON6.png\"></p>\n<p>执行引擎包含三部分：解释器，及时编译器，垃圾回收器</p>\n<h2 id=\"Java代码执行流程\"><a href=\"#Java代码执行流程\" class=\"headerlink\" title=\"Java代码执行流程\"></a>Java代码执行流程</h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/DJ72XD]@T~%60O~L1~XRJIPZ4.png\"></p>\n<p>只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了</p>\n<h2 id=\"JVM的架构模型\"><a href=\"#JVM的架构模型\" class=\"headerlink\" title=\"JVM的架构模型\"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p>\n<p>基于栈式架构的特点</p>\n<ul>\n<li>设计和实现更简单，适用于资源受限的系统；</li>\n<li>避开了寄存器的分配难题：使用零地址指令方式分配。</li>\n<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li>\n<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>\n</ul>\n<p>基于寄存器架构的特点</p>\n<ul>\n<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li>\n<li>指令集架构则完全依赖硬件，可移植性差</li>\n<li>性能优秀和执行更高效</li>\n<li>花费更少的指令去完成一项操作。</li>\n<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li>\n</ul>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p>\n<p>基于栈的计算流程（以Java虚拟机为例）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">iconst_2 <span class=\"comment\">//常量2入栈</span></span><br><span class=\"line\">istore_1</span><br><span class=\"line\">iconst_3 <span class=\"comment\">// 常量3入栈</span></span><br><span class=\"line\">istore_2</span><br><span class=\"line\">iload_1</span><br><span class=\"line\">iload_2</span><br><span class=\"line\">iadd <span class=\"comment\">//常量2/3出栈，执行相加</span></span><br><span class=\"line\">istore_0 <span class=\"comment\">// 结果5入栈</span></span><br></pre></td></tr></table></figure>\n\n<p>而基于寄存器的计算流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">mov eax,<span class=\"number\">2</span> <span class=\"comment\">//将eax寄存器的值设为1</span></span><br><span class=\"line\">add eax,<span class=\"number\">3</span> <span class=\"comment\">//使eax寄存器的值加3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字节码反编译\"><a href=\"#字节码反编译\" class=\"headerlink\" title=\"字节码反编译\"></a>字节码反编译</h3><p>我们编写一个简单的代码，然后查看一下字节码的反编译后的结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackStruTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> + <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们找到编译后的 class文件，使用下列命令进行反编译</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">javap -v StackStruTest.class</span><br></pre></td></tr></table></figure>\n\n<p>得到的文件为:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">   descriptor: ([Ljava/lang/String;)V</span><br><span class=\"line\">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class=\"line\">   Code:</span><br><span class=\"line\">     stack=<span class=\"number\">2</span>, locals=<span class=\"number\">4</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"number\">0</span>: iconst_2</span><br><span class=\"line\">        <span class=\"number\">1</span>: istore_1</span><br><span class=\"line\">        <span class=\"number\">2</span>: iconst_3</span><br><span class=\"line\">        <span class=\"number\">3</span>: istore_2</span><br><span class=\"line\">        <span class=\"number\">4</span>: iload_1</span><br><span class=\"line\">        <span class=\"number\">5</span>: iload_2</span><br><span class=\"line\">        <span class=\"number\">6</span>: iadd</span><br><span class=\"line\">        <span class=\"number\">7</span>: istore_3</span><br><span class=\"line\">        <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">     LineNumberTable:</span><br><span class=\"line\">       line <span class=\"number\">9</span>: <span class=\"number\">0</span></span><br><span class=\"line\">       line <span class=\"number\">10</span>: <span class=\"number\">2</span></span><br><span class=\"line\">       line <span class=\"number\">11</span>: <span class=\"number\">4</span></span><br><span class=\"line\">       line <span class=\"number\">12</span>: <span class=\"number\">8</span></span><br><span class=\"line\">     LocalVariableTable:</span><br><span class=\"line\">       Start  Length  Slot  Name   Signature</span><br><span class=\"line\">           <span class=\"number\">0</span>       <span class=\"number\">9</span>     <span class=\"number\">0</span>  args   [Ljava/lang/String;</span><br><span class=\"line\">           <span class=\"number\">2</span>       <span class=\"number\">7</span>     <span class=\"number\">1</span>     i   I</span><br><span class=\"line\">           <span class=\"number\">4</span>       <span class=\"number\">5</span>     <span class=\"number\">2</span>     j   I</span><br><span class=\"line\">           <span class=\"number\">8</span>       <span class=\"number\">1</span>     <span class=\"number\">3</span>     k   I</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>\n<p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><ul>\n<li>跨平台性</li>\n<li>指令集小</li>\n<li>指令多</li>\n<li>执行性能比寄存器差</li>\n</ul>\n<h2 id=\"JVM生命周期\"><a href=\"#JVM生命周期\" class=\"headerlink\" title=\"JVM生命周期\"></a>JVM生命周期</h2><h3 id=\"虚拟机的启动\"><a href=\"#虚拟机的启动\" class=\"headerlink\" title=\"虚拟机的启动\"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>\n<h3 id=\"虚拟机的执行\"><a href=\"#虚拟机的执行\" class=\"headerlink\" title=\"虚拟机的执行\"></a>虚拟机的执行</h3><ul>\n<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li>\n<li>程序开始执行时他才运行，程序结束时他就停止。</li>\n<li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li>\n</ul>\n<h3 id=\"虚拟机的退出\"><a href=\"#虚拟机的退出\" class=\"headerlink\" title=\"虚拟机的退出\"></a>虚拟机的退出</h3><p>有如下的几种情况：</p>\n<ul>\n<li>程序正常执行结束</li>\n<li>程序在执行过程中遇到了异常或错误而异常终止</li>\n<li>由于操作系统用现错误而导致Java虚拟机进程终止</li>\n<li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li>\n<li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li>\n</ul>\n<h2 id=\"JVM发展历程\"><a href=\"#JVM发展历程\" class=\"headerlink\" title=\"JVM发展历程\"></a>JVM发展历程</h2><h3 id=\"Sun-Classic-VM\"><a href=\"#Sun-Classic-VM\" class=\"headerlink\" title=\"Sun Classic VM\"></a>Sun Classic VM</h3><ul>\n<li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</li>\n<li>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li>\n<li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li>\n<li>现在hotspot内置了此虚拟机。</li>\n</ul>\n<h3 id=\"Exact-VM\"><a href=\"#Exact-VM\" class=\"headerlink\" title=\"Exact VM\"></a>Exact VM</h3><p>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。 Exact Memory Management：准确式内存管理</p>\n<ul>\n<li>也可以叫Non-Conservative/Accurate Memory Management</li>\n<li>虚拟机可以知道内存中某个位置的数据具体是什么类型。|</li>\n</ul>\n<p>具备现代高性能虚拟机的维形</p>\n<ul>\n<li>热点探测（寻找出热点代码进行缓存）</li>\n<li>编译器与解释器混合工作模式</li>\n</ul>\n<p>只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p>\n<h3 id=\"HotSpot-VM\"><a href=\"#HotSpot-VM\" class=\"headerlink\" title=\"HotSpot VM\"></a>HotSpot VM</h3><p>HotSpot历史</p>\n<ul>\n<li>最初由一家名为“Longview Technologies”的小公司设计</li>\n<li>1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。</li>\n<li>JDK1.3时，HotSpot VM成为默认虚拟机</li>\n</ul>\n<p>目前Hotspot占有绝对的市场地位，称霸武林。</p>\n<ul>\n<li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li>\n<li>Sun/oracle JDK和openJDK的默认虚拟机</li>\n<li>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念）</li>\n</ul>\n<p>从服务器、桌面到移动端、嵌入式都有应用。</p>\n<p>名称中的HotSpot指的就是它的热点代码探测技术。</p>\n<ul>\n<li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li>\n<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li>\n</ul>\n<h3 id=\"JRockit\"><a href=\"#JRockit\" class=\"headerlink\" title=\"JRockit\"></a>JRockit</h3><p>专注于服务器端应用</p>\n<ul>\n<li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li>\n</ul>\n<p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p>\n<ul>\n<li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li>\n</ul>\n<p>优势：全面的Java运行时解决方案组合</p>\n<ul>\n<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>\n<li>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li>\n</ul>\n<p>2008年，JRockit被oracle收购。</p>\n<p>oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p>\n<p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p>\n<h3 id=\"IBM的J9\"><a href=\"#IBM的J9\" class=\"headerlink\" title=\"IBM的J9\"></a>IBM的J9</h3><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p>\n<p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p>\n<p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</p>\n<p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9</p>\n<p>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</p>\n<h3 id=\"KVM和CDC-CLDC-Hotspot\"><a href=\"#KVM和CDC-CLDC-Hotspot\" class=\"headerlink\" title=\"KVM和CDC / CLDC Hotspot\"></a>KVM和CDC / CLDC Hotspot</h3><p>oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。</p>\n<p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p>\n<ul>\n<li>智能控制器、传感器</li>\n<li>老人手机、经济欠发达地区的功能手机</li>\n</ul>\n<p>所有的虚拟机的原则：一次编译，到处运行。</p>\n<h3 id=\"Azul-VM\"><a href=\"#Azul-VM\" class=\"headerlink\" title=\"Azul VM\"></a>Azul VM</h3><p>前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机I</p>\n<ul>\n<li>高性能Java虚拟机中的战斗机。</li>\n</ul>\n<p>Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。</p>\n<p>每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</p>\n<p>2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</p>\n<h3 id=\"Liquid-VM\"><a href=\"#Liquid-VM\" class=\"headerlink\" title=\"Liquid VM\"></a>Liquid VM</h3><p>高性能Java虚拟机中的战斗机。</p>\n<p>BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），</p>\n<p>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</p>\n<p>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</p>\n<h3 id=\"Apache-Marmony\"><a href=\"#Apache-Marmony\" class=\"headerlink\" title=\"Apache Marmony\"></a>Apache Marmony</h3><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p>\n<p>它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p>\n<p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p>\n<h3 id=\"Micorsoft-JVM\"><a href=\"#Micorsoft-JVM\" class=\"headerlink\" title=\"Micorsoft JVM\"></a>Micorsoft JVM</h3><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p>\n<p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p>\n<p>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p>\n<h3 id=\"Taobao-JVM\"><a href=\"#Taobao-JVM\" class=\"headerlink\" title=\"Taobao JVM\"></a>Taobao JVM</h3><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p>\n<p>基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</p>\n<p>基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p>\n<ul>\n<li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</li>\n<li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li>\n<li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li>\n<li>PMU hardware的Java profiling tool和诊断协助功能</li>\n<li>针对大数据场景的ZenGc</li>\n</ul>\n<p>taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</p>\n<p>目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。</p>\n<h3 id=\"Dalvik-VM\"><a href=\"#Dalvik-VM\" class=\"headerlink\" title=\"Dalvik VM\"></a>Dalvik VM</h3><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p>\n<p>Dalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范</p>\n<p>不能直接执行Java的Class文件</p>\n<p>基于寄存器架构，不是jvm的栈架构。</p>\n<p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p>\n<ul>\n<li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li>\n</ul>\n<p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</p>\n<h3 id=\"Graal-VM\"><a href=\"#Graal-VM\" class=\"headerlink\" title=\"Graal VM\"></a>Graal VM</h3><p>2018年4月，oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p>\n<p>GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p>\n<p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p>\n<p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>\n<p>如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。</p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第3章-运行时数据区概述及线程","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/","content":"<h1 id=\"运行时数据区概述及线程\"><a href=\"#运行时数据区概述及线程\" class=\"headerlink\" title=\"运行时数据区概述及线程\"></a>运行时数据区概述及线程</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>\n<p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/A@S7C1S]P6%7BA%7B8[8B9@2B2.png\"></p>\n<p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/%7D]H6TZ]1%7BT%60KGV[9R]4OJ]5.png\"></p>\n<p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/A]FYHY$79BN1CW9D4BGBQ_C.png\"></p>\n<h2 id=\"运行时数据区结构\"><a href=\"#运行时数据区结构\" class=\"headerlink\" title=\"运行时数据区结构\"></a>运行时数据区结构</h2><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>\n<blockquote>\n<p> 我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p>\n</blockquote>\n<p>运行时数据区的完整图</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/123457.png\"></p>\n<h2 id=\"线程的内存空间\"><a href=\"#线程的内存空间\" class=\"headerlink\" title=\"线程的内存空间\"></a>线程的内存空间</h2><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>\n<p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p>\n<ul>\n<li><p>每个线程：独立包括程序计数器、栈、本地栈。</p>\n</li>\n<li><p>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/asdasdasfd.png\"></p>\n</li>\n</ul>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p>\n<ul>\n<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>\n</ul>\n<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p>\n<h2 id=\"JVM系统线程\"><a href=\"#JVM系统线程\" class=\"headerlink\" title=\"JVM系统线程\"></a>JVM系统线程</h2><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。| 这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p>\n<ul>\n<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>\n<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>\n<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>\n<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>\n<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>\n</ul>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第4章-程序计数器","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/","content":"<h1 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/rhszxccsdg.png\"></p>\n<p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p>\n<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>\n<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p>\n<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>\n<p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/12easda.png\"></p>\n<h2 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><p>我们首先写一个简单的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PCRegisterTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = i + j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>: bipush        <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">2</span>: istore_1</span><br><span class=\"line\"><span class=\"number\">3</span>: bipush        <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"number\">5</span>: istore_2</span><br><span class=\"line\"><span class=\"number\">6</span>: iload_1</span><br><span class=\"line\"><span class=\"number\">7</span>: iload_2</span><br><span class=\"line\"><span class=\"number\">8</span>: iadd</span><br><span class=\"line\"><span class=\"number\">9</span>: istore_3</span><br><span class=\"line\"><span class=\"number\">10</span>: <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/dfzdfzdfzfzs.png\"></p>\n<h2 id=\"使用PC寄存器存储字节码指令地址有什么用呢？\"><a href=\"#使用PC寄存器存储字节码指令地址有什么用呢？\" class=\"headerlink\" title=\"使用PC寄存器存储字节码指令地址有什么用呢？\"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>\n<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/DN5W4MONE6.png\"></p>\n<h2 id=\"PC寄存器为什么被设定为私有的？\"><a href=\"#PC寄存器为什么被设定为私有的？\" class=\"headerlink\" title=\"PC寄存器为什么被设定为私有的？\"></a>PC寄存器为什么被设定为私有的？</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>\n<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>\n<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/N%7D@M%$%60TT9G7XXLHS%7DN]%7BQL.png\"></p>\n<h2 id=\"CPU时间片\"><a href=\"#CPU时间片\" class=\"headerlink\" title=\"CPU时间片\"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>\n<p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>\n<p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/M87S]0E52IM.png\"></p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第6章-本地方法接口","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC6%E7%AB%A0-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/","content":"<h1 id=\"本地方法接口\"><a href=\"#本地方法接口\" class=\"headerlink\" title=\"本地方法接口\"></a>本地方法接口</h1><h2 id=\"什么是本地方法\"><a href=\"#什么是本地方法\" class=\"headerlink\" title=\"什么是本地方法\"></a>什么是本地方法</h2><p>简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p>\n<p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p>\n<p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p>\n<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/JH7RZI3@79ZG_K%60P_D21%7D4X.png\"></p>\n<p>代码举例说明Native方法是如何编写的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IhaveNatives</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">Native1</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">native</span> <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">Native2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">native</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> <span class=\"title\">Native3</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">Natives</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ary)</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><em>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</em></p>\n</blockquote>\n<h2 id=\"为什么使用Native-Method？\"><a href=\"#为什么使用Native-Method？\" class=\"headerlink\" title=\"为什么使用Native Method？\"></a>为什么使用Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>\n<h3 id=\"与Java环境的交互\"><a href=\"#与Java环境的交互\" class=\"headerlink\" title=\"与Java环境的交互\"></a>与Java环境的交互</h3><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p>\n<h3 id=\"与操作系统的交互\"><a href=\"#与操作系统的交互\" class=\"headerlink\" title=\"与操作系统的交互\"></a>与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>\n<h3 id=\"Sun’s-Java\"><a href=\"#Sun’s-Java\" class=\"headerlink\" title=\"Sun’s Java\"></a>Sun’s Java</h3><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p>\n<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第5章-虚拟机栈","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC5%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/","content":"<h1 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h3 id=\"虚拟机栈的出现背景\"><a href=\"#虚拟机栈的出现背景\" class=\"headerlink\" title=\"虚拟机栈的出现背景\"></a>虚拟机栈的出现背景</h3><ol>\n<li> 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li>\n<li> 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li>\n</ol>\n<h3 id=\"内存中的栈与堆\"><a href=\"#内存中的栈与堆\" class=\"headerlink\" title=\"内存中的栈与堆\"></a>内存中的栈与堆</h3><ol>\n<li>首先栈是运行时的单位，而堆是存储的单位。</li>\n<li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li>\n</ol>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/IFF3AN8IDVE6SG]0F$@_TGB.png\"></p>\n<h3 id=\"虚拟机栈基本内容\"><a href=\"#虚拟机栈基本内容\" class=\"headerlink\" title=\"虚拟机栈基本内容\"></a>虚拟机栈基本内容</h3><ul>\n<li><p>Java虚拟机栈是什么？</p>\n<ul>\n<li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        StackTest test = <span class=\"keyword\">new</span> StackTest();</span><br><span class=\"line\">        test.methodA();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        methodB();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = <span class=\"number\">40</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/$OWFF3P~NWR[9DPUOU48.png\"></p>\n<ul>\n<li><p>虚拟机栈的生命周期</p>\n<ul>\n<li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li>\n</ul>\n</li>\n<li><p>虚拟机栈的作用</p>\n<ul>\n<li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li>\n<li>局部变量，它是相比于成员变量来说的（或属性）</li>\n<li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"虚拟机栈的特点\"><a href=\"#虚拟机栈的特点\" class=\"headerlink\" title=\"虚拟机栈的特点\"></a>虚拟机栈的特点</h3><ul>\n<li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>\n</li>\n<li><p>JVM直接对Java栈的操作只有两个：</p>\n<ul>\n<li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li>\n<li>执行结束后的<strong>出栈</strong>工作</li>\n</ul>\n</li>\n<li><p>对于栈来说不存在垃圾回收问题</p>\n<ul>\n<li>栈不需要GC，但是可能存在OOM</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/_W%7D85%7B8IO@DJOOY8J~S]0%7B7.png\"></p>\n<h3 id=\"虚拟机栈的异常\"><a href=\"#虚拟机栈的异常\" class=\"headerlink\" title=\"虚拟机栈的异常\"></a>虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p>\n<ul>\n<li><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p>\n<ul>\n<li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p>\n</li>\n<li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设置栈内存大小\"><a href=\"#设置栈内存大小\" class=\"headerlink\" title=\"设置栈内存大小\"></a>设置栈内存大小</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><blockquote>\n<p>多去官方文档看看：<a href=\"https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE\">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p>\n<p>地址经常变</p>\n</blockquote>\n<p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>\n<blockquote>\n<p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p>\n<ul>\n<li>Linux/x64 (64-bit): 1024 KB</li>\n<li>macOS (64-bit): 1024 KB</li>\n<li>Oracle Solaris/x64 (64-bit): 1024 KB</li>\n<li>Windows: The default value depends on virtual memory</li>\n</ul>\n</blockquote>\n<p>The following examples set the thread stack size to 1024 KB in different units:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xss1m</span><br><span class=\"line\">-Xss1024k</span><br><span class=\"line\">-Xss1048576</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackErrorTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        main(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>没设置参数前</strong></p>\n<p>部分输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11404</span></span><br><span class=\"line\"><span class=\"number\">11405</span></span><br><span class=\"line\"><span class=\"number\">11406</span></span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class=\"line\">\tat sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class=\"number\">691</span>)</span><br></pre></td></tr></table></figure>\n\n<p>说明栈在11406这个深度溢出了</p>\n<p><strong>设置栈参数之后</strong></p>\n<p>部分输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2474</span></span><br><span class=\"line\"><span class=\"number\">2475</span></span><br><span class=\"line\"><span class=\"number\">2476</span></span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class=\"line\">\tat sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class=\"number\">77</span>)</span><br></pre></td></tr></table></figure>\n\n<p>说明参数起作用了</p>\n<h2 id=\"栈的存储单位\"><a href=\"#栈的存储单位\" class=\"headerlink\" title=\"栈的存储单位\"></a>栈的存储单位</h2><h3 id=\"栈中存储什么？\"><a href=\"#栈中存储什么？\" class=\"headerlink\" title=\"栈中存储什么？\"></a>栈中存储什么？</h3><ol>\n<li> 每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li>\n<li> 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li>\n<li> 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>\n</ol>\n<h3 id=\"栈运行原理\"><a href=\"#栈运行原理\" class=\"headerlink\" title=\"栈运行原理\"></a>栈运行原理</h3><ol>\n<li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p>\n</li>\n<li><p> 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></p>\n</li>\n<li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>\n</li>\n<li><p> 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>\n</li>\n</ol>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/asdasfasf.png\"></p>\n<ol>\n<li> <strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>\n<li> 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li>\n<li>Java方法有两种返回函数的方式。<ul>\n<li>一种是正常的函数返回，使用return指令。</li>\n<li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li>\n<li>但不管使用哪种方式，都会导致栈帧被弹出。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"栈帧的内部结构\"><a href=\"#栈帧的内部结构\" class=\"headerlink\" title=\"栈帧的内部结构\"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p>\n<ul>\n<li><p>局部变量表（Local Variables）</p>\n</li>\n<li><p>操作数栈（Operand Stack）（或表达式栈）</p>\n</li>\n<li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p>\n</li>\n<li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p>\n</li>\n<li><p>一些附加信息</p>\n</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/Y@8A%SVOK[0I9S$7NECAU0.png\"></p>\n<p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/asdasdasd.png\"></p>\n<h2 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h2><h3 id=\"认识局部变量表\"><a href=\"#认识局部变量表\" class=\"headerlink\" title=\"认识局部变量表\"></a>认识局部变量表</h3><h4 id=\"概念-1\"><a href=\"#概念-1\" class=\"headerlink\" title=\"概念\"></a>概念</h4><ol>\n<li> 局部变量表也被称之为局部变量数组或本地变量表</li>\n<li> <strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li>\n<li> 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li>\n<li> <strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>\n<li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul>\n<li>  对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li>\n<li>  进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>\n</ul>\n</li>\n<li>局部变量表中的变量只在当前方法调用中有效。<ul>\n<li>  在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li>\n<li>  当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"举例-1\"><a href=\"#举例-1\" class=\"headerlink\" title=\"举例\"></a>举例</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalVariablesTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LocalVariablesTest test = <span class=\"keyword\">new</span> LocalVariablesTest();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\">        test.test1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//练习：</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testStatic</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        LocalVariablesTest test = <span class=\"keyword\">new</span> LocalVariablesTest();</span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\">        <span class=\"comment\">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(this.count);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//关于Slot的使用的理解</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LocalVariablesTest</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        String name1 = <span class=\"string\">&quot;atguigu.com&quot;</span>;</span><br><span class=\"line\">        test2(date, name1);</span><br><span class=\"line\">        System.out.println(date + name1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test2</span><span class=\"params\">(Date dateP, String name2)</span> </span>&#123;</span><br><span class=\"line\">        dateP = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        name2 = <span class=\"string\">&quot;songhongkang&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> weight = <span class=\"number\">130.5</span>;<span class=\"comment\">//占据两个slot</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> gender = <span class=\"string\">&#x27;男&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dateP + name2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">            b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p>\n<h3 id=\"关于Slot的理解\"><a href=\"#关于Slot的理解\" class=\"headerlink\" title=\"关于Slot的理解\"></a>关于Slot的理解</h3><ol>\n<li> 参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li>\n<li> 局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li>\n<li>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）。<ul>\n<li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li>\n<li>long和double则占据两个slot</li>\n</ul>\n</li>\n<li> JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>\n<li> 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li>\n<li> 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li>\n<li> 如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li>\n</ol>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/fesdghgfgf.png\"></p>\n<h3 id=\"Slot代码示例\"><a href=\"#Slot代码示例\" class=\"headerlink\" title=\"Slot代码示例\"></a>Slot代码示例</h3><p><strong>this 存放在 index = 0 的位置：</strong></p>\n<p>代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.count++;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>局部变量表：this 存放在 index = 0 的位置</p>\n<p><strong>64位的类型（1ong和double）占用两个slot</strong></p>\n<p>代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test2</span><span class=\"params\">(Date dateP, String name2)</span> </span>&#123;</span><br><span class=\"line\">      dateP = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      name2 = <span class=\"string\">&quot;songhongkang&quot;</span>;</span><br><span class=\"line\">      <span class=\"keyword\">double</span> weight = <span class=\"number\">130.5</span>;<span class=\"comment\">//占据两个slot</span></span><br><span class=\"line\">      <span class=\"keyword\">char</span> gender = <span class=\"string\">&#x27;男&#x27;</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dateP + name2;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>weight 为 double 类型，index 直接从 3 蹦到了 5</p>\n<p><strong>static 无法调用 this</strong></p>\n<p>this 不存在与 static 方法的局部变量表中，所以无法调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testStatic</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        LocalVariablesTest test = <span class=\"keyword\">new</span> LocalVariablesTest();</span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">        System.out.println(count);</span><br><span class=\"line\">        <span class=\"comment\">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(this.count);</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Slot的重复利用\"><a href=\"#Slot的重复利用\" class=\"headerlink\" title=\"Slot的重复利用\"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>\n<p>代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">        b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>局部变量 c 重用了局部变量 b 的 slot 位置</p>\n<h3 id=\"静态变量与局部变量的对比\"><a href=\"#静态变量与局部变量的对比\" class=\"headerlink\" title=\"静态变量与局部变量的对比\"></a>静态变量与局部变量的对比</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">变量的分类：</span><br><span class=\"line\"><span class=\"number\">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class=\"line\"><span class=\"number\">2</span>、按照在类中声明的位置分：</span><br><span class=\"line\">  <span class=\"number\">2</span>-<span class=\"number\">1</span>、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class=\"line\">       <span class=\"number\">2</span>-<span class=\"number\">1</span>-<span class=\"number\">1</span>、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class=\"line\">              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class=\"line\">       <span class=\"number\">2</span>-<span class=\"number\">1</span>-<span class=\"number\">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class=\"line\">  <span class=\"number\">2</span>-<span class=\"number\">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li> 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li>\n<li> 我们知道成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li>\n<li> 和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>\n</ol>\n<h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><ol>\n<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>\n<li> 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li>\n</ol>\n<h2 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h2><h3 id=\"概念-2\"><a href=\"#概念-2\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>操作数栈：Operand Stack</p>\n<p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p>\n<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p>\n<ul>\n<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>\n<li>比如：执行复制、交换、求和等操作</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/7U3C7.png\"></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/7WF8_23N0F.png\"></p>\n<h3 id=\"操作数栈的作用\"><a href=\"#操作数栈的作用\" class=\"headerlink\" title=\"操作数栈的作用\"></a>操作数栈的作用</h3><ol>\n<li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li>\n<li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</li>\n<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li>\n<li>栈中的任何一个元素都是可以任意的Java数据类型<ul>\n<li>  32bit的类型占用一个栈单位深度</li>\n<li>  64bit的类型占用两个栈单位深度</li>\n</ul>\n</li>\n<li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></li>\n<li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li>\n<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li>\n<li> 另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li>\n</ol>\n<p>局部变量表就相当于食材</p>\n<p>操作数栈就相当于做法步骤</p>\n<h2 id=\"操作数栈代码追踪\"><a href=\"#操作数栈代码追踪\" class=\"headerlink\" title=\"操作数栈代码追踪\"></a>操作数栈代码追踪</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testAddOperation</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//byte、short、char、boolean：都以int型来保存</span></span><br><span class=\"line\">       <span class=\"keyword\">byte</span> i = <span class=\"number\">15</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> j = <span class=\"number\">8</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> k = i + j;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// int m = 800;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用javap 命令反编译class文件： javap -v 类名.class</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">0</span> bipush <span class=\"number\">15</span></span><br><span class=\"line\"> <span class=\"number\">2</span> istore_1</span><br><span class=\"line\"> <span class=\"number\">3</span> bipush <span class=\"number\">8</span></span><br><span class=\"line\"> <span class=\"number\">5</span> istore_2</span><br><span class=\"line\"> <span class=\"number\">6</span> iload_1</span><br><span class=\"line\"> <span class=\"number\">7</span> iload_2</span><br><span class=\"line\"> <span class=\"number\">8</span> iadd</span><br><span class=\"line\"> <span class=\"number\">9</span> istore_3</span><br><span class=\"line\"><span class=\"number\">10</span> <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>byte、short、char、boolean 内部都是使用int型来进行保存的</p>\n<p>从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和 8进行入栈操作</p>\n<p>同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作</p>\n</blockquote>\n<p>执行流程如下所示：</p>\n<p>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入栈。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/MNDMPFJ%60TCO0A03@MVK]I]O.png\"></p>\n<p>执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/M%7B_7A7SBYP.png\"></p>\n<blockquote>\n<p>为什么局部变量表不是从0开始的呢？</p>\n<p>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~</p>\n</blockquote>\n<p>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/VX5@PA%7D06%600@6[TR4LBG@SB.png\"></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/123aasdasd.png\"></p>\n<p>然后从局部变量表中，依次将数据放在操作数栈中</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/2HXR1MBX5LS0KA.png\"></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/ZU68T1N3_%]_S%7B62XKICGML.png\"></p>\n<p>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/123123123123.png\"></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/76543.png\"></p>\n<p>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</p>\n<p>i++和++i的区别</p>\n<h2 id=\"栈顶缓存技术\"><a href=\"#栈顶缓存技术\" class=\"headerlink\" title=\"栈顶缓存技术\"></a>栈顶缓存技术</h2><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p>\n<ol>\n<li> 前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要</li>\n<li> 多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。</li>\n<li> 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></li>\n<li> 寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li>\n</ol>\n<h2 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h2><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p>\n<ol>\n<li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li>\n<li> 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicLinkingTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;methodA()....&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;methodB()....&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        methodA();</span><br><span class=\"line\"></span><br><span class=\"line\">        num++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对应字节码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.class</span><br><span class=\"line\">  Last modified <span class=\"number\">2020</span>-<span class=\"number\">11</span>-<span class=\"number\">10</span>; size <span class=\"number\">712</span> bytes</span><br><span class=\"line\">  MD5 checksum e56913c945f897c7ee6c0a608629bca8</span><br><span class=\"line\">  Compiled from <span class=\"string\">&quot;DynamicLinkingTest.java&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">atguigu</span>.<span class=\"title\">java1</span>.<span class=\"title\">DynamicLinkingTest</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">minor</span> <span class=\"title\">version</span>: 0</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">major</span> <span class=\"title\">version</span>: 52</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">flags</span>: <span class=\"title\">ACC_PUBLIC</span>, <span class=\"title\">ACC_SUPER</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Constant</span> <span class=\"title\">pool</span>:</span></span><br><span class=\"line\"><span class=\"class\">   #1 </span>= Methodref          #<span class=\"number\">9.</span>#<span class=\"number\">23</span>         <span class=\"comment\">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">   #<span class=\"number\">2</span> = Fieldref           #<span class=\"number\">8.</span>#<span class=\"number\">24</span>         <span class=\"comment\">// com/atguigu/java1/DynamicLinkingTest.num:I</span></span><br><span class=\"line\">   #<span class=\"number\">3</span> = Fieldref           #<span class=\"number\">25.</span>#<span class=\"number\">26</span>        <span class=\"comment\">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">   #<span class=\"number\">4</span> = String             #<span class=\"number\">27</span>            <span class=\"comment\">// methodA()....</span></span><br><span class=\"line\">   #<span class=\"number\">5</span> = Methodref          #<span class=\"number\">28.</span>#<span class=\"number\">29</span>        <span class=\"comment\">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">   #<span class=\"number\">6</span> = String             #<span class=\"number\">30</span>            <span class=\"comment\">// methodB()....</span></span><br><span class=\"line\">   #<span class=\"number\">7</span> = Methodref          #<span class=\"number\">8.</span>#<span class=\"number\">31</span>         <span class=\"comment\">// com/atguigu/java1/DynamicLinkingTest.methodA:()V</span></span><br><span class=\"line\">   #<span class=\"number\">8</span> = Class              #<span class=\"number\">32</span>            <span class=\"comment\">// com/atguigu/java1/DynamicLinkingTest</span></span><br><span class=\"line\">   #<span class=\"number\">9</span> = Class              #<span class=\"number\">33</span>            <span class=\"comment\">// java/lang/Object</span></span><br><span class=\"line\">  #<span class=\"number\">10</span> = Utf8               num</span><br><span class=\"line\">  #<span class=\"number\">11</span> = Utf8               I</span><br><span class=\"line\">  #<span class=\"number\">12</span> = Utf8               &lt;init&gt;</span><br><span class=\"line\">  #<span class=\"number\">13</span> = Utf8               ()V</span><br><span class=\"line\">  #<span class=\"number\">14</span> = Utf8               Code</span><br><span class=\"line\">  #<span class=\"number\">15</span> = Utf8               LineNumberTable</span><br><span class=\"line\">  #<span class=\"number\">16</span> = Utf8               LocalVariableTable</span><br><span class=\"line\">  #<span class=\"number\">17</span> = Utf8               <span class=\"keyword\">this</span></span><br><span class=\"line\">  #<span class=\"number\">18</span> = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class=\"line\">  #<span class=\"number\">19</span> = Utf8               methodA</span><br><span class=\"line\">  #<span class=\"number\">20</span> = Utf8               methodB</span><br><span class=\"line\">  #<span class=\"number\">21</span> = Utf8               SourceFile</span><br><span class=\"line\">  #<span class=\"number\">22</span> = Utf8               DynamicLinkingTest.java</span><br><span class=\"line\">  #<span class=\"number\">23</span> = NameAndType        #<span class=\"number\">12</span>:#<span class=\"number\">13</span>        <span class=\"comment\">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">  #<span class=\"number\">24</span> = NameAndType        #<span class=\"number\">10</span>:#<span class=\"number\">11</span>        <span class=\"comment\">// num:I</span></span><br><span class=\"line\">  #<span class=\"number\">25</span> = Class              #<span class=\"number\">34</span>            <span class=\"comment\">// java/lang/System</span></span><br><span class=\"line\">  #<span class=\"number\">26</span> = NameAndType        #<span class=\"number\">35</span>:#<span class=\"number\">36</span>        <span class=\"comment\">// out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">  #<span class=\"number\">27</span> = <span class=\"function\">Utf8               <span class=\"title\">methodA</span><span class=\"params\">()</span>....</span></span><br><span class=\"line\"><span class=\"function\">  #28 </span>= Class              #<span class=\"number\">37</span>            <span class=\"comment\">// java/io/PrintStream</span></span><br><span class=\"line\">  #<span class=\"number\">29</span> = NameAndType        #<span class=\"number\">38</span>:#<span class=\"number\">39</span>        <span class=\"comment\">// println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">  #<span class=\"number\">30</span> = <span class=\"function\">Utf8               <span class=\"title\">methodB</span><span class=\"params\">()</span>....</span></span><br><span class=\"line\"><span class=\"function\">  #31 </span>= NameAndType        #<span class=\"number\">19</span>:#<span class=\"number\">13</span>        <span class=\"comment\">// methodA:()V</span></span><br><span class=\"line\">  #<span class=\"number\">32</span> = Utf8               com/atguigu/java1/DynamicLinkingTest</span><br><span class=\"line\">  #<span class=\"number\">33</span> = Utf8               java/lang/Object</span><br><span class=\"line\">  #<span class=\"number\">34</span> = Utf8               java/lang/System</span><br><span class=\"line\">  #<span class=\"number\">35</span> = Utf8               out</span><br><span class=\"line\">  #<span class=\"number\">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class=\"line\">  #<span class=\"number\">37</span> = Utf8               java/io/PrintStream</span><br><span class=\"line\">  #<span class=\"number\">38</span> = Utf8               println</span><br><span class=\"line\">  #<span class=\"number\">39</span> = Utf8               (Ljava/lang/String;)V</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    descriptor: I</span><br><span class=\"line\">    flags:</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> com.atguigu.java1.DynamicLinkingTest();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">         <span class=\"number\">4</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">5</span>: bipush        <span class=\"number\">10</span></span><br><span class=\"line\">         <span class=\"number\">7</span>: putfield      #<span class=\"number\">2</span>                  <span class=\"comment\">// Field num:I</span></span><br><span class=\"line\">        <span class=\"number\">10</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">7</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">9</span>: <span class=\"number\">4</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>      <span class=\"number\">11</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">3</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">4</span>                  <span class=\"comment\">// String methodA()....</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">5</span>                  <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">12</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">13</span>: <span class=\"number\">8</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">9</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodB</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">3</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">3</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">6</span>                  <span class=\"comment\">// String methodB()....</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">5</span>                  <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">9</span>: invokevirtual #<span class=\"number\">7</span>                  <span class=\"comment\">// Method methodA:()V</span></span><br><span class=\"line\">        <span class=\"number\">12</span>: aload_0</span><br><span class=\"line\">        <span class=\"number\">13</span>: dup</span><br><span class=\"line\">        <span class=\"number\">14</span>: getfield      #<span class=\"number\">2</span>                  <span class=\"comment\">// Field num:I</span></span><br><span class=\"line\">        <span class=\"number\">17</span>: iconst_1</span><br><span class=\"line\">        <span class=\"number\">18</span>: iadd</span><br><span class=\"line\">        <span class=\"number\">19</span>: putfield      #<span class=\"number\">2</span>                  <span class=\"comment\">// Field num:I</span></span><br><span class=\"line\">        <span class=\"number\">22</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">16</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">18</span>: <span class=\"number\">8</span></span><br><span class=\"line\">        line <span class=\"number\">20</span>: <span class=\"number\">12</span></span><br><span class=\"line\">        line <span class=\"number\">21</span>: <span class=\"number\">22</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>      <span class=\"number\">23</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SourceFile: <span class=\"string\">&quot;DynamicLinkingTest.java&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p>\n<p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p>\n<ul>\n<li>先找 #8 ：<ul>\n<li>  <code>#8 = Class #32</code> ：去找 #32</li>\n<li>  <code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li>\n<li>  结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li>\n</ul>\n</li>\n<li>再来找 #31：<ul>\n<li>  <code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li>\n<li>  <code>#19 = Utf8 methodA</code> ：方法名为 methodA</li>\n<li>  <code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li>\n</ul>\n</li>\n</ul>\n<p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p>\n<p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p>\n<p><strong>为什么要用常量池呢？</strong></p>\n<ol>\n<li>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</li>\n<li> 常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li>\n</ol>\n<h2 id=\"方法的调用\"><a href=\"#方法的调用\" class=\"headerlink\" title=\"方法的调用\"></a>方法的调用</h2><h3 id=\"静态链接与动态链接\"><a href=\"#静态链接与动态链接\" class=\"headerlink\" title=\"静态链接与动态链接\"></a>静态链接与动态链接</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>\n<ul>\n<li><strong>静态链接</strong>：</li>\n</ul>\n<p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p>\n<ul>\n<li><strong>动态链接</strong>：</li>\n</ul>\n<p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>\n<h3 id=\"早期绑定与晚期绑定\"><a href=\"#早期绑定与晚期绑定\" class=\"headerlink\" title=\"早期绑定与晚期绑定\"></a>早期绑定与晚期绑定</h3><blockquote>\n<p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p>\n</blockquote>\n<p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p>\n<ul>\n<li><strong>早期绑定</strong></li>\n</ul>\n<p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p>\n<ul>\n<li><strong>晚期绑定</strong></li>\n</ul>\n<p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;动物进食&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Huntable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hunt</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> <span class=\"keyword\">implements</span> <span class=\"title\">Huntable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;狗吃骨头&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hunt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;捕食耗子，多管闲事&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> <span class=\"keyword\">implements</span> <span class=\"title\">Huntable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();<span class=\"comment\">//表现为：早期绑定</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cat</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>();<span class=\"comment\">//表现为：早期绑定</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.eat();<span class=\"comment\">//表现为：早期绑定</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;猫吃鱼&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hunt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;捕食耗子，天经地义&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnimalTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showAnimal</span><span class=\"params\">(Animal animal)</span> </span>&#123;</span><br><span class=\"line\">        animal.eat();<span class=\"comment\">//表现为：晚期绑定</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showHunt</span><span class=\"params\">(Huntable h)</span> </span>&#123;</span><br><span class=\"line\">        h.hunt();<span class=\"comment\">//表现为：晚期绑定</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>部分字节码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> com.atguigu.java2.AnimalTest();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">54</span>: <span class=\"number\">0</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">5</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showAnimal</span><span class=\"params\">(com.atguigu.java2.Animal)</span></span>;</span><br><span class=\"line\">    descriptor: (Lcom/atguigu/java2/Animal;)V</span><br><span class=\"line\">    flags: ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">2</span>, args_size=<span class=\"number\">2</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_1</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokevirtual #<span class=\"number\">2</span>                  <span class=\"comment\">// Method com/atguigu/java2/Animal.eat:()V</span></span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">56</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">57</span>: <span class=\"number\">4</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">5</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">5</span>     <span class=\"number\">1</span> animal   Lcom/atguigu/java2/Animal;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showHunt</span><span class=\"params\">(com.atguigu.java2.Huntable)</span></span>;</span><br><span class=\"line\">    descriptor: (Lcom/atguigu/java2/Huntable;)V</span><br><span class=\"line\">    flags: ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">2</span>, args_size=<span class=\"number\">2</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_1</span><br><span class=\"line\">         <span class=\"number\">1</span>: invokeinterface #<span class=\"number\">3</span>,  <span class=\"number\">1</span>            <span class=\"comment\">// InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span></span><br><span class=\"line\">         <span class=\"number\">6</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">60</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">61</span>: <span class=\"number\">6</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">7</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">7</span>     <span class=\"number\">1</span>     h   Lcom/atguigu/java2/Huntable;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SourceFile: <span class=\"string\">&quot;AnimalTest.java&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>invokevirtual 体现为晚期绑定</p>\n<p>invokeinterface 也体现为晚期绑定</p>\n<p>invokespecial 体现为早期绑定</p>\n<h3 id=\"多态与绑定\"><a href=\"#多态与绑定\" class=\"headerlink\" title=\"多态与绑定\"></a>多态与绑定</h3><ol>\n<li>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</li>\n<li> Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li>\n</ol>\n<h4 id=\"虚方法与非虚方法\"><a href=\"#虚方法与非虚方法\" class=\"headerlink\" title=\"虚方法与非虚方法\"></a>虚方法与非虚方法</h4><p><strong>虚方法与非虚方法的区别</strong></p>\n<ol>\n<li> 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>\n<li> 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li>\n<li> 其他方法称为虚方法。</li>\n</ol>\n<p><strong>子类对象的多态的使用前提：</strong></p>\n<ol>\n<li> 类的继承关系</li>\n<li> 方法的重写</li>\n</ol>\n<p><strong>虚拟机中调用方法的指令</strong></p>\n<ul>\n<li><strong>普通指令：</strong></li>\n</ul>\n<ol>\n<li> invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>\n<li> invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li>\n<li> invokevirtual：调用所有虚方法</li>\n<li> invokeinterface：调用接口方法</li>\n</ol>\n<ul>\n<li><strong>动态调用指令</strong></li>\n</ul>\n<p>invokedynamic：动态解析出需要调用的方法，然后执行</p>\n<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p>\n<h4 id=\"关于-invokedynamic-指令\"><a href=\"#关于-invokedynamic-指令\" class=\"headerlink\" title=\"关于 invokedynamic 指令\"></a>关于 invokedynamic 指令</h4><ol>\n<li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</li>\n<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li>\n<li> Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Func</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">func</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lambda</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lambda</span><span class=\"params\">(Func func)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Lambda lambda = <span class=\"keyword\">new</span> Lambda();</span><br><span class=\"line\"></span><br><span class=\"line\">        Func func = s -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        lambda.lambda(func);</span><br><span class=\"line\"></span><br><span class=\"line\">        lambda.lambda(s -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"动态语言和静态语言\"><a href=\"#动态语言和静态语言\" class=\"headerlink\" title=\"动态语言和静态语言\"></a>动态语言和静态语言</h3><ol>\n<li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</li>\n<li> 说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li>\n</ol>\n<p>Java：String info = “mogu blog”;             (Java是静态类型语言的，会先编译就进行类型检查)<br>    JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p>\n<pre><code>Python: info = 130.5 (运行时才检查)\n</code></pre>\n<h3 id=\"Java语言中方法重写的本质\"><a href=\"#Java语言中方法重写的本质\" class=\"headerlink\" title=\"Java语言中方法重写的本质\"></a>Java语言中方法重写的本质</h3><ol>\n<li> 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>\n<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul>\n<li>  如果通过则返回这个方法的直接引用，查找过程结束</li>\n<li>  如果不通过，则返回java.lang.IllegalAccessError 异常</li>\n</ul>\n</li>\n<li> 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>\n<li> 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>\n</ol>\n<blockquote>\n<p>上面这个过程称为<strong>动态分派</strong></p>\n</blockquote>\n<p><strong>IllegalAccessError介绍</strong></p>\n<ol>\n<li> 程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li>\n<li> 比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li>\n</ol>\n<h3 id=\"虚方法表\"><a href=\"#虚方法表\" class=\"headerlink\" title=\"虚方法表\"></a>虚方法表</h3><ol>\n<li>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</li>\n<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li>\n<li>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</li>\n</ol>\n<p><strong>例子1</strong></p>\n<p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/874MZW[0HA.png\"></p>\n<p>1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p>\n<p>2、下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p>\n<h2 id=\"方法返回地址\"><a href=\"#方法返回地址\" class=\"headerlink\" title=\"方法返回地址\"></a>方法返回地址</h2><blockquote>\n<p>在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区</p>\n</blockquote>\n<ol>\n<li>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：<ul>\n<li>  正常执行完成</li>\n<li>  出现未处理的异常，非正常退出</li>\n</ul>\n</li>\n<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li>\n<li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li>\n<li> 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li>\n</ol>\n<p><strong>方法退出的两种方式</strong></p>\n<p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p>\n<p><strong>正常退出：</strong></p>\n<ol>\n<li><p> 执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</p>\n</li>\n<li><p> 一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</p>\n</li>\n<li><p>在字节码指令中，返回指令包含：</p>\n<ul>\n<li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p>\n</li>\n<li><p>lreturn：Long类型</p>\n</li>\n<li><p>freturn：Float类型</p>\n</li>\n<li><p>dreturn：Double类型</p>\n</li>\n<li><p>areturn：引用类型</p>\n</li>\n<li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>异常退出：</strong></p>\n<ol>\n<li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</li>\n<li> 方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li>\n</ol>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/_X5JZHM2RN7%60HKC4S%60684BF.png\"></p>\n<p>异常处理表：</p>\n<ul>\n<li>  反编译字节码文件，可得到 Exception table</li>\n<li>  from ：字节码指令起始地址</li>\n<li>  to ：字节码指令结束地址</li>\n<li>  target ：出现异常跳转至地址为 11 的指令执行</li>\n<li>  type ：捕获异常的类型</li>\n</ul>\n<h2 id=\"一些附加信息\"><a href=\"#一些附加信息\" class=\"headerlink\" title=\"一些附加信息\"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>\n<h2 id=\"栈相关面试题\"><a href=\"#栈相关面试题\" class=\"headerlink\" title=\"栈相关面试题\"></a>栈相关面试题</h2><h3 id=\"举例栈溢出的情况？\"><a href=\"#举例栈溢出的情况？\" class=\"headerlink\" title=\"举例栈溢出的情况？\"></a>举例栈溢出的情况？</h3><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p>\n<h3 id=\"调整栈大小，就能保证不出现溢出么？\"><a href=\"#调整栈大小，就能保证不出现溢出么？\" class=\"headerlink\" title=\"调整栈大小，就能保证不出现溢出么？\"></a>调整栈大小，就能保证不出现溢出么？</h3><p>不能保证不溢出，只能保证SOF出现的几率小</p>\n<h3 id=\"分配的栈内存越大越好么？\"><a href=\"#分配的栈内存越大越好么？\" class=\"headerlink\" title=\"分配的栈内存越大越好么？\"></a>分配的栈内存越大越好么？</h3><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p>\n<h3 id=\"垃圾回收是否涉及到虚拟机栈？\"><a href=\"#垃圾回收是否涉及到虚拟机栈？\" class=\"headerlink\" title=\"垃圾回收是否涉及到虚拟机栈？\"></a>垃圾回收是否涉及到虚拟机栈？</h3><p>不会</p>\n<table>\n<thead>\n<tr>\n<th>位置</th>\n<th>是否有Error</th>\n<th>是否存在GC</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PC计数器</td>\n<td>无</td>\n<td>不存在</td>\n</tr>\n<tr>\n<td>虚拟机栈</td>\n<td>有，SOF</td>\n<td>不存在</td>\n</tr>\n<tr>\n<td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>堆</td>\n<td>有，OOM</td>\n<td>存在</td>\n</tr>\n<tr>\n<td>方法区</td>\n<td>有</td>\n<td>存在</td>\n</tr>\n</tbody></table>\n<h3 id=\"方法中定义的局部变量是否线程安全？\"><a href=\"#方法中定义的局部变量是否线程安全？\" class=\"headerlink\" title=\"方法中定义的局部变量是否线程安全？\"></a>方法中定义的局部变量是否线程安全？</h3><p>具体问题具体分析</p>\n<ol>\n<li> 如果只有一个线程才可以操作此数据，则必是线程安全的。</li>\n<li> 如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li>\n</ol>\n<p><strong>具体问题具体分析：</strong></p>\n<ul>\n<li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 面试题：</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *   何为线程安全？</span></span><br><span class=\"line\"><span class=\"comment\"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class=\"line\"><span class=\"comment\"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringBuilderTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//s1的声明方式是线程安全的（只在方法内部用了）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//StringBuilder:线程不安全</span></span><br><span class=\"line\">        StringBuilder s1 = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        s1.append(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        s1.append(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">(StringBuilder sBuilder)</span></span>&#123;</span><br><span class=\"line\">        sBuilder.append(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        sBuilder.append(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> StringBuilder <span class=\"title\">method3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        StringBuilder s1 = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        s1.append(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        s1.append(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//s1的操作：是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">method4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        StringBuilder s1 = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        s1.append(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        s1.append(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder s = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            s.append(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">            s.append(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        method2(s);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第7章-本地方法栈","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC7%E7%AB%A0-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/","content":"<h1 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h1><p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p>\n<p>本地方法栈，也是线程私有的。</p>\n<p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>\n<ul>\n<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li>\n<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li>\n</ul>\n<p>本地方法是使用C语言实现的。</p>\n<p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/asdasdasdasd44.png\"></p>\n<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p>\n<ul>\n<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li>\n<li>它甚至可以直接使用本地处理器中的寄存器</li>\n<li>直接从本地内存的堆中分配任意数量的内存。</li>\n</ul>\n<p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p>\n<p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第8章-堆","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC8%E7%AB%A0-%E5%A0%86/","content":"<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><h2 id=\"堆的核心概念\"><a href=\"#堆的核心概念\" class=\"headerlink\" title=\"堆的核心概念\"></a>堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/70%7DWFU5U%60_M3TRX.png\"></p>\n<p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>\n<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p>\n<ul>\n<li>堆内存的大小是可以调节的。</li>\n</ul>\n<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>\n<p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>\n<blockquote>\n<p>-Xms10m：最小堆内存</p>\n<p>-Xmx10m：最大堆内存</p>\n</blockquote>\n<p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/B09SW4E_XK.png\"></p>\n<p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>\n<p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p>\n<ul>\n<li>因为还有一些对象是在栈上分配的</li>\n</ul>\n<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>\n<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>\n<ul>\n<li>也就是触发了GC的时候，才会进行回收</li>\n<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>\n</ul>\n<p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/VQ~53U57XD.png\"></p>\n<h3 id=\"堆内存细分\"><a href=\"#堆内存细分\" class=\"headerlink\" title=\"堆内存细分\"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p>\n<ul>\n<li>Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区</li>\n<li>Tenure generation space 养老区 Old/Tenure</li>\n<li>Permanent Space永久区 Perm</li>\n</ul>\n<p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p>\n<ul>\n<li>Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区</li>\n<li>Tenure generation space 养老区 Old/Tenure</li>\n<li>Meta Space 元空间 Meta</li>\n</ul>\n<p>约定：新生区 -&gt; 新生代 -&gt; 年轻代 、 养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/4P%7B4[~3~X1_ZAOC.png\"></p>\n<p>堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/0HQ~GTPP3PT9~D%60I7C4P.png\"></p>\n<h2 id=\"设置堆内存大小与OOM\"><a href=\"#设置堆内存大小与OOM\" class=\"headerlink\" title=\"设置堆内存大小与OOM\"></a>设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>\n<ul>\n<li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li>\n<li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>\n</ul>\n<p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p>\n<p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p>\n<p>默认情况下</p>\n<ul>\n<li>初始内存大小：物理电脑内存大小/64</li>\n<li>最大内存大小：物理电脑内存大小/4</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeapSpaceInitial</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回Java虚拟机中的堆内存总量</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class=\"number\">1024</span> / <span class=\"number\">1024</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 返回Java虚拟机试图使用的最大堆内存</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class=\"number\">1024</span> / <span class=\"number\">1024</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;-Xms:&quot;</span> + initialMemory + <span class=\"string\">&quot;M&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;-Xmx:&quot;</span> + maxMemory + <span class=\"string\">&quot;M&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xms:245M</span><br><span class=\"line\">-Xmx:3614M</span><br></pre></td></tr></table></figure>\n\n<p>如何查看堆内存的内存分配情况</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">jps  -&gt;  staat -gc  进程id</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/[APFR5D4MU5E.png\"></p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/9IE7FR2QRS7ZQS.png\"></p>\n<h3 id=\"OutOfMemory举例\"><a href=\"#OutOfMemory举例\" class=\"headerlink\" title=\"OutOfMemory举例\"></a>OutOfMemory举例</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/D6872XU035CXMIH9W7.png\"></p>\n<p><img src=\"http://image.moguit.cn/0a025c4881d34fb2bfa65851211d7145\" alt=\"image-20200706210000461\"></p>\n<p>我们简单的写一个OOM例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OOMTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            list.add(<span class=\"number\">999999999</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后设置启动参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xms10m -Xmx:10m</span><br></pre></td></tr></table></figure>\n\n<p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/CT6GIU$%7BXW33J0QBC~AVYY3.png\"></p>\n<h2 id=\"年轻代与老年代\"><a href=\"#年轻代与老年代\" class=\"headerlink\" title=\"年轻代与老年代\"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p>\n<ul>\n<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul>\n<li>生命周期短的，及时回收即可</li>\n</ul>\n</li>\n<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>\n</ul>\n<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>\n<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/S03B]W3YW_%60N%7BG4Q5DK.png\"></p>\n<p>下面这参数开发中一般不会调：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/H45345454WD5X.png\"></p>\n<ul>\n<li>Eden：From：to -&gt; 8:1:1</li>\n<li>新生代：老年代 - &gt; 1 : 2</li>\n</ul>\n<p>配置新生代与老年代在堆结构的占比。</p>\n<ul>\n<li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li>\n<li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li>\n</ul>\n<blockquote>\n<p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p>\n</blockquote>\n<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p>\n<p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p>\n<blockquote>\n<p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>\n<p>可以使用选项”-Xmn”设置新生代最大内存大小</p>\n<p>这个参数一般使用默认值就可以了。</p>\n</blockquote>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/YL6O5CQ8TD3CXPLH.png\"></p>\n<h2 id=\"图解对象分配过程\"><a href=\"#图解对象分配过程\" class=\"headerlink\" title=\"图解对象分配过程\"></a>图解对象分配过程</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>\n<ul>\n<li>new的对象先放伊甸园区。此区有大小限制。</li>\n<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>\n<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>\n<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>\n<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>\n<li>啥时候能去养老区呢？可以设置次数。默认是15次。</li>\n<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>\n<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>\n</ul>\n<p>可以设置参数：-Xx:MaxTenuringThreshold= N进行设置</p>\n<h3 id=\"图解过程\"><a href=\"#图解过程\" class=\"headerlink\" title=\"图解过程\"></a>图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/9IGLK32MM$5T%60IZ[RMTPBC2.png\"></p>\n<p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p>\n<p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/07YMS[9585VO41P41JQ.png\"></p>\n<p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/8~TEZ]9VVXPEYUX01SR[YJ.png\"></p>\n<h3 id=\"思考：幸存区区满了后？\"><a href=\"#思考：幸存区区满了后？\" class=\"headerlink\" title=\"思考：幸存区区满了后？\"></a>思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p>\n<p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p>\n<blockquote>\n<p>举例：以当兵为例，正常人的晋升可能是 ： 新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p>\n<p>但是也有可能有些人因为做了非常大的贡献，直接从 新兵 -&gt; 排长</p>\n</blockquote>\n<h3 id=\"对象分配的特殊情况\"><a href=\"#对象分配的特殊情况\" class=\"headerlink\" title=\"对象分配的特殊情况\"></a>对象分配的特殊情况</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/PHQJ2D7OHZUQ9GAO%7DZ0LD.png\"></p>\n<h3 id=\"代码演示对象分配过程\"><a href=\"#代码演示对象分配过程\" class=\"headerlink\" title=\"代码演示对象分配过程\"></a>代码演示对象分配过程</h3><p>我们不断的创建大对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeapInstanceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">byte</span> [] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">1024</span> * <span class=\"number\">200</span>)];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ArrayList&lt;HeapInstanceTest&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            list.add(<span class=\"keyword\">new</span> HeapInstanceTest());</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后设置JVM参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xms600m -Xmx600m</span><br></pre></td></tr></table></figure>\n\n<p>然后cmd输入下面命令，打开VisualVM图形化界面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jvisualvm</span><br></pre></td></tr></table></figure>\n\n<p>然后通过执行上面代码，通过VisualGC进行动态化查看</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/0WM~NVCU6P0ZT2J2DYZJ.png\"></p>\n<p>最终，在老年代和新生代都满了，就出现OOM</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat com.atguigu.java.chapter08.HeapInstanceTest.&lt;<span class=\"keyword\">init</span>&gt;(HeapInstanceTest.java:<span class=\"number\">13</span>)</span><br><span class=\"line\">\tat com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:<span class=\"number\">17</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用的调优工具\"><a href=\"#常用的调优工具\" class=\"headerlink\" title=\"常用的调优工具\"></a>常用的调优工具</h3><ul>\n<li>JDK命令行</li>\n<li>Eclipse：Memory Analyzer Tool</li>\n<li>Jconsole</li>\n<li>Visual VM（实时监控 推荐~）</li>\n<li>Jprofiler（推荐~）</li>\n<li>Java Flight Recorder（实时监控）</li>\n<li>GCViewer</li>\n<li>GCEasy</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li>\n<li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li>\n<li>新生代采用复制算法的目的：是为了减少内碎片</li>\n</ul>\n<h2 id=\"Minor-GC，MajorGC、Full-GC\"><a href=\"#Minor-GC，MajorGC、Full-GC\" class=\"headerlink\" title=\"Minor GC，MajorGC、Full GC\"></a>Minor GC，MajorGC、Full GC</h2><ul>\n<li>Minor GC：新生代的GC</li>\n<li>Major GC：老年代的GC</li>\n<li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li>\n</ul>\n<blockquote>\n<p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p>\n<p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p>\n</blockquote>\n<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>\n<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>\n<ul>\n<li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li>\n<li>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。<ul>\n<li>目前，只有CMSGC会有单独收集老年代的行为。</li>\n<li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>\n</ul>\n</li>\n<li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul>\n<li>目前，只有G1 GC会有这种行为</li>\n</ul>\n</li>\n</ul>\n<p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p>\n<h3 id=\"Minor-GC\"><a href=\"#Minor-GC\" class=\"headerlink\" title=\"Minor GC\"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p>\n<p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>\n<p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p>\n<blockquote>\n<p>STW：stop the word</p>\n</blockquote>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/Z9EHG7E2aaaaaJ3SJS.png\"></p>\n<h3 id=\"Major-GC\"><a href=\"#Major-GC\" class=\"headerlink\" title=\"Major GC\"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p>\n<p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>\n<ul>\n<li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li>\n</ul>\n<p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p>\n<h3 id=\"Full-GC\"><a href=\"#Full-GC\" class=\"headerlink\" title=\"Full GC\"></a>Full GC</h3><p>触发Fu11GC执行的情况有如下五种：</p>\n<ul>\n<li>调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ul>\n<p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p>\n<h3 id=\"GC-举例\"><a href=\"#GC-举例\" class=\"headerlink\" title=\"GC 举例\"></a>GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GCTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            String a = <span class=\"string\">&quot;mogu blog&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                list.add(a);</span><br><span class=\"line\">                a = a + a;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.getStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设置JVM启动参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>\n\n<p>打印出的日志</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: <span class=\"number\">2038</span>K-&gt;<span class=\"number\">500</span>K(<span class=\"number\">2560</span>K)] <span class=\"number\">2038</span>K-&gt;<span class=\"number\">797</span>K(<span class=\"number\">9728</span>K), <span class=\"number\">0.3532002</span> secs] [Times: user=<span class=\"number\">0.01</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.36</span> secs] </span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: <span class=\"number\">2108</span>K-&gt;<span class=\"number\">480</span>K(<span class=\"number\">2560</span>K)] <span class=\"number\">2405</span>K-&gt;<span class=\"number\">1565</span>K(<span class=\"number\">9728</span>K), <span class=\"number\">0.0014069</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: <span class=\"number\">2288</span>K-&gt;<span class=\"number\">0</span>K(<span class=\"number\">2560</span>K)] [ParOldGen: <span class=\"number\">6845</span>K-&gt;<span class=\"number\">5281</span>K(<span class=\"number\">7168</span>K)] <span class=\"number\">9133</span>K-&gt;<span class=\"number\">5281</span>K(<span class=\"number\">9728</span>K), [Metaspace: <span class=\"number\">3482</span>K-&gt;<span class=\"number\">3482</span>K(<span class=\"number\">1056768</span>K)], <span class=\"number\">0.0058675</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: <span class=\"number\">0</span>K-&gt;<span class=\"number\">0</span>K(<span class=\"number\">2560</span>K)] <span class=\"number\">5281</span>K-&gt;<span class=\"number\">5281</span>K(<span class=\"number\">9728</span>K), <span class=\"number\">0.0002857</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">[Full GC (Allocation Failure) [PSYoungGen: <span class=\"number\">0</span>K-&gt;<span class=\"number\">0</span>K(<span class=\"number\">2560</span>K)] [ParOldGen: <span class=\"number\">5281</span>K-&gt;<span class=\"number\">5263</span>K(<span class=\"number\">7168</span>K)] <span class=\"number\">5281</span>K-&gt;<span class=\"number\">5263</span>K(<span class=\"number\">9728</span>K), [Metaspace: <span class=\"number\">3482</span>K-&gt;<span class=\"number\">3482</span>K(<span class=\"number\">1056768</span>K)], <span class=\"number\">0.0058564</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.01</span> secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> PSYoungGen      total <span class=\"number\">2560</span>K, used <span class=\"number\">60</span>K [<span class=\"number\">0x00000000ffd00000</span>, <span class=\"number\">0x0000000100000000</span>, <span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\">  eden space <span class=\"number\">2048</span>K, <span class=\"number\">2</span>% used [<span class=\"number\">0x00000000ffd00000</span>,<span class=\"number\">0x00000000ffd0f138</span>,<span class=\"number\">0x00000000fff00000</span>)</span><br><span class=\"line\">  from space <span class=\"number\">512</span>K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000fff00000</span>,<span class=\"number\">0x00000000fff00000</span>,<span class=\"number\">0x00000000fff80000</span>)</span><br><span class=\"line\">  to   space <span class=\"number\">512</span>K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000000fff80000</span>,<span class=\"number\">0x00000000fff80000</span>,<span class=\"number\">0x0000000100000000</span>)</span><br><span class=\"line\"> ParOldGen       total <span class=\"number\">7168</span>K, used <span class=\"number\">5263</span>K [<span class=\"number\">0x00000000ff600000</span>, <span class=\"number\">0x00000000ffd00000</span>, <span class=\"number\">0x00000000ffd00000</span>)</span><br><span class=\"line\">  object space <span class=\"number\">7168</span>K, <span class=\"number\">73</span>% used [<span class=\"number\">0x00000000ff600000</span>,<span class=\"number\">0x00000000ffb23cf0</span>,<span class=\"number\">0x00000000ffd00000</span>)</span><br><span class=\"line\"> Metaspace       used <span class=\"number\">3514</span>K, capacity <span class=\"number\">4498</span>K, committed <span class=\"number\">4864</span>K, reserved <span class=\"number\">1056768</span>K</span><br><span class=\"line\">  class space    used <span class=\"number\">388</span>K, capacity <span class=\"number\">390</span>K, committed <span class=\"number\">512</span>K, reserved <span class=\"number\">1048576</span>K</span><br><span class=\"line\">  </span><br><span class=\"line\">  Exception <span class=\"keyword\">in</span> thread <span class=\"string\">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat java.util.Arrays.copyOfRange(Arrays.java:<span class=\"number\">3664</span>)</span><br><span class=\"line\">\tat java.lang.<span class=\"built_in\">String</span>.&lt;init&gt;(<span class=\"built_in\">String</span>.java:<span class=\"number\">207</span>)</span><br><span class=\"line\">\tat java.lang.StringBuilder.toString(StringBuilder.java:<span class=\"number\">407</span>)</span><br><span class=\"line\">\tat com.atguigu.java.chapter08.GCTest.main(GCTest.java:<span class=\"number\">20</span>)</span><br></pre></td></tr></table></figure>\n\n<p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p>\n<h2 id=\"堆空间分代思想\"><a href=\"#堆空间分代思想\" class=\"headerlink\" title=\"堆空间分代思想\"></a>堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>\n<blockquote>\n<p>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。 老年代：存放新生代中经历多次GC仍然存活的对象。</p>\n</blockquote>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/TI869RBKT4VC94V785Y.png\"></p>\n<p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/3MB18_A%7BJYFRM08Y_XYQB.png\"></p>\n<h2 id=\"内存分配策略\"><a href=\"#内存分配策略\" class=\"headerlink\" title=\"内存分配策略\"></a>内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p>\n<p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p>\n<p>针对不同年龄段的对象分配原则如下所示：</p>\n<ul>\n<li>优先分配到Eden<ul>\n<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>\n</ul>\n</li>\n<li>大对象直接分配到老年代<ul>\n<li>尽量避免程序中出现过多的大对象</li>\n</ul>\n</li>\n<li>长期存活的对象分配到老年代</li>\n<li>动态对象年龄判断<ul>\n<li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li>\n</ul>\n</li>\n</ul>\n<p>空间分配担保： -Xx:HandlePromotionFailure</p>\n<ul>\n<li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li>\n</ul>\n<h2 id=\"为对象分配内存：TLAB\"><a href=\"#为对象分配内存：TLAB\" class=\"headerlink\" title=\"为对象分配内存：TLAB\"></a>为对象分配内存：TLAB</h2><h3 id=\"问题：堆空间都是共享的么？\"><a href=\"#问题：堆空间都是共享的么？\" class=\"headerlink\" title=\"问题：堆空间都是共享的么？\"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p>\n<h3 id=\"为什么有TLAB？\"><a href=\"#为什么有TLAB？\" class=\"headerlink\" title=\"为什么有TLAB？\"></a>为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p>\n<p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>\n<p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>\n<p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>\n<h3 id=\"什么是TLAB\"><a href=\"#什么是TLAB\" class=\"headerlink\" title=\"什么是TLAB\"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>\n<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p>\n<p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/UF]UDK710GIE]W[%60%60$_JL.png\"></p>\n<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p>\n<p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p>\n<p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p>\n<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>\n<h3 id=\"TLAB分配过程\"><a href=\"#TLAB分配过程\" class=\"headerlink\" title=\"TLAB分配过程\"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/2TU4MOEYKBO%600NI.png\"></p>\n<h2 id=\"小结：堆空间的参数设置\"><a href=\"#小结：堆空间的参数设置\" class=\"headerlink\" title=\"小结：堆空间的参数设置\"></a>小结：堆空间的参数设置</h2><ul>\n<li>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</li>\n<li>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</li>\n<li>-Xms：初始堆空间内存（默认为物理内存的1/64）</li>\n<li>-Xmx：最大堆空间内存（默认为物理内存的1/4）</li>\n<li>-Xmn：设置新生代的大小。（初始值及最大值）</li>\n<li>-XX:NewRatio：配置新生代与老年代在堆结构的占比</li>\n<li>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</li>\n<li>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</li>\n<li>-XX：+PrintGCDetails：输出详细的GC处理日志<ul>\n<li>打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</li>\n</ul>\n</li>\n<li>-XX:HandlePromotionFalilure：是否设置空间分配担保</li>\n</ul>\n<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p>\n<ul>\n<li>如果大于，则此次Minor GC是安全的</li>\n<li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul>\n<li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li>\n<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>\n<li>如果小于，则改为进行一次FullGC。</li>\n<li>如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。</li>\n</ul>\n</li>\n</ul>\n<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p>\n<h2 id=\"堆是分配对象的唯一选择么？\"><a href=\"#堆是分配对象的唯一选择么？\" class=\"headerlink\" title=\"堆是分配对象的唯一选择么？\"></a>堆是分配对象的唯一选择么？</h2><h3 id=\"逃逸分析\"><a href=\"#逃逸分析\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>\n<p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>\n<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>\n<p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>\n<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>\n<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p>\n<ul>\n<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>\n<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>\n</ul>\n<h4 id=\"逃逸分析举例\"><a href=\"#逃逸分析举例\" class=\"headerlink\" title=\"逃逸分析举例\"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">my_method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    V v = <span class=\"keyword\">new</span> V();</span><br><span class=\"line\">    <span class=\"comment\">// use v</span></span><br><span class=\"line\">    <span class=\"comment\">// ....</span></span><br><span class=\"line\">    v = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>针对下面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> StringBuffer <span class=\"title\">createStringBuffer</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">    StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果想要StringBuffer sb不发生逃逸，可以这样写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">createStringBuffer</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">    StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整的逃逸分析代码举例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EscapeAnalysis</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> EscapeAnalysis obj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EscapeAnalysis <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj == <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> EscapeAnalysis():obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 为成员属性赋值，发生逃逸</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObj</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.obj = <span class=\"keyword\">new</span> EscapeAnalysis();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">useEscapeAnalysis</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        EscapeAnalysis e = <span class=\"keyword\">new</span> EscapeAnalysis();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 引用成员变量的值，发生逃逸</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">useEscapeAnalysis2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        EscapeAnalysis e = getInstance();</span><br><span class=\"line\">        <span class=\"comment\">// getInstance().XXX  发生逃逸</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>\n<p>如果使用的是较早的版本，开发人员则可以通过：</p>\n<ul>\n<li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li>\n<li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>\n</ul>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p>\n<p>使用逃逸分析，编译器可以对代码做如下优化：</p>\n<ul>\n<li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>\n<li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>\n<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>\n</ul>\n<h3 id=\"栈上分配\"><a href=\"#栈上分配\" class=\"headerlink\" title=\"栈上分配\"></a>栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>\n<p>常见的栈上分配的场景</p>\n<blockquote>\n<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p>\n</blockquote>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String age;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String gender;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String phone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackAllocation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000000</span>; i++) &#123;</span><br><span class=\"line\">            alloc();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;花费的时间为：&quot;</span> + (end - start) + <span class=\"string\">&quot; ms&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">10000000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">alloc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设置JVM参数，表示未开启逃逸分析</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br></pre></td></tr></table></figure>\n\n<p>运行结果，同时还触发了GC操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">花费的时间为：664 ms</span><br></pre></td></tr></table></figure>\n\n<p>然后查看内存的情况，发现有大量的User存储在堆中</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/7PKI1XQDMFVCL~GK4C5.png\"></p>\n<p>我们在开启逃逸分析</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br></pre></td></tr></table></figure>\n\n<p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">花费的时间为：5 ms</span><br></pre></td></tr></table></figure>\n\n<p>然后在看内存情况，我们发现只有很少的User对象，说明User发生了逃逸，因为他们存储在栈中，随着栈的销毁而消失</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/MR6IB%5_1SAJ9.png\"></p>\n<h3 id=\"同步省略\"><a href=\"#同步省略\" class=\"headerlink\" title=\"同步省略\"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>\n<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>\n<p>例如下面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Object hellis = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(hellis) &#123;</span><br><span class=\"line\">        System.out.println(hellis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Object hellis = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">\tSystem.out.println(hellis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们将其转换成字节码</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/9XNRHSUHRMXMIW6.png\"></p>\n<h3 id=\"分离对象和标量替换\"><a href=\"#分离对象和标量替换\" class=\"headerlink\" title=\"分离对象和标量替换\"></a>分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>\n<p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>\n<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过J工T优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">    alloc();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">alloc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Point point = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;point.x&quot;</span> + point.x + <span class=\"string\">&quot;;point.y&quot;</span> + point.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码，经过标量替换后，就会变成</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">alloc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y = <span class=\"number\">2</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;point.x = &quot;</span> + x + <span class=\"string\">&quot;; point.y=&quot;</span> + y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。</p>\n<h3 id=\"代码优化之标量替换\"><a href=\"#代码优化之标量替换\" class=\"headerlink\" title=\"代码优化之标量替换\"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure>\n\n<p>这里设置参数如下：</p>\n<ul>\n<li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li>\n<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>\n<li>参数-Xmx10m：指定了堆空间最大为10MB</li>\n<li>参数-XX:+PrintGC：将打印Gc日志。</li>\n<li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>\n</ul>\n<h3 id=\"逃逸分析的不足\"><a href=\"#逃逸分析的不足\" class=\"headerlink\" title=\"逃逸分析的不足\"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>\n<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>\n<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>\n<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>\n<p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p>\n<p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第9章-方法区","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC9%E7%AB%A0-%E6%96%B9%E6%B3%95%E5%8C%BA/","content":"<h1 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这次所讲述的是运行时数据区的最后一个部分</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/5O[7ZY~ZNLI0YURNU[$N.png\"></p>\n<p>从线程共享与否的角度来看</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/DF[27DXTA0L63[XQM8D.png\"></p>\n<p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p>\n<h2 id=\"栈、堆、方法区的交互关系\"><a href=\"#栈、堆、方法区的交互关系\" class=\"headerlink\" title=\"栈、堆、方法区的交互关系\"></a>栈、堆、方法区的交互关系</h2><p>下面就涉及了对象的访问定位</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/J80UWFNU_G[~BR3Q_NY.png\"></p>\n<ul>\n<li>Person：存放在元空间，也可以说方法区</li>\n<li>person：存放在Java栈的局部变量表中</li>\n<li>new Person()：存放在Java堆中</li>\n</ul>\n<h2 id=\"方法区的理解\"><a href=\"#方法区的理解\" class=\"headerlink\" title=\"方法区的理解\"></a>方法区的理解</h2><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p>\n<p>所以，方法区看作是一块独立于Java堆的内存空间。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/97CFZM7%7DIQ7AFI2$Y71XC4B.png\"></p>\n<p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p>\n<ul>\n<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li>\n<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>\n<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>\n<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul>\n<li>加载大量的第三方的jar包</li>\n<li>Tomcat部署的工程过多（30~50个）</li>\n<li>大量动态的生成反射类</li>\n</ul>\n</li>\n<li>关闭JVM就会释放这个区域的内存。</li>\n</ul>\n<h3 id=\"HotSpot中方法区的演进\"><a href=\"#HotSpot中方法区的演进\" class=\"headerlink\" title=\"HotSpot中方法区的演进\"></a>HotSpot中方法区的演进</h3><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p>\n<ul>\n<li>JDK 1.8后，元空间存放在堆外内存中</li>\n</ul>\n<p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。</p>\n<blockquote>\n<p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</p>\n</blockquote>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/D_O_HPQXLH%RRFR9.png\"></p>\n<p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/RHE$JZCLZ%60JL_XRU.png\"></p>\n<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p>\n<p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p>\n<p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p>\n<h2 id=\"设置方法区大小与OOM\"><a href=\"#设置方法区大小与OOM\" class=\"headerlink\" title=\"设置方法区大小与OOM\"></a>设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>\n<h3 id=\"jdk7及以前\"><a href=\"#jdk7及以前\" class=\"headerlink\" title=\"jdk7及以前\"></a>jdk7及以前</h3><ul>\n<li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li>\n<li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li>\n<li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/0JAQX4P]CO47HD9E.png\"></p>\n<h3 id=\"JDK8以后\"><a href=\"#JDK8以后\" class=\"headerlink\" title=\"JDK8以后\"></a>JDK8以后</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p>\n<p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p>\n<p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p>\n<p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>\n<p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p>\n<h3 id=\"如何解决这些OOM\"><a href=\"#如何解决这些OOM\" class=\"headerlink\" title=\"如何解决这些OOM\"></a>如何解决这些OOM</h3><ul>\n<li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）<ul>\n<li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li>\n</ul>\n</li>\n<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>\n<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>\n</ul>\n<h2 id=\"方法区的内部结构\"><a href=\"#方法区的内部结构\" class=\"headerlink\" title=\"方法区的内部结构\"></a>方法区的内部结构</h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/JL6W8SUJZPU0%60%7D%60TJ%%M.png\"></p>\n<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/OQQ[48FU9[V@NOA55.png\"></p>\n<h3 id=\"类型信息\"><a href=\"#类型信息\" class=\"headerlink\" title=\"类型信息\"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p>\n<ul>\n<li>这个类型的完整有效名称（全名=包名.类名）</li>\n<li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li>\n<li>这个类型的修饰符（public，abstract，final的某个子集）</li>\n<li>这个类型直接接口的一个有序列表</li>\n</ul>\n<h3 id=\"域信息\"><a href=\"#域信息\" class=\"headerlink\" title=\"域信息\"></a>域信息</h3><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>\n<p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p>\n<h3 id=\"方法（Method）信息\"><a href=\"#方法（Method）信息\" class=\"headerlink\" title=\"方法（Method）信息\"></a>方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>\n<ul>\n<li>方法名称</li>\n<li>方法的返回类型（或void）</li>\n<li>方法参数的数量和类型（按顺序）</li>\n<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>\n<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>\n<li>异常表（abstract和native方法除外）</li>\n</ul>\n<blockquote>\n<p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p>\n</blockquote>\n<h3 id=\"non-final的类变量\"><a href=\"#non-final的类变量\" class=\"headerlink\" title=\"non-final的类变量\"></a>non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>\n<p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodAreaTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Order order = <span class=\"keyword\">new</span> Order();</span><br><span class=\"line\">        order.hello();</span><br><span class=\"line\">        System.out.println(order.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> number = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p>\n<h3 id=\"全局常量\"><a href=\"#全局常量\" class=\"headerlink\" title=\"全局常量\"></a>全局常量</h3><p>全局常量就是使用 static final 进行修饰</p>\n<p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p>\n<h3 id=\"运行时常量池-VS-常量池\"><a href=\"#运行时常量池-VS-常量池\" class=\"headerlink\" title=\"运行时常量池 VS 常量池\"></a>运行时常量池 VS 常量池</h3><p>运行时常量池，就是运行时常量池</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/QHYC6_R%60[I154~O4.png\"></p>\n<ul>\n<li>方法区，内部包含了运行时常量池</li>\n<li>字节码文件，内部包含了常量池</li>\n<li>要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。</li>\n<li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li>\n</ul>\n<h3 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/]LJHSPOGO4ORHQT%60AN%60%60W6.png\"></p>\n<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p>\n<h4 id=\"为什么需要常量池\"><a href=\"#为什么需要常量池\" class=\"headerlink\" title=\"为什么需要常量池\"></a>为什么需要常量池</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。</p>\n<p>比如：如下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p>\n<h4 id=\"常量池中有什么\"><a href=\"#常量池中有什么\" class=\"headerlink\" title=\"常量池中有什么\"></a>常量池中有什么</h4><ul>\n<li>数量值</li>\n<li>字符串值</li>\n<li>类引用</li>\n<li>字段引用</li>\n<li>方法引用</li>\n</ul>\n<p>例如下面这段代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodAreaTest2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将会被翻译成如下字节码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">new <span class=\"comment\">#2  </span></span><br><span class=\"line\">dup</span><br><span class=\"line\">invokespecial</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p>\n<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>\n<p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>\n<p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>\n<p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p>\n<p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p>\n<p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</p>\n<p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p>\n<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p>\n<h2 id=\"方法区使用举例\"><a href=\"#方法区使用举例\" class=\"headerlink\" title=\"方法区使用举例\"></a>方法区使用举例</h2><p>如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodAreaDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = <span class=\"number\">500</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = x / y;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">50</span>;</span><br><span class=\"line\">        System.out.println(a+b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>字节码执行过程展示</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/3rsrer234r22t452.png\"></p>\n<p>首先现将操作数500放入到操作数栈中</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/6BZYO_GL[2NYI]RPD7NH.png\"></p>\n<p>然后存储到局部变量表中</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/N5OD537VG6Y6H.png\"></p>\n<p>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/234rtgfdserf.png\"></p>\n<p>将500 和 100 进行一个除法运算，在把结果入栈</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/4BTURZGGYLQGPQCWOU~M14P.png\"></p>\n<p>在最后就是输出流，需要调用运行时常量池的常量</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/3790U[%7D5CJ.png\"></p>\n<p>最后调用invokevirtual（虚方法调用），然后返回</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/QV7QQLD[@0]0C%7D9.png\"></p>\n<p>返回时</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/88455115151651465.png\"></p>\n<p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p>\n<h2 id=\"方法区的演进细节\"><a href=\"#方法区的演进细节\" class=\"headerlink\" title=\"方法区的演进细节\"></a>方法区的演进细节</h2><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p>\n<p>Hotspot中方法区的变化：</p>\n<p>| JDK1.6及以前 | 有永久代，静态变量存储在永久代上 | | ———— | ———————————————————— | | JDK1.7 | 有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中 | | JDK1.8 | 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。 |</p>\n<p>JDK6的时候</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/IS_590SBV~36K76%7D7PQVPC.png\"></p>\n<p>JDK7的时候</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/N1A%7BJPDQT3DGSD[6XS.png\"></p>\n<p>JDK8的时候，元空间大小只受物理内存影响</p>\n<h3 id=\"为什么永久代要被元空间替代？\"><a href=\"#为什么永久代要被元空间替代？\" class=\"headerlink\" title=\"为什么永久代要被元空间替代？\"></a>为什么永久代要被元空间替代？</h3><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p>\n<p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p>\n<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p>\n<ul>\n<li>为永久代设置空间大小是很难确定的。</li>\n</ul>\n<p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>\n<p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p>\n<p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p>\n<ul>\n<li>对永久代进行调优是很困难的。<ul>\n<li>主要是为了降低Full GC</li>\n</ul>\n</li>\n</ul>\n<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p>\n<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p>\n<h3 id=\"StringTable为什么要调整位置\"><a href=\"#StringTable为什么要调整位置\" class=\"headerlink\" title=\"StringTable为什么要调整位置\"></a>StringTable为什么要调整位置</h3><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而ful1gc是老年代的空间不足、永久代不足时才会触发。</p>\n<p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>\n<h3 id=\"静态变量存放在那里？\"><a href=\"#静态变量存放在那里？\" class=\"headerlink\" title=\"静态变量存放在那里？\"></a>静态变量存放在那里？</h3><p>静态引用对应的对象实体始终都存在堆空间</p>\n<p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p>\n<p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/awweaa23.png\"></p>\n<p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p>\n<p>接着，找到了一个引用该staticobj对象的地方，是在一个java.1ang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/T23O3O99HIGNO8OEE.png\"></p>\n<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点</p>\n<h2 id=\"方法区的垃圾回收\"><a href=\"#方法区的垃圾回收\" class=\"headerlink\" title=\"方法区的垃圾回收\"></a>方法区的垃圾回收</h2><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p>\n<p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>\n<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>\n<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>\n<ul>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符</li>\n</ul>\n<p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>\n<p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p>\n<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li>\n<li>该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li>\n<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/K]TDX%60CSMAKVNFF0V3L.png\"></p>\n<h3 id=\"常见面试题\"><a href=\"#常见面试题\" class=\"headerlink\" title=\"常见面试题\"></a>常见面试题</h3><p>百度 三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p>\n<p>蚂蚁金服： Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？ 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？ 二面：Eden和survior的比例分配</p>\n<p>小米： jvm内存分区，为什么要有新生代和老年代</p>\n<p>字节跳动： 二面：Java的内存分区 二面：讲讲vm运行时数据库区 什么时候对象会进入老年代？</p>\n<p>京东： JVM的内存结构，Eden和Survivor比例。 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p>\n<p>天猫： 一面：Jvm内存模型以及分区，需要详细到每个区放什么。 一面：JVM的内存模型，Java8做了什么改</p>\n<p>拼多多： JVM内存分哪几个区，每个区的作用是什么？</p>\n<p>美团： java内存分配 jvm的永久代中会发生垃圾回收吗？ 一面：jvm内存分区，为什么要有新生代和老年代？</p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第11章-直接内存","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC11%E7%AB%A0-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/","content":"<h1 id=\"直接内存-Direct-Memory\"><a href=\"#直接内存-Direct-Memory\" class=\"headerlink\" title=\"直接内存 Direct Memory\"></a>直接内存 Direct Memory</h1><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p>\n<p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p>\n<p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p>\n<p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p>\n<ul>\n<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li>\n<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li>\n</ul>\n<p>使用下列代码，直接分配本地内存空间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> BUFFER = <span class=\"number\">1024</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>; <span class=\"comment\">// 1GB</span></span><br><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"非直接缓存区和缓存区\"><a href=\"#非直接缓存区和缓存区\" class=\"headerlink\" title=\"非直接缓存区和缓存区\"></a>非直接缓存区和缓存区</h2><p>原来采用BIO的架构，我们需要从用户态切换成内核态</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/F%60BIGT9TCQI4X~FB2Y.png\"></p>\n<p>NIO的方式使用了缓存区的概念</p>\n<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><p>也可能导致outofMemoryError异常</p>\n<p>由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。 缺点</p>\n<ul>\n<li>分配回收成本较高</li>\n<li>不受JVM内存回收管理</li>\n</ul>\n<p>直接内存大小可以通过MaxDirectMemorySize设置</p>\n<p>如果不指定，默认与堆的最大值-xmx参数值一致</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/7ESAKZ%7B%60Z%7DPHF.png\"></p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第10章-对象实例化及访问定位","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC10%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/","content":"<h1 id=\"对象实例化内存布局与访问定位\"><a href=\"#对象实例化内存布局与访问定位\" class=\"headerlink\" title=\"对象实例化内存布局与访问定位\"></a>对象实例化内存布局与访问定位</h1><h2 id=\"对象实例化\"><a href=\"#对象实例化\" class=\"headerlink\" title=\"对象实例化\"></a>对象实例化</h2><h3 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h3><ul>\n<li>对象在JVM中是怎么存储的？</li>\n<li>对象头信息里面有哪些东西？</li>\n<li>Java对象头有什么？</li>\n</ul>\n<p>从对象创建的方式 和 步骤开始说</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/X_VFHL%60OZZW0U.png\"></p>\n<h3 id=\"对象创建方式\"><a href=\"#对象创建方式\" class=\"headerlink\" title=\"对象创建方式\"></a>对象创建方式</h3><ul>\n<li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li>\n<li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li>\n<li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li>\n<li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li>\n<li>使用序列化：序列化一般用于Socket的网络传输</li>\n<li>第三方库 Objenesis</li>\n</ul>\n<h3 id=\"创建对象的步骤\"><a href=\"#创建对象的步骤\" class=\"headerlink\" title=\"创建对象的步骤\"></a>创建对象的步骤</h3><h4 id=\"判断对象对应的类是否加载、链接、初始化\"><a href=\"#判断对象对应的类是否加载、链接、初始化\" class=\"headerlink\" title=\"判断对象对应的类是否加载、链接、初始化\"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p>\n<h4 id=\"为对象分配内存\"><a href=\"#为对象分配内存\" class=\"headerlink\" title=\"为对象分配内存\"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p>\n<ul>\n<li>如果内存规整：指针碰撞</li>\n<li>如果内存不规整<ul>\n<li>虚拟表需要维护一个列表</li>\n<li>空闲列表分配</li>\n</ul>\n</li>\n</ul>\n<p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p>\n<p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p>\n<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p>\n<p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>\n<h4 id=\"处理并发问题\"><a href=\"#处理并发问题\" class=\"headerlink\" title=\"处理并发问题\"></a>处理并发问题</h4><ul>\n<li>采用CAS配上失败重试保证更新的原子性</li>\n<li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul>\n<li>在Eden区给每个线程分配一块区域</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"初始化分配到的内存\"><a href=\"#初始化分配到的内存\" class=\"headerlink\" title=\"初始化分配到的内存\"></a>初始化分配到的内存</h3><p>给对象属性赋值的操作</p>\n<ul>\n<li>属性的默认初始化</li>\n<li>显示初始化</li>\n<li>代码块中的初始化</li>\n<li>构造器初始化</li>\n<li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li>\n</ul>\n<h3 id=\"设置对象的对象头\"><a href=\"#设置对象的对象头\" class=\"headerlink\" title=\"设置对象的对象头\"></a>设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>\n<h3 id=\"执行init方法进行初始化\"><a href=\"#执行init方法进行初始化\" class=\"headerlink\" title=\"执行init方法进行初始化\"></a>执行init方法进行初始化</h3><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p>\n<p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>\n<h3 id=\"对象实例化的过程\"><a href=\"#对象实例化的过程\" class=\"headerlink\" title=\"对象实例化的过程\"></a>对象实例化的过程</h3><ul>\n<li>加载类元信息</li>\n<li>为对象分配内存</li>\n<li>处理并发问题</li>\n<li>属性的默认初始化（零值初始化）</li>\n<li>设置对象头信息</li>\n<li>属性的显示初始化、代码块中初始化、构造器中初始化</li>\n</ul>\n<h2 id=\"对象内存布局\"><a href=\"#对象内存布局\" class=\"headerlink\" title=\"对象内存布局\"></a>对象内存布局</h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/2HN93YJHO8R04YR0V2O.png\"></p>\n<h3 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h3><p>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针</p>\n<blockquote>\n<p>如果是数组，还需要记录数组的长度</p>\n</blockquote>\n<h4 id=\"运行时元数据\"><a href=\"#运行时元数据\" class=\"headerlink\" title=\"运行时元数据\"></a>运行时元数据</h4><ul>\n<li>哈希值（HashCode）</li>\n<li>GC分代年龄</li>\n<li>锁状态标志</li>\n<li>线程持有的锁</li>\n<li>偏向线程ID</li>\n<li>翩向时间戳</li>\n</ul>\n<h4 id=\"类型指针\"><a href=\"#类型指针\" class=\"headerlink\" title=\"类型指针\"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</p>\n<h3 id=\"实例数据（Instance-Data）\"><a href=\"#实例数据（Instance-Data）\" class=\"headerlink\" title=\"实例数据（Instance Data）\"></a>实例数据（Instance Data）</h3><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p>\n<ul>\n<li><p>相同宽度的字段总是被分配在一起</p>\n</li>\n<li><p>父类中定义的变量会出现在子类之前</p>\n</li>\n<li><p>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</p>\n</li>\n</ul>\n<h3 id=\"对齐填充（Padding）\"><a href=\"#对齐填充（Padding）\" class=\"headerlink\" title=\"对齐填充（Padding）\"></a>对齐填充（Padding）</h3><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p>\n<p><strong>举例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> id = <span class=\"number\">1001</span>;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    Account acct;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name = <span class=\"string\">&quot;匿名客户&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Customer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        acct = <span class=\"keyword\">new</span> Account();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerTest</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(string[] args)</span></span>&#123;</span><br><span class=\"line\">        Customer cust=<span class=\"keyword\">new</span> Customer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>图示</strong></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/LHFAPCQ7M]G~GCV.png\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/]DU2Y4ECJ047RDXU%7DZ%60C.png\"></p>\n<h2 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/KWMY78G7E1EWYXKW3.png\"></p>\n<p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/E7H]83DO1YK]6Z613E7.png\"></p>\n<h3 id=\"句柄访问\"><a href=\"#句柄访问\" class=\"headerlink\" title=\"句柄访问\"></a>句柄访问</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/WRRTZ9BRLZUB1~V71AD.png\"></p>\n<p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p>\n<h3 id=\"直接指针（HotSpot采用）\"><a href=\"#直接指针（HotSpot采用）\" class=\"headerlink\" title=\"直接指针（HotSpot采用）\"></a>直接指针（HotSpot采用）</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/57FJ%7BW18]0QR]XEX7BZ2.png\"></p>\n<p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第14章-垃圾回收概述","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC14%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/","content":"<h1 id=\"垃圾回收概述\"><a href=\"#垃圾回收概述\" class=\"headerlink\" title=\"垃圾回收概述\"></a>垃圾回收概述</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>这次我们主要关注的是黄色部分，内存的分配与回收</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/VGY74FUW8LGNME.png\"></p>\n<h2 id=\"什么是垃圾\"><a href=\"#什么是垃圾\" class=\"headerlink\" title=\"什么是垃圾\"></a>什么是垃圾</h2><p>在提到什么是垃圾之前，我们先看下面一张图</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/3JZHJTBEECW3XAT7J6.png\"></p>\n<p>从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。</p>\n<p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。 关于垃圾收集有三个经典问题：</p>\n<ul>\n<li>哪些内存需要回收？</li>\n<li>什么时候回收？</li>\n<li>如何回收？</li>\n</ul>\n<p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>\n<h3 id=\"什么是垃圾？\"><a href=\"#什么是垃圾？\" class=\"headerlink\" title=\"什么是垃圾？\"></a>什么是垃圾？</h3><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p>\n<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p>\n<h3 id=\"磁盘碎片整理\"><a href=\"#磁盘碎片整理\" class=\"headerlink\" title=\"磁盘碎片整理\"></a>磁盘碎片整理</h3><p>机械硬盘需要进行磁盘整理，同时还有坏道</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/F8[E9X7[S0BKKW37B.png\"></p>\n<h3 id=\"大厂面试题\"><a href=\"#大厂面试题\" class=\"headerlink\" title=\"大厂面试题\"></a>大厂面试题</h3><h4 id=\"蚂蚁金服\"><a href=\"#蚂蚁金服\" class=\"headerlink\" title=\"蚂蚁金服\"></a>蚂蚁金服</h4><ul>\n<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1？</li>\n<li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li>\n<li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li>\n<li>GC的两种判定方法？CMS收集器与G1收集器的特点</li>\n</ul>\n<h4 id=\"百度\"><a href=\"#百度\" class=\"headerlink\" title=\"百度\"></a>百度</h4><ul>\n<li>说一下GC算法，分代回收说下</li>\n<li>垃圾收集策略和算法</li>\n</ul>\n<h4 id=\"天猫\"><a href=\"#天猫\" class=\"headerlink\" title=\"天猫\"></a>天猫</h4><ul>\n<li>JVM GC原理，JVM怎么回收内存</li>\n<li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>\n</ul>\n<h4 id=\"滴滴\"><a href=\"#滴滴\" class=\"headerlink\" title=\"滴滴\"></a>滴滴</h4><p>Java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的</p>\n<h4 id=\"京东\"><a href=\"#京东\" class=\"headerlink\" title=\"京东\"></a>京东</h4><ul>\n<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，</li>\n<li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li>\n</ul>\n<h4 id=\"阿里\"><a href=\"#阿里\" class=\"headerlink\" title=\"阿里\"></a>阿里</h4><ul>\n<li>讲一讲垃圾回收算法。</li>\n<li>什么情况下触发垃圾回收？</li>\n<li>如何选择合适的垃圾收集算法？</li>\n<li>JVM有哪三种垃圾回收器？</li>\n</ul>\n<h4 id=\"字节跳动\"><a href=\"#字节跳动\" class=\"headerlink\" title=\"字节跳动\"></a>字节跳动</h4><ul>\n<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>\n<li>System.gc（）和Runtime.gc（）会做什么事情？</li>\n<li>Java GC机制？GC Roots有哪些？</li>\n<li>Java对象的回收方式，回收算法。</li>\n<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>\n<li>CMS回收停顿了几次，为什么要停顿两次?</li>\n</ul>\n<h2 id=\"为什么需要GC\"><a href=\"#为什么需要GC\" class=\"headerlink\" title=\"为什么需要GC\"></a>为什么需要GC</h2><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>\n<p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。</p>\n<p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>\n<h2 id=\"早期垃圾回收\"><a href=\"#早期垃圾回收\" class=\"headerlink\" title=\"早期垃圾回收\"></a>早期垃圾回收</h2><p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">MibBridge *pBridge= <span class=\"keyword\">new</span> cmBaseGroupBridge（）；</span><br><span class=\"line\"><span class=\"comment\">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> pBridge；</span><br></pre></td></tr></table></figure>\n\n<p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p>\n<p>有了垃圾回收机制后，上述代码极有可能变成这样</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">MibBridge *pBridge=<span class=\"keyword\">new</span> <span class=\"built_in\">cmBaseGroupBridge</span>(); </span><br><span class=\"line\">pBridge-&gt;<span class=\"built_in\">Register</span>(kDestroy);</span><br></pre></td></tr></table></figure>\n\n<p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。</p>\n<h2 id=\"Java垃圾回收机制\"><a href=\"#Java垃圾回收机制\" class=\"headerlink\" title=\"Java垃圾回收机制\"></a>Java垃圾回收机制</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p>\n<p>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</p>\n<p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p>\n<p>oracle官网关于垃圾回收的介绍 <a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html\">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p>\n<h3 id=\"担忧\"><a href=\"#担忧\" class=\"headerlink\" title=\"担忧\"></a>担忧</h3><p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p>\n<p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</p>\n<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>\n<h3 id=\"GC主要关注的区域\"><a href=\"#GC主要关注的区域\" class=\"headerlink\" title=\"GC主要关注的区域\"></a>GC主要关注的区域</h3><p>GC主要关注于 方法区 和堆中的垃圾收集</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/8B9QWEXKOWQNV%7BU17.png\"></p>\n<p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收</p>\n<ul>\n<li>其中，Java堆是垃圾收集器的工作重点</li>\n</ul>\n<p>从次数上讲：</p>\n<ul>\n<li>频繁收集Young区</li>\n<li>较少收集Old区</li>\n<li>基本不收集Perm区（元空间）</li>\n</ul>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第12章-执行引擎","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC12%E7%AB%A0-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/","content":"<h1 id=\"执行引擎\"><a href=\"#执行引擎\" class=\"headerlink\" title=\"执行引擎\"></a>执行引擎</h1><h2 id=\"执行引擎概述\"><a href=\"#执行引擎概述\" class=\"headerlink\" title=\"执行引擎概述\"></a>执行引擎概述</h2><p>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/VYJQF4N84HCR6D56_HK.png\"></p>\n<p>执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>\n<p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/QIHY$HY1FGE3%60F$V.png\"></p>\n<p>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/2TCU0Q26D86H]9NUY.png\"></p>\n<h3 id=\"执行引擎的工作流程\"><a href=\"#执行引擎的工作流程\" class=\"headerlink\" title=\"执行引擎的工作流程\"></a>执行引擎的工作流程</h3><ul>\n<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li>\n<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>\n<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/MK7N4Z3UHM4K57T.png\"></p>\n<p>从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p>\n<h2 id=\"Java代码编译和执行过程\"><a href=\"#Java代码编译和执行过程\" class=\"headerlink\" title=\"Java代码编译和执行过程\"></a>Java代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p>\n<ul>\n<li>前面橙色部分是生成字节码文件的过程，和JVM无关</li>\n<li>后面蓝色和绿色才是JVM需要考虑的过程</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/Z91~I%7BOX~9MGN638%7DC.png\"></p>\n<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/H7H[~1W9SKCZWB5HAW.png\"></p>\n<p>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/KPDKV]WCP9JWKK8]3PB.png\"></p>\n<p>我们用一个总的图，来说说 解释器和编译器</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/41KSP9QWM89QLRG5LNG.png\"></p>\n<h3 id=\"什么是解释器（Interpreter）\"><a href=\"#什么是解释器（Interpreter）\" class=\"headerlink\" title=\"什么是解释器（Interpreter）\"></a>什么是解释器（Interpreter）</h3><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>\n<h3 id=\"什么是IT编译器\"><a href=\"#什么是IT编译器\" class=\"headerlink\" title=\"什么是IT编译器\"></a>什么是IT编译器</h3><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>\n<h3 id=\"为什么Java是半编译半解释型语言\"><a href=\"#为什么Java是半编译半解释型语言\" class=\"headerlink\" title=\"为什么Java是半编译半解释型语言\"></a>为什么Java是半编译半解释型语言</h3><p>JDK1.e时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>\n<p>翻译成本地代码后，就可以做一个缓存操作，存储在方法区中</p>\n<h2 id=\"机器码、指令、汇编语言\"><a href=\"#机器码、指令、汇编语言\" class=\"headerlink\" title=\"机器码、指令、汇编语言\"></a>机器码、指令、汇编语言</h2><h3 id=\"机器码\"><a href=\"#机器码\" class=\"headerlink\" title=\"机器码\"></a>机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p>\n<p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p>\n<p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p>\n<p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p>\n<p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p>\n<p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p>\n<h3 id=\"指令集\"><a href=\"#指令集\" class=\"headerlink\" title=\"指令集\"></a>指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p>\n<ul>\n<li>x86指令集，对应的是x86架构的平台</li>\n<li>ARM指令集，对应的是ARM架构的平台</li>\n</ul>\n<h3 id=\"汇编语言\"><a href=\"#汇编语言\" class=\"headerlink\" title=\"汇编语言\"></a>汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p>\n<p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo1）或标号（Labe1）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p>\n<blockquote>\n<p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</p>\n</blockquote>\n<h3 id=\"高级语言\"><a href=\"#高级语言\" class=\"headerlink\" title=\"高级语言\"></a>高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。</p>\n<p>高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/]%7DS1%7DE_MJHF47GEX98N.png\"></p>\n<p>高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++</p>\n<h3 id=\"C、C-源程序执行过程\"><a href=\"#C、C-源程序执行过程\" class=\"headerlink\" title=\"C、C++源程序执行过程\"></a>C、C++源程序执行过程</h3><p>编译过程又可以分成两个阶段：编译和汇编。</p>\n<p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p>\n<p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/49S7MYZMOQ3.png\"></p>\n<h3 id=\"字节码\"><a href=\"#字节码\" class=\"headerlink\" title=\"字节码\"></a>字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p>\n<p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p>\n<p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p>\n<ul>\n<li>字节码典型的应用为：Java bytecode</li>\n</ul>\n<h2 id=\"解释器\"><a href=\"#解释器\" class=\"headerlink\" title=\"解释器\"></a>解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/H6_8TII67QL[KE4.png\"></p>\n<p>为什么Java源文件不直接翻译成JMV，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的</p>\n<p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>\n<p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>\n<h3 id=\"解释器分类\"><a href=\"#解释器分类\" class=\"headerlink\" title=\"解释器分类\"></a>解释器分类</h3><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p>\n<p>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p>\n<p>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p>\n<p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p>\n<ul>\n<li>Interpreter模块：实现了解释器的核心功能</li>\n<li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li>\n</ul>\n<h3 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h3><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</p>\n<p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p>\n<p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p>\n<h2 id=\"JIT编译器\"><a href=\"#JIT编译器\" class=\"headerlink\" title=\"JIT编译器\"></a>JIT编译器</h2><h3 id=\"Java代码的执行分类\"><a href=\"#Java代码的执行分类\" class=\"headerlink\" title=\"Java代码的执行分类\"></a>Java代码的执行分类</h3><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p>\n<p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p>\n<p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>\n<p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p>\n<h3 id=\"问题来了\"><a href=\"#问题来了\" class=\"headerlink\" title=\"问题来了\"></a>问题来了</h3><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>\n<ul>\n<li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li>\n</ul>\n<p>首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>\n<p>所以： 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</p>\n<p>在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p>\n<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>\n<h3 id=\"HotSpot-JVM执行方式\"><a href=\"#HotSpot-JVM执行方式\" class=\"headerlink\" title=\"HotSpot JVM执行方式\"></a>HotSpot JVM执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>\n<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/WPDO4KZ2UY250V7H.png\"></p>\n<h3 id=\"概念解释\"><a href=\"#概念解释\" class=\"headerlink\" title=\"概念解释\"></a>概念解释</h3><ul>\n<li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）</li>\n<li>把字节码转变成机器码的过程。</li>\n<li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。</li>\n</ul>\n<p>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p>\n<p>JIT编译器：HotSpot VM的C1、C2编译器。</p>\n<p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p>\n<h3 id=\"热点探测技术\"><a href=\"#热点探测技术\" class=\"headerlink\" title=\"热点探测技术\"></a>热点探测技术</h3><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。</p>\n<p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p>\n<p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</p>\n<p>采用基于计数器的热点探测，HotSpot V将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p>\n<ul>\n<li>方法调用计数器用于统计方法的调用次数</li>\n<li>回边计数器则用于统计循环体执行的循环次数</li>\n</ul>\n<h3 id=\"方法调用计数器\"><a href=\"#方法调用计数器\" class=\"headerlink\" title=\"方法调用计数器\"></a>方法调用计数器</h3><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p>\n<p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p>\n<p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/EXPH]%60913G%60Y%7D_MOPLJ.png\"></p>\n<h3 id=\"热点衰减\"><a href=\"#热点衰减\" class=\"headerlink\" title=\"热点衰减\"></a>热点衰减</h3><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p>\n<ul>\n<li>半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄</li>\n</ul>\n<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>\n<p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>\n<h3 id=\"回边计数器\"><a href=\"#回边计数器\" class=\"headerlink\" title=\"回边计数器\"></a>回边计数器</h3><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/8PTPUL2OFJNMDT%7B9WV.png\"></p>\n<h3 id=\"HotSpotVM-可以设置程序执行方法\"><a href=\"#HotSpotVM-可以设置程序执行方法\" class=\"headerlink\" title=\"HotSpotVM 可以设置程序执行方法\"></a>HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p>\n<ul>\n<li>-Xint：完全采用解释器模式执行程序；</li>\n<li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>\n<li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/4A1HBDG[]C1_]H5TKYA.png\"></p>\n<h3 id=\"HotSpotVM中-JIT-分类\"><a href=\"#HotSpotVM中-JIT-分类\" class=\"headerlink\" title=\"HotSpotVM中 JIT 分类\"></a>HotSpotVM中 JIT 分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>\n<ul>\n<li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul>\n<li>C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。</li>\n</ul>\n</li>\n<li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。<ul>\n<li>C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"C1-和-C2编译器不同的优化策略\"><a href=\"#C1-和-C2编译器不同的优化策略\" class=\"headerlink\" title=\"C1 和 C2编译器不同的优化策略\"></a>C1 和 C2编译器不同的优化策略</h3><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。</p>\n<ul>\n<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>\n<li>去虚拟化：对唯一的实现樊进行内联</li>\n<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>\n</ul>\n<p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p>\n<ul>\n<li>标量替换：用标量值代替聚合对象的属性值</li>\n<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>\n<li>同步消除：清除同步操作，通常指synchronized</li>\n</ul>\n<h3 id=\"分层编译策略\"><a href=\"#分层编译策略\" class=\"headerlink\" title=\"分层编译策略\"></a>分层编译策略</h3><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p>\n<p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>一般来讲，JIT编译出来的机器码性能比解释器搞</li>\n<li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li>\n</ul>\n<h3 id=\"AOT编译器\"><a href=\"#AOT编译器\" class=\"headerlink\" title=\"AOT编译器\"></a>AOT编译器</h3><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p>\n<p>Java 9引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p>\n<p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</span><br></pre></td></tr></table></figure>\n\n<p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p>\n<p>缺点：</p>\n<ul>\n<li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li>\n<li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li>\n<li>还需要继续优化中，最初只支持Linux X64 java base</li>\n</ul>\n<h3 id=\"写到最后\"><a href=\"#写到最后\" class=\"headerlink\" title=\"写到最后\"></a>写到最后</h3><ul>\n<li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li>\n<li>编译效果短短几年时间就追评了G2编译器，未来可期</li>\n<li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</span><br></pre></td></tr></table></figure>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第13章-StringTable","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC13%E7%AB%A0-StringTable/","content":"<h2 id=\"String的基本特性\"><a href=\"#String的基本特性\" class=\"headerlink\" title=\"String的基本特性\"></a>String的基本特性</h2><ul>\n<li>String：字符串，使用一对 ”” 引起来表示<ul>\n<li>String s1 = “mogublog” ; // 字面量的定义方式</li>\n<li>String s2 = new String(“moxi”);</li>\n</ul>\n</li>\n<li>string声明为final的，不可被继承</li>\n<li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</li>\n<li>string在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li>\n</ul>\n<h3 id=\"为什么JDK9改变了结构\"><a href=\"#为什么JDK9改变了结构\" class=\"headerlink\" title=\"为什么JDK9改变了结构\"></a>为什么JDK9改变了结构</h3><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p>\n<p>我们建议改变字符串的内部表示clasš从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p>\n<p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 之前</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br><span class=\"line\"><span class=\"comment\">// 之后</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] value</span><br></pre></td></tr></table></figure>\n\n<p>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p>\n<h3 id=\"String的不可变性\"><a href=\"#String的不可变性\" class=\"headerlink\" title=\"String的不可变性\"></a>String的不可变性</h3><p>String：代表不可变的字符序列。简称：不可变性。</p>\n<blockquote>\n<p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>\n</blockquote>\n<p>代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 字面量定义的方式，“abc”存储在字符串常量池中</span></span><br><span class=\"line\">        String s1 = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        String s2 = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        System.out.println(s1 == s2);</span><br><span class=\"line\">        s1 = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">        System.out.println(s1 == s2);</span><br><span class=\"line\">        System.out.println(s1);</span><br><span class=\"line\">        System.out.println(s2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;----------------&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String s1 = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        String s2 = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 只要进行了修改，就会重新创建一个对象，这就是不可变性</span></span><br><span class=\"line\">        s2 += <span class=\"string\">&quot;def&quot;</span>;</span><br><span class=\"line\">        System.out.println(s1);</span><br><span class=\"line\">        System.out.println(s2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;----------------&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String s1 = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        String s2 = s1.replace(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;m&#x27;</span>);</span><br><span class=\"line\">        System.out.println(s1);</span><br><span class=\"line\">        System.out.println(s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        test1();</span><br><span class=\"line\">        test2();</span><br><span class=\"line\">        test3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">true</span><br><span class=\"line\">false</span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"section\">abc</span></span><br><span class=\"line\"><span class=\"section\">----------------</span></span><br><span class=\"line\">abc</span><br><span class=\"line\"><span class=\"section\">abcdef</span></span><br><span class=\"line\"><span class=\"section\">----------------</span></span><br><span class=\"line\">abc</span><br><span class=\"line\">mbc</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringExer</span> </span>&#123;</span><br><span class=\"line\">    String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;good&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> [] ch = &#123;<span class=\"string\">&#x27;t&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;s&#x27;</span>,<span class=\"string\">&#x27;t&#x27;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">change</span><span class=\"params\">(String str, <span class=\"keyword\">char</span> ch [])</span> </span>&#123;</span><br><span class=\"line\">        str = <span class=\"string\">&quot;test ok&quot;</span>;</span><br><span class=\"line\">        ch[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;b&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        StringExer ex = <span class=\"keyword\">new</span> StringExer();</span><br><span class=\"line\">        ex.change(ex.str, ex.ch);</span><br><span class=\"line\">        System.out.println(ex.str);</span><br><span class=\"line\">        System.out.println(ex.ch);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">good</span><br><span class=\"line\">best</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p>\n<p>String的string Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。</p>\n<p>使用-XX:StringTablesize可设置stringTab1e的长度</p>\n<p>在jdk6中stringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。stringTablesize设置没有要求</p>\n<p>在jdk7中，stringTable的长度默认值是60013，</p>\n<p>在JDK8中，StringTable可以设置的最小值为1009</p>\n<h2 id=\"String的内存分配\"><a href=\"#String的内存分配\" class=\"headerlink\" title=\"String的内存分配\"></a>String的内存分配</h2><p>在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>\n<p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，string类型的常量池比较特殊。它的主要使用方法有两种。</p>\n<p>直接使用双引号声明出来的String对象会直接存储在常量池中。</p>\n<ul>\n<li>比如：string info=”atguigu.com”；</li>\n</ul>\n<p>如果不是用双引号声明的string对象，可以使用string提供的intern（）方法。</p>\n<p>Java 6及以前，字符串常量池存放在永久代</p>\n<p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p>\n<blockquote>\n<p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p>\n<p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用string.intern（）。</p>\n</blockquote>\n<p>Java8元空间，字符串常量在堆</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/SLOGD956ZAMW2JYRY12C45M.png\"></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/4GZ6T9Y95LPY9TGY.png\"></p>\n<h3 id=\"为什么StringTable从永久代调整到堆中\"><a href=\"#为什么StringTable从永久代调整到堆中\" class=\"headerlink\" title=\"为什么StringTable从永久代调整到堆中\"></a>为什么StringTable从永久代调整到堆中</h3><p>在JDK 7中，interned字符串不再在Java堆的永久生成中分配，而是在Java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。</p>\n<ul>\n<li>永久代的默认比较小</li>\n<li>永久代垃圾回收频率低</li>\n</ul>\n<h2 id=\"String的基本操作\"><a href=\"#String的基本操作\" class=\"headerlink\" title=\"String的基本操作\"></a>String的基本操作</h2><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p>\n<h2 id=\"字符串拼接操作\"><a href=\"#字符串拼接操作\" class=\"headerlink\" title=\"字符串拼接操作\"></a>字符串拼接操作</h2><ul>\n<li>常量与常量的拼接结果在常量池，原理是编译期优化</li>\n<li>常量池中不会存在相同内容的变量</li>\n<li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li>\n<li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       String s1 = <span class=\"string\">&quot;a&quot;</span> + <span class=\"string\">&quot;b&quot;</span> + <span class=\"string\">&quot;c&quot;</span>;  <span class=\"comment\">// 得到 abc的常量池</span></span><br><span class=\"line\">       String s2 = <span class=\"string\">&quot;abc&quot;</span>; <span class=\"comment\">// abc存放在常量池，直接将常量池的地址返回</span></span><br><span class=\"line\">       <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 最终java编译成.class，再执行.class</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       System.out.println(s1 == s2); <span class=\"comment\">// true，因为存放在字符串常量池</span></span><br><span class=\"line\">       System.out.println(s1.equals(s2)); <span class=\"comment\">// true</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       String s1 = <span class=\"string\">&quot;javaEE&quot;</span>;</span><br><span class=\"line\">       String s2 = <span class=\"string\">&quot;hadoop&quot;</span>;</span><br><span class=\"line\">       String s3 = <span class=\"string\">&quot;javaEEhadoop&quot;</span>;</span><br><span class=\"line\">       String s4 = <span class=\"string\">&quot;javaEE&quot;</span> + <span class=\"string\">&quot;hadoop&quot;</span>;    </span><br><span class=\"line\">       String s5 = s1 + <span class=\"string\">&quot;hadoop&quot;</span>;</span><br><span class=\"line\">       String s6 = <span class=\"string\">&quot;javaEE&quot;</span> + s2;</span><br><span class=\"line\">       String s7 = s1 + s2;</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(s3 == s4); <span class=\"comment\">// true</span></span><br><span class=\"line\">       System.out.println(s3 == s5); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s3 == s6); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s3 == s7); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s5 == s6); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s5 == s7); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s6 == s7); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">       String s8 = s6.intern();</span><br><span class=\"line\">       System.out.println(s3 == s8); <span class=\"comment\">// true</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上述的结果我们可以知道：</p>\n<p>如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果</p>\n<p>而调用intern方法，则会判断字符串常量池中是否存在JavaEEhadoop值，如果存在则返回常量池中的值，否者就在常量池中创建</p>\n<h3 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h3><p>拼接操作的底层其实使用了StringBuilder</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/JG%7BIS8JV9TWKW9R_JY.png\"></p>\n<p>s1 + s2的执行细节</p>\n<ul>\n<li>StringBuilder s = new StringBuilder();</li>\n<li>s.append(s1);</li>\n<li>s.append(s2);</li>\n<li>s.toString(); -&gt; 类似于new String(“ab”);</li>\n</ul>\n<p>在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer</p>\n<p>| String | StringBuffer | StringBuilder | | ———————————————————— | ———————————————————— | —————- | | String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间 | StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 | 可变类，速度更快 | | 不可变 | 可变 | 可变 | | | 线程安全 | 线程不安全 | | | 多线程操作字符串 | 单线程操作字符串 |</p>\n<p>注意，我们左右两边如果是变量的话，就是需要new StringBuilder进行拼接，但是如果使用的是final修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。也就是说被final修饰的变量，将会变成常量，类和方法将不能被继承、</p>\n<ul>\n<li>在开发中，能够使用final的时候，建议使用上</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String s1 = <span class=\"string\">&quot;a&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String s2 = <span class=\"string\">&quot;b&quot;</span>;</span><br><span class=\"line\">    String s3 = <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\">    String s4 = s1 + s2;</span><br><span class=\"line\">    System.out.println(s3 == s4);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"拼接操作和append性能对比\"><a href=\"#拼接操作和append性能对比\" class=\"headerlink\" title=\"拼接操作和append性能对比\"></a>拼接操作和append性能对比</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">(<span class=\"keyword\">int</span> highLevel)</span> </span>&#123;</span><br><span class=\"line\">    String src = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class=\"line\">        src += <span class=\"string\">&quot;a&quot;</span>; <span class=\"comment\">// 每次循环都会创建一个StringBuilder对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">(<span class=\"keyword\">int</span> highLevel)</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法1耗费的时间：4005ms，方法2消耗时间：7ms</p>\n<p>结论：</p>\n<ul>\n<li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li>\n</ul>\n<p>好处</p>\n<ul>\n<li>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</li>\n<li>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</li>\n<li>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</li>\n</ul>\n<p>改进的空间</p>\n<ul>\n<li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li>\n<li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li>\n</ul>\n<h2 id=\"intern-的使用\"><a href=\"#intern-的使用\" class=\"headerlink\" title=\"intern()的使用\"></a>intern()的使用</h2><p>intern是一个native方法，调用的是底层C的方法</p>\n<p>字符串池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p>\n<p>如果不是用双引号声明的string对象，可以使用string提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>\n<p>比如：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span> myInfo = <span class=\"keyword\">new</span> <span class=\"keyword\">string</span>(<span class=\"string\">&quot;I love atguigu&quot;</span>).intern();</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，如果在任意字符串上调用string.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"string\">&quot;a&quot;</span>+<span class=\"string\">&quot;b&quot;</span>+<span class=\"string\">&quot;c&quot;</span>）.intern（）==<span class=\"string\">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>通俗点讲，Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>\n<h3 id=\"intern的空间效率测试\"><a href=\"#intern的空间效率测试\" class=\"headerlink\" title=\"intern的空间效率测试\"></a>intern的空间效率测试</h3><p>我们通过测试一下，使用了intern和不使用的时候，其实相差还挺多的</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringIntern2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_COUNT = <span class=\"number\">1000</span> * <span class=\"number\">10000</span>;</span><br><span class=\"line\">    <span class=\"built_in\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">String</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[MAX_COUNT];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span>[] args) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Integer</span> [] data = <span class=\"keyword\">new</span> <span class=\"keyword\">Integer</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">        long start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class=\"line\">            arr[i] = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>(<span class=\"keyword\">String</span>.valueOf(data[i%data.length])).intern();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (<span class=\"built_in\">Exception</span> e) &#123;</span><br><span class=\"line\">            e.getStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结论</strong>：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省内存空间。</p>\n<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</p>\n<h2 id=\"面试题-1\"><a href=\"#面试题-1\" class=\"headerlink\" title=\"面试题\"></a>面试题</h2><h3 id=\"new-String-“ab”-会创建几个对象\"><a href=\"#new-String-“ab”-会创建几个对象\" class=\"headerlink\" title=\"new String(“ab”)会创建几个对象\"></a>new String(“ab”)会创建几个对象</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringNewTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;ab&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们转换成字节码来查看</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">0</span> <span class=\"keyword\">new</span> <span class=\"meta\">#2 &lt;java/lang/String&gt;</span></span><br><span class=\"line\"> <span class=\"number\">3</span> dup</span><br><span class=\"line\"> <span class=\"number\">4</span> ldc <span class=\"meta\">#3 &lt;ab&gt;</span></span><br><span class=\"line\"> <span class=\"number\">6</span> invokespecial <span class=\"meta\">#4 &lt;java/lang/String.&lt;init&gt;&gt;</span></span><br><span class=\"line\"> <span class=\"number\">9</span> astore_1</span><br><span class=\"line\"><span class=\"number\">10</span> <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<p>这里面就是两个对象</p>\n<ul>\n<li>一个对象是：new关键字在堆空间中创建</li>\n<li>另一个对象：字符串常量池中的对象</li>\n</ul>\n<h3 id=\"new-String-“a”-new-String-“b”-会创建几个对象\"><a href=\"#new-String-“a”-new-String-“b”-会创建几个对象\" class=\"headerlink\" title=\"new String(“a”) + new String(“b”) 会创建几个对象\"></a>new String(“a”) + new String(“b”) 会创建几个对象</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringNewTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;a&quot;</span>) + <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>字节码文件为</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">0</span> <span class=\"keyword\">new</span> <span class=\"meta\">#2 &lt;java/lang/StringBuilder&gt;</span></span><br><span class=\"line\"> <span class=\"number\">3</span> dup</span><br><span class=\"line\"> <span class=\"number\">4</span> invokespecial <span class=\"meta\">#3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span></span><br><span class=\"line\"> <span class=\"number\">7</span> <span class=\"keyword\">new</span> <span class=\"meta\">#4 &lt;java/lang/String&gt;</span></span><br><span class=\"line\"><span class=\"number\">10</span> dup</span><br><span class=\"line\"><span class=\"number\">11</span> ldc <span class=\"meta\">#5 &lt;a&gt;</span></span><br><span class=\"line\"><span class=\"number\">13</span> invokespecial <span class=\"meta\">#6 &lt;java/lang/String.&lt;init&gt;&gt;</span></span><br><span class=\"line\"><span class=\"number\">16</span> invokevirtual <span class=\"meta\">#7 &lt;java/lang/StringBuilder.append&gt;</span></span><br><span class=\"line\"><span class=\"number\">19</span> <span class=\"keyword\">new</span> <span class=\"meta\">#4 &lt;java/lang/String&gt;</span></span><br><span class=\"line\"><span class=\"number\">22</span> dup</span><br><span class=\"line\"><span class=\"number\">23</span> ldc <span class=\"meta\">#8 &lt;b&gt;</span></span><br><span class=\"line\"><span class=\"number\">25</span> invokespecial <span class=\"meta\">#6 &lt;java/lang/String.&lt;init&gt;&gt;</span></span><br><span class=\"line\"><span class=\"number\">28</span> invokevirtual <span class=\"meta\">#7 &lt;java/lang/StringBuilder.append&gt;</span></span><br><span class=\"line\"><span class=\"number\">31</span> invokevirtual <span class=\"meta\">#9 &lt;java/lang/StringBuilder.toString&gt;</span></span><br><span class=\"line\"><span class=\"number\">34</span> astore_1</span><br><span class=\"line\"><span class=\"number\">35</span> <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<p>我们创建了6个对象</p>\n<ul>\n<li>对象1：new StringBuilder()</li>\n<li>对象2：new String(“a”)</li>\n<li>对象3：常量池的 a</li>\n<li>对象4：new String(“b”)</li>\n<li>对象5：常量池的 b</li>\n<li>对象6：toString中会创建一个 new String(“ab”)<ul>\n<li>调用toString方法，不会在常量池中生成ab</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"intern的使用：JDK6和JDK7\"><a href=\"#intern的使用：JDK6和JDK7\" class=\"headerlink\" title=\"intern的使用：JDK6和JDK7\"></a>intern的使用：JDK6和JDK7</h3><h4 id=\"JDK6中\"><a href=\"#JDK6中\" class=\"headerlink\" title=\"JDK6中\"></a>JDK6中</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;1&quot;</span>);  <span class=\"comment\">// 在常量池中已经有了</span></span><br><span class=\"line\">s.intern(); <span class=\"comment\">// 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1</span></span><br><span class=\"line\">String s2 = <span class=\"string\">&quot;1&quot;</span>;</span><br><span class=\"line\">System.out.println(s == s2); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">String s3 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;1&quot;</span>) + <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">s3.intern();</span><br><span class=\"line\">String s4 = <span class=\"string\">&quot;11&quot;</span>;</span><br><span class=\"line\">System.out.println(s3 == s4); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>为什么对象会不一样呢？</p>\n<ul>\n<li>一个是new创建的对象，一个是常量池中的对象，显然不是同一个</li>\n</ul>\n<p>如果是下面这样的，那么就是true</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">s = s.intern();</span><br><span class=\"line\"><span class=\"built_in\">String</span> s2 = <span class=\"string\">&quot;1&quot;</span>;</span><br><span class=\"line\">System.out.println(s == s2); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>而对于下面的来说，因为 s3变量记录的地址是 new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是JDK6的关系，然后执行 s3.intern()后，就会在常量池中生成 “11”，最后 s4用的就是s3的地址</p>\n<blockquote>\n<p>为什么最后输出的 s3 == s4 会为false呢？</p>\n<p>这是因为在JDK6中创建了一个新的对象 “11”，也就是有了新的地址， s2 = 新地址</p>\n<p>而在JDK7中，在JDK7中，并没有创新一个新对象，而是指向常量池中的新对象</p>\n</blockquote>\n<h4 id=\"JDK7中\"><a href=\"#JDK7中\" class=\"headerlink\" title=\"JDK7中\"></a>JDK7中</h4><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">s.intern();</span><br><span class=\"line\"><span class=\"built_in\">String</span> s2 = <span class=\"string\">&quot;1&quot;</span>;</span><br><span class=\"line\">System.out.println(s == s2); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span> s3 = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;1&quot;</span>) + <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">s3.intern();</span><br><span class=\"line\"><span class=\"built_in\">String</span> s4 = <span class=\"string\">&quot;11&quot;</span>;</span><br><span class=\"line\">System.out.println(s3 == s4); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/FW17N$V5XMDRVFTUD7V.png\"></p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s3 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;1&quot;</span>) + <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">String s4 = <span class=\"string\">&quot;11&quot;</span>;  <span class=\"comment\">// 在常量池中生成的字符串</span></span><br><span class=\"line\">s3.intern();  <span class=\"comment\">// 然后s3就会从常量池中找，发现有了，就什么事情都不做</span></span><br><span class=\"line\">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>\n\n<p>我们将 s4的位置向上移动一行，发现变化就会很大，最后得到的是 false</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总结string的intern（）的使用：</p>\n<p>JDK1.6中，将这个字符串对象尝试放入串池。</p>\n<ul>\n<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>\n<li>如果没有，会把此<strong>对象复制一份</strong>，放入串池，并返回串池中的对象地址</li>\n</ul>\n<p>JDK1.7起，将这个字符串对象尝试放入串池。</p>\n<ul>\n<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>\n<li>如果没有，则会把<strong>对象的引用地址</strong>复制一份，放入串池，并返回串池中的引用地址</li>\n</ul>\n<p>练习：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/L%7DX1U%7D93K9~O%7DCQV~X[L.png\"></p>\n<ul>\n<li>在JDK6中，在字符串常量池中创建一个字符串 “ab”</li>\n<li>在JDK8中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到 串池中。</li>\n</ul>\n<p>所以上述结果，在JDK6中是：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p>在JDK8中是</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span>  </span><br><span class=\"line\"><span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/A9D[8YZ%60UED4CEPU.png\"></p>\n<p>针对下面这题，在JDK6和8中表现的是一样的</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/EM0TYSD0RGDK9HGUJ6.png\"></p>\n<h2 id=\"StringTable的垃圾回收\"><a href=\"#StringTable的垃圾回收\" class=\"headerlink\" title=\"StringTable的垃圾回收\"></a>StringTable的垃圾回收</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringGCTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">            String.valueOf(i).intern();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"G1中的String去重操作\"><a href=\"#G1中的String去重操作\" class=\"headerlink\" title=\"G1中的String去重操作\"></a>G1中的String去重操作</h2><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：</p>\n<ul>\n<li>堆存活数据集合里面string对象占了25%</li>\n<li>堆存活数据集合里面重复的string对象有13.5%</li>\n<li>string对象的平均长度是45</li>\n</ul>\n<p>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals（string2）= true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ul>\n<li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的string对象。</li>\n<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。</li>\n<li>使用一个hashtab1e来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>\n<li>如果存在，string对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>\n<li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li>\n</ul>\n<h3 id=\"开启\"><a href=\"#开启\" class=\"headerlink\" title=\"开启\"></a>开启</h3><p>命令行选项</p>\n<blockquote>\n<p>UsestringDeduplication（bool）：开启string去重，默认是不开启的，需要手动开启。 Printstringbeduplicationstatistics（bool）：打印详细的去重统计信息 stringpeduplicationAgeThreshold（uintx）：达到这个年龄的string对象被认为是去重的候选对象</p>\n</blockquote>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第15章-垃圾回收相关算法","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC15%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/","content":"<h1 id=\"垃圾回收相关算法\"><a href=\"#垃圾回收相关算法\" class=\"headerlink\" title=\"垃圾回收相关算法\"></a>垃圾回收相关算法</h1><h2 id=\"标记阶段：引用计数算法\"><a href=\"#标记阶段：引用计数算法\" class=\"headerlink\" title=\"标记阶段：引用计数算法\"></a>标记阶段：引用计数算法</h2><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p>\n<p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p>\n<p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法。</strong></p>\n<p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p>\n<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>\n<p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>\n<p>缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p>\n<blockquote>\n<p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p>\n</blockquote>\n<h3 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h3><p>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/3T5HWGAC_0LU8W.png\"></p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>我们使用一个案例来测试Java中是否采用的是引用计数算法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefCountGC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] bigSize = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">5</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 引用</span></span><br><span class=\"line\">    Object reference = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RefCountGC obj1 = <span class=\"keyword\">new</span> RefCountGC();</span><br><span class=\"line\">        RefCountGC obj2 = <span class=\"keyword\">new</span> RefCountGC();</span><br><span class=\"line\">        obj1.reference = obj2;</span><br><span class=\"line\">        obj2.reference = obj1;</span><br><span class=\"line\">        obj1 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        obj2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"code\"><pre><span class=\"line\">[GC (System.gc()) [PSYoungGen: <span class=\"number\">15490</span>K-&gt;<span class=\"number\">808</span>K(<span class=\"number\">76288</span>K)] <span class=\"number\">15490</span>K-&gt;<span class=\"number\">816</span>K(<span class=\"number\">251392</span>K), <span class=\"number\">0.0061980</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.36</span> secs] </span><br><span class=\"line\">[Full GC (System.gc()) [PSYoungGen: <span class=\"number\">808</span>K-&gt;<span class=\"number\">0</span>K(<span class=\"number\">76288</span>K)] [ParOldGen: <span class=\"number\">8</span>K-&gt;<span class=\"number\">672</span>K(<span class=\"number\">175104</span>K)] <span class=\"number\">816</span>K-&gt;<span class=\"number\">672</span>K(<span class=\"number\">251392</span>K), [Metaspace: <span class=\"number\">3479</span>K-&gt;<span class=\"number\">3479</span>K(<span class=\"number\">1056768</span>K)], <span class=\"number\">0.0045983</span> secs] [Times: user=<span class=\"number\">0.00</span> sys=<span class=\"number\">0.00</span>, real=<span class=\"number\">0.00</span> secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> PSYoungGen      total <span class=\"number\">76288</span>K, used <span class=\"number\">655</span>K [<span class=\"number\">0x000000076b500000</span>, <span class=\"number\">0x0000000770a00000</span>, <span class=\"number\">0x00000007c0000000</span>)</span><br><span class=\"line\">  eden space <span class=\"number\">65536</span>K, <span class=\"number\">1</span>% used [<span class=\"number\">0x000000076b500000</span>,<span class=\"number\">0x000000076b5a3ee8</span>,<span class=\"number\">0x000000076f500000</span>)</span><br><span class=\"line\">  from space <span class=\"number\">10752</span>K, <span class=\"number\">0</span>% used [<span class=\"number\">0x000000076f500000</span>,<span class=\"number\">0x000000076f500000</span>,<span class=\"number\">0x000000076ff80000</span>)</span><br><span class=\"line\">  to   space <span class=\"number\">10752</span>K, <span class=\"number\">0</span>% used [<span class=\"number\">0x000000076ff80000</span>,<span class=\"number\">0x000000076ff80000</span>,<span class=\"number\">0x0000000770a00000</span>)</span><br><span class=\"line\"> ParOldGen       total <span class=\"number\">175104</span>K, used <span class=\"number\">672</span>K [<span class=\"number\">0x00000006c1e00000</span>, <span class=\"number\">0x00000006cc900000</span>, <span class=\"number\">0x000000076b500000</span>)</span><br><span class=\"line\">  object space <span class=\"number\">175104</span>K, <span class=\"number\">0</span>% used [<span class=\"number\">0x00000006c1e00000</span>,<span class=\"number\">0x00000006c1ea8070</span>,<span class=\"number\">0x00000006cc900000</span>)</span><br><span class=\"line\"> Metaspace       used <span class=\"number\">3486</span>K, capacity <span class=\"number\">4496</span>K, committed <span class=\"number\">4864</span>K, reserved <span class=\"number\">1056768</span>K</span><br><span class=\"line\">  class space    used <span class=\"number\">385</span>K, capacity <span class=\"number\">388</span>K, committed <span class=\"number\">512</span>K, reserved <span class=\"number\">1048576</span>K</span><br></pre></td></tr></table></figure>\n\n<p>我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">PSYoungGen: <span class=\"number\">15490</span>K-&gt;<span class=\"number\">808</span><span class=\"built_in\">K</span>(<span class=\"number\">76288</span>K)] <span class=\"number\">15490</span>K-&gt;<span class=\"number\">816</span><span class=\"built_in\">K</span>(<span class=\"number\">251392</span>K)</span><br></pre></td></tr></table></figure>\n\n<p>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/2]RK%7DKAVPF7IBA.png\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p>\n<p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p>\n<p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？</p>\n<blockquote>\n<p>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p>\n</blockquote>\n<h2 id=\"标记阶段：可达性分析算法\"><a href=\"#标记阶段：可达性分析算法\" class=\"headerlink\" title=\"标记阶段：可达性分析算法\"></a>标记阶段：可达性分析算法</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>可达性分析算法：也可以称为 根搜索算法、追踪性垃圾收集</p>\n<p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p>\n<p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p>\n<p>基本思路：</p>\n<ul>\n<li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li>\n<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li>\n<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>\n<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/S]7F1O7QD8XLSCO.png\"></p>\n<p>官场上的裙带关系，可达性分析在人类关系网中</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/HAM7LA_RPK734NTJHVL.png\"></p>\n<h3 id=\"GC-Roots可以是哪些？\"><a href=\"#GC-Roots可以是哪些？\" class=\"headerlink\" title=\"GC Roots可以是哪些？\"></a>GC Roots可以是哪些？</h3><ul>\n<li>虚拟机栈中引用的对象<ul>\n<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>\n</ul>\n</li>\n<li>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象<ul>\n<li>比如：Java类的引用类型静态变量</li>\n</ul>\n</li>\n<li>方法区中常量引用的对象<ul>\n<li>比如：字符串常量池（string Table）里的引用</li>\n</ul>\n</li>\n<li>所有被同步锁synchronized持有的对象</li>\n<li>Java虚拟机内部的引用。<ul>\n<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li>\n</ul>\n</li>\n<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/B47KMLJ%60TX3]UPM]AC.png\"></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p>\n<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p>\n<p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p>\n<h4 id=\"小技巧\"><a href=\"#小技巧\" class=\"headerlink\" title=\"小技巧\"></a>小技巧</h4><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p>\n<p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p>\n<p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>\n<h2 id=\"对象的finalization机制\"><a href=\"#对象的finalization机制\" class=\"headerlink\" title=\"对象的finalization机制\"></a>对象的finalization机制</h2><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>\n<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p>\n<p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>\n<h3 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：</p>\n<ul>\n<li>在finalize（）时可能会导致对象复活。</li>\n<li>finalize（）方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<ul>\n<li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li>\n</ul>\n</li>\n<li>一个糟糕的finalize（）会严重影响Gc的性能。</li>\n</ul>\n<p>从功能上来说，finalize（）方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p>\n<p>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>\n<h3 id=\"生存还是死亡？\"><a href=\"#生存还是死亡？\" class=\"headerlink\" title=\"生存还是死亡？\"></a>生存还是死亡？</h3><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>\n<ul>\n<li>可触及的：从根节点开始，可以到达这个对象。</li>\n<li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li>\n<li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li>\n</ul>\n<p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>\n<h3 id=\"具体过程\"><a href=\"#具体过程\" class=\"headerlink\" title=\"具体过程\"></a>具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p>\n<ul>\n<li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li>\n<li>进行筛选，判断此对象是否有必要执行finalize（）方法<ul>\n<li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li>\n<li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li>\n<li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/JX6OAMO9CU%7BAX1%7DPY8ZSG.png\"></p>\n<p>上图就是我们看到的Finalizer线程</p>\n<h3 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h3><p>我们使用重写 finalize()方法，然后在方法的内部，重写将其存放到GC Roots中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CanReliveObj</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类变量，属于GC Roots的一部分</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> CanReliveObj canReliveObj;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class=\"line\">        canReliveObj = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        canReliveObj = <span class=\"keyword\">new</span> CanReliveObj();</span><br><span class=\"line\">        canReliveObj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;-----------------第一次gc操作------------&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canReliveObj == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;obj is dead&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;obj is still alive&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;-----------------第二次gc操作------------&quot;</span>);</span><br><span class=\"line\">        canReliveObj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"comment\">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canReliveObj == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;obj is dead&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;obj is still alive&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后运行结果</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\">-----------------第一次gc操作------------</span><br><span class=\"line\">调用当前类重写的finalize()方法</span><br><span class=\"line\">obj <span class=\"keyword\">is</span> still alive</span><br><span class=\"line\">-----------------第二次gc操作------------</span><br><span class=\"line\">obj <span class=\"keyword\">is</span> dead</span><br></pre></td></tr></table></figure>\n\n<p>在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</p>\n<h2 id=\"MAT与JProfiler的GC-Roots溯源\"><a href=\"#MAT与JProfiler的GC-Roots溯源\" class=\"headerlink\" title=\"MAT与JProfiler的GC Roots溯源\"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id=\"MAT是什么？\"><a href=\"#MAT是什么？\" class=\"headerlink\" title=\"MAT是什么？\"></a>MAT是什么？</h3><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>\n<p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p>\n<p>大家可以在<a href=\"http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT\">http://www.eclipse.org/mat/下载并使用MAT</a></p>\n<h3 id=\"命令行使用-jmap\"><a href=\"#命令行使用-jmap\" class=\"headerlink\" title=\"命令行使用 jmap\"></a>命令行使用 jmap</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/I%60PDCKT7U_E6KKW.png\"></p>\n<h3 id=\"使用JVIsualVM\"><a href=\"#使用JVIsualVM\" class=\"headerlink\" title=\"使用JVIsualVM\"></a>使用JVIsualVM</h3><p>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</p>\n<p>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。</p>\n<p>在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。</p>\n<p>右击这个节点选择save as（另存为）即可将heap dump保存到本地。</p>\n<h3 id=\"使用MAT打开Dump文件\"><a href=\"#使用MAT打开Dump文件\" class=\"headerlink\" title=\"使用MAT打开Dump文件\"></a>使用MAT打开Dump文件</h3><p>打开后，我们就可以看到有哪些可以作为GC Roots的对象</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/5IV2G6DPO8_Y~MWN41V.png\"></p>\n<p>里面我们能够看到有一些常用的Java类，然后Thread线程。</p>\n<h3 id=\"JProfiler的GC-Roots溯源\"><a href=\"#JProfiler的GC-Roots溯源\" class=\"headerlink\" title=\"JProfiler的GC Roots溯源\"></a>JProfiler的GC Roots溯源</h3><p>我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/1YWRJN7IO5BFKPP7V.png\"></p>\n<h3 id=\"如何判断什么原因造成OOM\"><a href=\"#如何判断什么原因造成OOM\" class=\"headerlink\" title=\"如何判断什么原因造成OOM\"></a>如何判断什么原因造成OOM</h3><p>当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeapOOM</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建1M的文件</span></span><br><span class=\"line\">    <span class=\"keyword\">byte</span> [] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ArrayList&lt;HeapOOM&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                list.add(<span class=\"keyword\">new</span> HeapOOM());</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.getStackTrace();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;count:&quot;</span> + count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"deletion\">-Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span></span><br></pre></td></tr></table></figure>\n\n<p>我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/NDWW508[YNN4RYE7X4DOQ.png\"></p>\n<p>然后我们通过线程，还能够定位到哪里出现OOM</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/H[_RHRDHKS182TEKH.png\"></p>\n<h2 id=\"清除阶段：标记-清除算法\"><a href=\"#清除阶段：标记-清除算法\" class=\"headerlink\" title=\"清除阶段：标记-清除算法\"></a>清除阶段：标记-清除算法</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p>\n<ul>\n<li>标记一清除算法（Mark-Sweep）</li>\n<li>复制算法（copying）</li>\n<li>标记-压缩算法（Mark-Compact）</li>\n</ul>\n<p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>\n<h3 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h3><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>\n<ul>\n<li><p>标记</p>\n<p>：Collector从引用根节点开始遍历，</p>\n<p>标记所有被引用的对象</p>\n<p>。一般是在对象的Header中记录为可达对象。</p>\n<ul>\n<li><strong>标记的是引用的对象，不是垃圾！！</strong></li>\n</ul>\n</li>\n<li><p><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</p>\n</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/PI27BX0%7D2T60EK%7BK0OL.png\"></p>\n<h3 id=\"什么是清除？\"><a href=\"#什么是清除？\" class=\"headerlink\" title=\"什么是清除？\"></a>什么是清除？</h3><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>\n<p>关于空闲列表是在为对象分配内存的时候 提过</p>\n<ul>\n<li>如果内存规整<ul>\n<li>采用指针碰撞的方式进行内存分配</li>\n</ul>\n</li>\n<li>如果内存不规整<ul>\n<li>虚拟机需要维护一个列表</li>\n<li>空闲列表分配</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>标记清除算法的效率不算高</li>\n<li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li>\n<li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li>\n</ul>\n<h2 id=\"清除阶段：复制算法\"><a href=\"#清除阶段：复制算法\" class=\"headerlink\" title=\"清除阶段：复制算法\"></a>清除阶段：复制算法</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/H[H%7DX6X92LF4KJMR%7BWK.png\"></p>\n<p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/%7DS0BODBI97LFNK%7D32RV.png\"></p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>没有标记和清除过程，实现简单，运行高效</li>\n<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>\n</ul>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>\n<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li>\n</ul>\n<h3 id=\"注意-2\"><a href=\"#注意-2\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</p>\n<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/XN89S4X9P%7B53FFUEI%60I.png\"></p>\n<h2 id=\"清除阶段：标记-整理算法\"><a href=\"#清除阶段：标记-整理算法\" class=\"headerlink\" title=\"清除阶段：标记-整理算法\"></a>清除阶段：标记-整理算法</h2><h3 id=\"背景-1\"><a href=\"#背景-1\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>\n<p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>\n<p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>\n<h3 id=\"执行过程-1\"><a href=\"#执行过程-1\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h3><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p>\n<p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/RFBRXKVPJA~K7%60G35LM9.png\"></p>\n<h3 id=\"标清和标整的区别\"><a href=\"#标清和标整的区别\" class=\"headerlink\" title=\"标清和标整的区别\"></a>标清和标整的区别</h3><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p>\n<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>\n<h3 id=\"标整的优缺点\"><a href=\"#标整的优缺点\" class=\"headerlink\" title=\"标整的优缺点\"></a>标整的优缺点</h3><h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>\n<li>消除了复制算法当中，内存减半的高额代价。</li>\n</ul>\n<h4 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>从效率上来说，标记-整理算法要低于复制算法。</li>\n<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>\n<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>\n</ul>\n<h2 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>\n<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>\n<p>| | 标记清除 | 标记整理 | 复制 | | ———— | —————— | —————- | ————————————- | | <strong>速率</strong> | 中等 | 最慢 | 最快 | | <strong>空间开销</strong> | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍空间（不堆积碎片） | | <strong>移动对象</strong> | 否 | 是 | 是 |</p>\n<p>综合我们可以找到，没有最好的算法，只有最合适的算法</p>\n<h3 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>\n<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>\n<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>\n<p>目前几乎所有的GC都采用分代收集算法执行垃圾回收的</p>\n<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>\n<ul>\n<li>年轻代（Young Gen）</li>\n</ul>\n<p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>\n<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>\n<ul>\n<li>老年代（Tenured Gen）</li>\n</ul>\n<p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>\n<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>\n<ul>\n<li>Mark阶段的开销与存活对象的数量成正比。</li>\n<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>\n<li>compact阶段的开销与存活对象的数据成正比。</li>\n</ul>\n<p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p>\n<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p>\n<h2 id=\"增量收集算法\"><a href=\"#增量收集算法\" class=\"headerlink\" title=\"增量收集算法\"></a>增量收集算法</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>\n<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>\n<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p>\n<h3 id=\"缺点-3\"><a href=\"#缺点-3\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>\n<h2 id=\"分区算法\"><a href=\"#分区算法\" class=\"headerlink\" title=\"分区算法\"></a>分区算法</h2><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>\n<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/30Q%60UV5PSE%7DP4LLVB.png\"></p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第17章-垃圾回收器","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC17%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/","content":"<h1 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h1><h2 id=\"GC分类与性能指标\"><a href=\"#GC分类与性能指标\" class=\"headerlink\" title=\"GC分类与性能指标\"></a>GC分类与性能指标</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p>\n<p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p>\n<p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p>\n<blockquote>\n<p>Java不同版本新特性</p>\n<ul>\n<li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum</li>\n<li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li>\n<li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化</li>\n</ul>\n</blockquote>\n<h3 id=\"垃圾收集器分类\"><a href=\"#垃圾收集器分类\" class=\"headerlink\" title=\"垃圾收集器分类\"></a>垃圾收集器分类</h3><h4 id=\"按线程数分\"><a href=\"#按线程数分\" class=\"headerlink\" title=\"按线程数分\"></a><strong>按线程数分</strong></h4><p><strong>按线程数分</strong>（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/N]M15U1DDGF2WQA7GV.png\"></p>\n<p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>\n<ul>\n<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li>\n<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>\n</ul>\n<p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。</p>\n<h4 id=\"按工作模式分\"><a href=\"#按工作模式分\" class=\"headerlink\" title=\"按工作模式分\"></a>按工作模式分</h4><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p>\n<ul>\n<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>\n<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/IS1]N%3YYY[KJ8FVN.png\"></p>\n<h4 id=\"按碎片处理方式分\"><a href=\"#按碎片处理方式分\" class=\"headerlink\" title=\"按碎片处理方式分\"></a>按碎片处理方式分</h4><p>按碎片处理方式分，可分为压缩武垃圾回收器和非压缩式垃圾回收器。</p>\n<ul>\n<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>\n<li>非压缩式的垃圾回收器不进行这步操作。</li>\n</ul>\n<p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p>\n<h3 id=\"评估GC的性能指标\"><a href=\"#评估GC的性能指标\" class=\"headerlink\" title=\"评估GC的性能指标\"></a>评估GC的性能指标</h3><ul>\n<li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li>\n<li><strong>垃圾收集开销</strong>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>\n<li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li>\n<li><strong>收集频率</strong>：相对于应用程序的执行，收集操作发生的频率。</li>\n<li><strong>内存占用</strong>：Java堆区所占的内存大小。</li>\n<li><strong>快速</strong>：一个对象从诞生到被回收所经历的时间。</li>\n</ul>\n<p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p>\n<p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：</p>\n<ul>\n<li>吞吐量</li>\n<li>暂停时间</li>\n</ul>\n<h3 id=\"性能指标：吞吐量\"><a href=\"#性能指标：吞吐量\" class=\"headerlink\" title=\"性能指标：吞吐量\"></a>性能指标：吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p>\n<blockquote>\n<p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>\n</blockquote>\n<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>\n<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=e.4</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/7MQSZGJJCTLRI5QK%7BA.png\"></p>\n<h3 id=\"性能指标：暂停时间\"><a href=\"#性能指标：暂停时间\" class=\"headerlink\" title=\"性能指标：暂停时间\"></a>性能指标：暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让Gc线程执行的状态</p>\n<p>例如，GC期间1ee毫秒的暂停时间意味着在这1e0毫秒期间内没有应用程序线程是活动的。暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/B~7FONX2%7DI9P9BATLKW8.png\"></p>\n<h3 id=\"吞吐量vs暂停时间\"><a href=\"#吞吐量vs暂停时间\" class=\"headerlink\" title=\"吞吐量vs暂停时间\"></a>吞吐量vs暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>\n<p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p>\n<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>\n<p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</p>\n<p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>\n<p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>\n<p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p>\n<h2 id=\"不同的垃圾回收器概述\"><a href=\"#不同的垃圾回收器概述\" class=\"headerlink\" title=\"不同的垃圾回收器概述\"></a>不同的垃圾回收器概述</h2><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p>\n<p>那么，Java常见的垃圾收集器有哪些？</p>\n<blockquote>\n<p>GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别</p>\n</blockquote>\n<h3 id=\"垃圾回收器发展史\"><a href=\"#垃圾回收器发展史\" class=\"headerlink\" title=\"垃圾回收器发展史\"></a>垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p>\n<ul>\n<li>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>\n<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li>\n<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>\n<li>2012年，在JDK1.7u4版本中，G1可用。</li>\n<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>\n<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>\n<li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>\n<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·2019年9月，JDK13发布。增强zGC，自动返回未用堆内存给操作系统。</li>\n<li>2020年3月，JDK14发布。删除cMs垃圾回收器。扩展zGC在macos和Windows上的应用</li>\n</ul>\n<h3 id=\"7种经典的垃圾收集器\"><a href=\"#7种经典的垃圾收集器\" class=\"headerlink\" title=\"7种经典的垃圾收集器\"></a>7种经典的垃圾收集器</h3><ul>\n<li>串行回收器：Serial、Serial old</li>\n<li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li>\n<li>并发回收器：CMS、G11</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/OKMARNA~XH%7BW7MZA9IYTB.png\"></p>\n<h3 id=\"7款经典收集器与垃圾分代之间的关系\"><a href=\"#7款经典收集器与垃圾分代之间的关系\" class=\"headerlink\" title=\"7款经典收集器与垃圾分代之间的关系\"></a>7款经典收集器与垃圾分代之间的关系</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/ZWTOVW_8L7SP6P923Y5KE.png\"></p>\n<p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p>\n<p>老年代收集器：Serial old、Parallel old、CMS；</p>\n<p>整堆收集器：G1；</p>\n<h3 id=\"垃圾收集器的组合关系\"><a href=\"#垃圾收集器的组合关系\" class=\"headerlink\" title=\"垃圾收集器的组合关系\"></a>垃圾收集器的组合关系</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/A~XFCUZCNITXCV9026.png\"></p>\n<ul>\n<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial 0ld、Parallel Scavenge/Parallel 01d、G1；</li>\n<li>其中Serial o1d作为CMs出现”Concurrent Mode Failure”失败的后备预案。</li>\n<li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li>\n<li>（绿色虚线）JDK14中：弃用Paralle1 Scavenge和Serialold GC组合（JEP366）</li>\n<li>（青色虚线）JDK14中：删除CMs垃圾回收器（JEP363）</li>\n</ul>\n<p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>\n<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p>\n<h3 id=\"如何查看默认垃圾收集器\"><a href=\"#如何查看默认垃圾收集器\" class=\"headerlink\" title=\"如何查看默认垃圾收集器\"></a>如何查看默认垃圾收集器</h3><p>-XX:+PrintcommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p>\n<p>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</p>\n<h2 id=\"Serial回收器：串行回收\"><a href=\"#Serial回收器：串行回收\" class=\"headerlink\" title=\"Serial回收器：串行回收\"></a>Serial回收器：串行回收</h2><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p>\n<p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p>\n<p>Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p>\n<p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p>\n<ul>\n<li>Serial old是运行在Client模式下默认的老年代的垃圾回收器</li>\n<li>Serial 0ld在Server模式下主要有两个用途：<ul>\n<li>与新生代的Parallel scavenge配合使用</li>\n<li>作为老年代CMS收集器的后备垃圾收集方案</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/GSD7NKSGYH57TT.png\"></p>\n<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p>\n<p>优势：简单而高效（与其他收集器的单线程比），对于限定单个cPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>\n<p>运行在client模式下的虚拟机是个不错的选择。</p>\n<p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p>\n<p>在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</p>\n<p>等价于新生代用Serial GC，且老年代用Serial old GC</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p>\n<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p>\n<h2 id=\"ParNew回收器：并行回收\"><a href=\"#ParNew回收器：并行回收\" class=\"headerlink\" title=\"ParNew回收器：并行回收\"></a>ParNew回收器：并行回收</h2><p>如果说serialGC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。</p>\n<ul>\n<li>Par是Parallel的缩写，New：只能处理的是新生代</li>\n</ul>\n<p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”stop-the-World”机制。</p>\n<p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/_TTE%7DHB56HS5GL7AAY.png\"></p>\n<ul>\n<li>对于新生代，回收次数频繁，使用并行方式高效。</li>\n<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li>\n</ul>\n<p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p>\n<ul>\n<li></li>\n</ul>\n<p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p>\n<p>在程序中，开发人员可以通过选项”-XX：+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>\n<p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p>\n<h2 id=\"Parallel回收器：吞吐量优先\"><a href=\"#Parallel回收器：吞吐量优先\" class=\"headerlink\" title=\"Parallel回收器：吞吐量优先\"></a>Parallel回收器：吞吐量优先</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p>\n<p>那么Parallel 收集器的出现是否多此一举？</p>\n<ul>\n<li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li>\n<li>自适应调节策略也是Paralle1 Scavenge与ParNew一个重要区别。</li>\n</ul>\n<p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>\n<p>Paralle1收集器在JDK1.6时提供了用于执行老年代垃圾收集的Paralle1o1d收集器，用来代替老年代的serialold收集器。</p>\n<p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/_B7O9NEA54FRQ7QC5TXD3B5.png\"></p>\n<p>在程序吞吐量优先的应用场景中，IParalle1收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p>\n<h3 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h3><p>-XX：+UseParallelGC 手动指定年轻代使用Paralle1并行收集器执行内存回收任务。</p>\n<p>-XX：+UseParalleloldcc 手动指定老年代都是使用并行回收收集器。</p>\n<ul>\n<li>分别适用于新生代和老年代。默认jdk8是开启的。</li>\n<li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li>\n</ul>\n<p>-XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p>\n<p>在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。</p>\n<p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8]</p>\n<p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。</p>\n<p>为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</p>\n<p>-XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p>\n<p>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1。</p>\n<p>与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p>\n<p>-XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略</p>\n<p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>\n<p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。</p>\n<h2 id=\"CMS回收器：低延迟\"><a href=\"#CMS回收器：低延迟\" class=\"headerlink\" title=\"CMS回收器：低延迟\"></a>CMS回收器：低延迟</h2><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p>\n<p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>\n<p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>\n<p>CMS的垃圾收集算法采用标记-清除算法，并且也会”stop-the-world”</p>\n<p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p>\n<p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/RMP5SXU%60LCJ39J]SM10WB5.png\"></p>\n<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p>\n<ul>\n<li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li>\n<li><strong>并发标记</strong>（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>\n<li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>\n<li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>\n</ul>\n<p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p>\n<p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>\n<p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>\n<p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/1BNK_FGVUB_WK7SVY55_WGX.png\"></p>\n<h3 id=\"CMS为什么不使用标记整理算法？\"><a href=\"#CMS为什么不使用标记整理算法？\" class=\"headerlink\" title=\"CMS为什么不使用标记整理算法？\"></a>CMS为什么不使用标记整理算法？</h3><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world” 这种场景下使用</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>并发收集</li>\n<li>低延迟</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</li>\n<li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>\n<li>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li>\n</ul>\n<h3 id=\"设置的参数\"><a href=\"#设置的参数\" class=\"headerlink\" title=\"设置的参数\"></a>设置的参数</h3><ul>\n<li>-XX：+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。</li>\n</ul>\n<p>开启该参数后会自动将-xx：+UseParNewGC打开。即：ParNew（Young区用）+CMS（01d区用）+Serial old的组合。</p>\n<ul>\n<li>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li>\n</ul>\n<p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次cMs回收。JDK6及以上版本默认值为92%</p>\n<p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p>\n<ul>\n<li>-XX：+UseCMSCompactAtFullCollection用于指定在执行完Ful1</li>\n</ul>\n<p>GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>\n<ul>\n<li>-XX:CMSFullGCsBeforecompaction 设置在执行多少次Ful1GC后对内存空间进行压缩整理。</li>\n<li>-XX:ParallelcMSThreads 设置cMs的线程数量。</li>\n</ul>\n<p>CMs默认启动的线程数是（Paralle1GCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同呢？</p>\n<p>请记住以下口令：</p>\n<ul>\n<li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li>\n<li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li>\n<li>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</li>\n</ul>\n<h3 id=\"JDK后续版本中CMS的变化\"><a href=\"#JDK后续版本中CMS的变化\" class=\"headerlink\" title=\"JDK后续版本中CMS的变化\"></a>JDK后续版本中CMS的变化</h3><p><strong>JDK9新特性</strong>：CMS被标记为eprecate了（JEP291）&gt;如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX： +UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p>\n<p>JDK14新特性：删除CMs垃圾回收器（JEP363）移除了CMS垃圾收集器，如果在JDK14中使用 XX：+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p>\n<h2 id=\"G1回收器：区域化分代式\"><a href=\"#G1回收器：区域化分代式\" class=\"headerlink\" title=\"G1回收器：区域化分代式\"></a>G1回收器：区域化分代式</h2><h3 id=\"既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？\"><a href=\"#既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？\" class=\"headerlink\" title=\"既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？\"></a>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</h3><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>\n<p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>\n<p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p>\n<h3 id=\"为什么名字叫-Garbage-First-G1-呢？\"><a href=\"#为什么名字叫-Garbage-First-G1-呢？\" class=\"headerlink\" title=\"为什么名字叫 Garbage First(G1)呢？\"></a>为什么名字叫 Garbage First(G1)呢？</h3><p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p>\n<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>\n<p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p>\n<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p>\n<p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Paralle1+Parallel old组合。被orac1e官方称为“全功能的垃圾收集器”。</p>\n<p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-xx：+UseG1GC来启用。</p>\n<h3 id=\"G1垃圾收集器的优点\"><a href=\"#G1垃圾收集器的优点\" class=\"headerlink\" title=\"G1垃圾收集器的优点\"></a>G1垃圾收集器的优点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>\n<p><strong>并行与并发</strong></p>\n<ul>\n<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>\n<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>\n</ul>\n<p><strong>分代收集</strong></p>\n<ul>\n<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>\n<li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li>\n<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>\n</ul>\n<p>G1所谓的分代，已经不是下面这样的了</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/3P[T7%1KCYZGWO06R.png\"></p>\n<p>而是这样的一个区域</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/56NMUHZ]7UOR72%60K46.png\"></p>\n<p><strong>空间整合</strong></p>\n<ul>\n<li>CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li>\n<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>\n</ul>\n<p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong> 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>\n<ul>\n<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>\n<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li>\n<li>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>\n</ul>\n<h3 id=\"G1垃圾收集器的缺点\"><a href=\"#G1垃圾收集器的缺点\" class=\"headerlink\" title=\"G1垃圾收集器的缺点\"></a>G1垃圾收集器的缺点</h3><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p>\n<p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p>\n<h3 id=\"G1参数设置\"><a href=\"#G1参数设置\" class=\"headerlink\" title=\"G1参数设置\"></a>G1参数设置</h3><ul>\n<li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li>\n<li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li>\n<li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li>\n<li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li>\n<li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li>\n<li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li>\n</ul>\n<h3 id=\"G1收集器的常见操作步骤\"><a href=\"#G1收集器的常见操作步骤\" class=\"headerlink\" title=\"G1收集器的常见操作步骤\"></a>G1收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>\n<ul>\n<li>第一步：开启G1垃圾收集器</li>\n<li>第二步：设置堆的最大内存</li>\n<li>第三步：设置最大的停顿时间</li>\n</ul>\n<p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Fu11GC，在不同的条件下被触发。</p>\n<h3 id=\"G1收集器的适用场景\"><a href=\"#G1收集器的适用场景\" class=\"headerlink\" title=\"G1收集器的适用场景\"></a>G1收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>\n<p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p>\n<p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于e.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次Gc停顿时间不会过长）。 用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用61可能比CMS好：</p>\n<ul>\n<li>超过5e%的Java堆被活动数据占用；</li>\n<li>对象分配频率或年代提升频率变化很大；</li>\n<li>GC停顿时间过长（长于e.5至1秒）</li>\n</ul>\n<p>HotSpot垃圾收集器里，除了61以外，其他的垃圾收集器使用内置的JVM线程执行Gc的多线程操作，而G1GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>\n<h3 id=\"分区Region：化整为零\"><a href=\"#分区Region：化整为零\" class=\"headerlink\" title=\"分区Region：化整为零\"></a>分区Region：化整为零</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p>\n<p>XX:G1HeapRegionsize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>\n<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/VS]0YB91UFBUF[ZADE.png\"></p>\n<p>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于01d内存区域。图中空白的表示未使用的内存空间。</p>\n<p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p>\n<p><strong>设置H的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Fu11Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p>\n<p>每个Region都是通过指针碰撞来分配空间</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/K[T_8WFESL9F]5HOQ_RO.png\"></p>\n<h3 id=\"G1垃圾回收器的回收过程\"><a href=\"#G1垃圾回收器的回收过程\" class=\"headerlink\" title=\"G1垃圾回收器的回收过程\"></a>G1垃圾回收器的回收过程</h3><p>G1GC的垃圾回收过程主要包括如下三个环节：</p>\n<ul>\n<li>年轻代GC（Young GC）</li>\n<li>老年代并发标记过程（Concurrent Marking）</li>\n<li>混合回收（Mixed GC）</li>\n</ul>\n<p>（如果需要，单线程、独占式、高强度的Fu11GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/XUKFWLQSI7%6053KX0UC.png\"></p>\n<p>顺时针，young gc-&gt;young gc+concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p>\n<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>\n<p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>\n<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>\n<p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>\n<h3 id=\"Remembered-Set（记忆集）\"><a href=\"#Remembered-Set（记忆集）\" class=\"headerlink\" title=\"Remembered Set（记忆集）\"></a>Remembered Set（记忆集）</h3><p>一个对象被不同区域引用的问题</p>\n<p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>\n<p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样的话会降低MinorGC的效率；</p>\n<p><strong>解决方法：</strong></p>\n<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p>\n<p>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p>\n<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/Y5YE1%60NB]E7_BDUAQ.png\"></p>\n<h3 id=\"G1回收过程-年轻代GC\"><a href=\"#G1回收过程-年轻代GC\" class=\"headerlink\" title=\"G1回收过程-年轻代GC\"></a>G1回收过程-年轻代GC</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>\n<p>YGC时，首先G1停止应用程序的执行（stop-The-Wor1d），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/J%60RB02QG%7DAWZN%60CC%60DJW2.png\"></p>\n<p>然后开始如下回收过程：</p>\n<ul>\n<li>第一阶段，扫描根</li>\n</ul>\n<p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>\n<ul>\n<li>第二阶段，更新RSet</li>\n</ul>\n<p>处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p>\n<ul>\n<li>第三阶段，处理RSet</li>\n</ul>\n<p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>\n<ul>\n<li>第四阶段，复制对象。</li>\n</ul>\n<p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>\n<ul>\n<li>第五阶段，处理引用</li>\n</ul>\n<p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>\n<h3 id=\"G1回收过程-并发标记过程\"><a href=\"#G1回收过程-并发标记过程\" class=\"headerlink\" title=\"G1回收过程-并发标记过程\"></a>G1回收过程-并发标记过程</h3><ul>\n<li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC。</li>\n<li>根区域扫描（Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li>\n<li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>\n<li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li>\n<li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是sTw的。这个阶段并不会实际上去做垃圾的收集</li>\n<li>并发清理阶段：识别并清理完全空闲的区域。</li>\n</ul>\n<h3 id=\"G1回收过程-混合回收\"><a href=\"#G1回收过程-混合回收\" class=\"headerlink\" title=\"G1回收过程 - 混合回收\"></a>G1回收过程 - 混合回收</h3><p>当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些o1d Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/R4LUSXGFLS$HNLK9[7U.png\"></p>\n<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</p>\n<p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>\n<p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</p>\n<p>XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>\n<p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为1e%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于1e%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p>\n<h3 id=\"G1回收可选的过程4-Full-GC\"><a href=\"#G1回收可选的过程4-Full-GC\" class=\"headerlink\" title=\"G1回收可选的过程4 - Full GC\"></a>G1回收可选的过程4 - Full GC</h3><p>G1的初衷就是要避免Fu11GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>\n<p>要避免Fu11GC的发生，一旦发生需要进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到ful1gc，这种情况可以通过增大内存解决。 导致61Fu11GC的原因可能有两个：</p>\n<ul>\n<li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li>\n<li>并发处理过程完成之前空间耗尽。</li>\n</ul>\n<h3 id=\"G1回收的优化建议\"><a href=\"#G1回收的优化建议\" class=\"headerlink\" title=\"G1回收的优化建议\"></a>G1回收的优化建议</h3><p>从oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>\n<p>年轻代大小</p>\n<ul>\n<li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li>\n<li>固定年轻代的大小会覆盖</li>\n</ul>\n<p>暂停时间目标暂停时间目标不要太过严苛</p>\n<ul>\n<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>\n<li>评估G1GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>\n</ul>\n<h2 id=\"垃圾回收器总结\"><a href=\"#垃圾回收器总结\" class=\"headerlink\" title=\"垃圾回收器总结\"></a>垃圾回收器总结</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/WSTLW_YMV1Y%7BT3IA%7D4.png\"></p>\n<p>GC发展阶段：Seria l=&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p>\n<p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/LB40PIY%60ZVSQX3PXO0OR.png\"></p>\n<h3 id=\"怎么选择垃圾回收器\"><a href=\"#怎么选择垃圾回收器\" class=\"headerlink\" title=\"怎么选择垃圾回收器\"></a>怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p>\n<ul>\n<li>优先调整堆的大小让JVM自适应完成。</li>\n<li>如果内存小于100M，使用串行收集器</li>\n<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>\n<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>\n<li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>\n<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li>\n</ul>\n<p>最后需要明确一个观点：</p>\n<ul>\n<li>没有最好的收集器，更没有万能的收集</li>\n<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>\n</ul>\n<h3 id=\"面试\"><a href=\"#面试\" class=\"headerlink\" title=\"面试\"></a>面试</h3><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p>\n<p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p>\n<p>垃圾收集器工作的基本流程。</p>\n<p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p>\n<h2 id=\"GC日志分析\"><a href=\"#GC日志分析\" class=\"headerlink\" title=\"GC日志分析\"></a>GC日志分析</h2><p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p>\n<ul>\n<li>-XX:+PrintGc输出GC日志。类似：-verbose:gc</li>\n<li>-XX:+PrintGcDetails输出Gc的详细日志</li>\n<li>-XX:+PrintGcTimestamps 输出Gc的时间戳（以基准时间的形式）</li>\n<li>-XX:+PrintGCDatestamps 输出Gc的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</li>\n<li>-XX:+PrintHeapAtGC在进行Gc的前后打印出堆的信息</li>\n<li>-Xloggc:../logs/gc.1og日志文件的输出路径</li>\n</ul>\n<h3 id=\"verbose-gc\"><a href=\"#verbose-gc\" class=\"headerlink\" title=\"verbose:gc\"></a>verbose:gc</h3><p>打开GC日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-verbose:gc</span><br></pre></td></tr></table></figure>\n\n<p>这个只会显示总的GC堆的变化，如下：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/]N3$N912JUMO8BD.png\"></p>\n<p>参数解析</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/HNX]6VE9OQCDG3M8A7P.png\"></p>\n<h3 id=\"PrintGCDetails\"><a href=\"#PrintGCDetails\" class=\"headerlink\" title=\"PrintGCDetails\"></a>PrintGCDetails</h3><p>打开GC日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-verbose:gc -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>\n\n<p>输入信息如下</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/RUBBOQ2AA8]1OVME6D%WU.png\"></p>\n<p>参数解析</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/TZ45VSF6ZRA6WSSXLUR.png\"></p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ul>\n<li>[GC”和”[Fu11GC”说明了这次垃圾收集的停顿类型，如果有”Fu11”则说明GC发生了”stop The World”</li>\n<li>使用Seria1收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li>\n<li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li>\n<li>使用Paralle1 scavenge收集器在新生代的名字是”[PSYoungGen”</li>\n<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>\n<li>使用G1收集器的话，会显示为”garbage-first heap”</li>\n</ul>\n<p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>\n<p>[PSYoungGen：5986K-&gt;696K（8704K）]5986K-&gt;704K（9216K）中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p>\n<p>user代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过rea1时间</p>\n<h3 id=\"Young-GC图片\"><a href=\"#Young-GC图片\" class=\"headerlink\" title=\"Young GC图片\"></a>Young GC图片</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/192FJ6%3XOMEQQFACOMXVYT.png\"></p>\n<h3 id=\"FullGC图片\"><a href=\"#FullGC图片\" class=\"headerlink\" title=\"FullGC图片\"></a>FullGC图片</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/NK0RH9BJQXLCEC55WUB.png\"></p>\n<h3 id=\"GC回收举例\"><a href=\"#GC回收举例\" class=\"headerlink\" title=\"GC回收举例\"></a>GC回收举例</h3><p>我们编写一个程序，用来说明GC收集的过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GCUseTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer _1MB = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span> [] allocation1, allocation2, allocation3, allocation4;</span><br><span class=\"line\">        allocation1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span> *_1MB];</span><br><span class=\"line\">        allocation2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span> *_1MB];</span><br><span class=\"line\">        allocation3 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">2</span> *_1MB];</span><br><span class=\"line\">        allocation4 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">4</span> *_1MB];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们设置JVM启动参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>\n\n<p>首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/ABTN7NR%60A0R5Q66UGLS.png\"></p>\n<p>然后我们将4M对象存入到Eden区中</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/J2Y5U7%7BL%7BOJWQFT0VF698.png\"></p>\n<p>可以用一些工具去分析这些GC日志</p>\n<p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p>\n<p><strong>GCViewer</strong></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/E9N0RR9BM1DDHK.png\"></p>\n<p><strong>GC easy</strong></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/XV7MASWL0%7BAOMHMME.png\"></p>\n<h2 id=\"垃圾回收器的新发展\"><a href=\"#垃圾回收器的新发展\" class=\"headerlink\" title=\"垃圾回收器的新发展\"></a>垃圾回收器的新发展</h2><p>GC仍然处于飞速发展之中，目前的默认选项G1GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Fu11GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</p>\n<p>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</p>\n<p>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</p>\n<p>Epsilon:A No-Op GarbageCollector（Epsilon垃圾回收器，”No-Op（无操作）”回收器）<a href=\"http://openidk.iava.net/iep\">http://openidk.iava.net/iep</a> s/318</p>\n<p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</p>\n<p>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12）</p>\n<blockquote>\n<p>主打特点：低停顿时间</p>\n</blockquote>\n<h3 id=\"Open-JDK12的Shenandoash-GC\"><a href=\"#Open-JDK12的Shenandoash-GC\" class=\"headerlink\" title=\"Open JDK12的Shenandoash GC\"></a>Open JDK12的Shenandoash GC</h3><p>Open JDK12的shenandoash GC：低停顿时间的GC（实验性）</p>\n<p>Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDk没有区别的Oracle公司仍拒绝在oracleJDK12中支持Shenandoah。</p>\n<p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p>\n<p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/~KEMFXN1Y%7DWB7Q8%7B7N98M5W.png\"></p>\n<p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p>\n<blockquote>\n<p>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。 而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</p>\n</blockquote>\n<p>总结</p>\n<ul>\n<li>shenandoah Gc的弱项：高运行负担下的吞吐量下降。</li>\n<li>shenandoah GC的强项：低延迟时间。</li>\n</ul>\n<h3 id=\"革命性的ZGC\"><a href=\"#革命性的ZGC\" class=\"headerlink\" title=\"革命性的ZGC\"></a>革命性的ZGC</h3><p>zGC与shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p>\n<p>《深入理解Java虚拟机》一书中这样定义zGC：2GC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p>\n<p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p>\n<p>ZGC几乎在所有地方并发执行的，除了初始标记的是STw的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/87PC5H%60LHF022LR23QVY.png\"></p>\n<p>停顿时间对比</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/FB42%7B78C_KFLN36W]YO3.png\"></p>\n<p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/%7B4RYMW9KA1~L5.png\"></p>\n<p>JDK14之前，2GC仅Linux才支持。</p>\n<p>尽管许多使用zGc的用户都使用类Linux的环境，但在Windows和macos上，人们也需要zGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，2GC特性被移植到了Windows和macos上。</p>\n<p>现在mac或Windows上也能使用zGC了，示例如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AliGC\"><a href=\"#AliGC\" class=\"headerlink\" title=\"AliGC\"></a>AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/QI~6IU745Q7J6.png\"></p>\n<p>当然，其它厂商也提供了各种别具一格的GC实现，例如比较有名的低延迟GC Zing</p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"JVM系列-第16章-垃圾回收相关概念","url":"/JVM/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC16%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/","content":"<h1 id=\"垃圾回收相关概念\"><a href=\"#垃圾回收相关概念\" class=\"headerlink\" title=\"垃圾回收相关概念\"></a>垃圾回收相关概念</h1><h2 id=\"System-gc-的理解\"><a href=\"#System-gc-的理解\" class=\"headerlink\" title=\"System.gc()的理解\"></a>System.gc()的理解</h2><p>在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>\n<p>然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p>\n<p>JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p>\n<p>代码演示是否出发GC操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SystemGCTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> SystemGCTest();</span><br><span class=\"line\">        <span class=\"comment\">// 提醒JVM进行垃圾回收</span></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"comment\">//System.runFinalization();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;SystemGCTest 执行了 finalize方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果，但是不一定会触发销毁的方法，调用System.runFinalization()会强制调用 失去引用对象的finalize()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SystemGCTest 执行了 finalize方法</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"手动GC来理解不可达对象的回收\"><a href=\"#手动GC来理解不可达对象的回收\" class=\"headerlink\" title=\"手动GC来理解不可达对象的回收\"></a>手动GC来理解不可达对象的回收</h3><p>代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalVarGC</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">localvarGC1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 触发YoungGC的时候，已经被回收了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">localvarGC2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">        buffer = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 不会被回收，因为它还存放在局部变量表索引为1的槽中</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">localvarGC3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">localvarGC4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = <span class=\"number\">10</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * localvarGC5中的数组已经被回收</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">localvarGC5</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        localvarGC1();</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LocalVarGC localVarGC = <span class=\"keyword\">new</span> LocalVarGC();</span><br><span class=\"line\">        localVarGC.localvarGC3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h2><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>\n<p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现ooM的情况。</p>\n<p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Fu11GC操作，这时候会回收大量的内存，供应用程序继续使用。</p>\n<p>javadoc中对outofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>\n<p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p>\n<ul>\n<li>Java虚拟机的堆内存设置不够。</li>\n</ul>\n<p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</p>\n<ul>\n<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>\n</ul>\n<p>对于老版本的oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</p>\n<p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现ooM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</p>\n<p>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>\n<blockquote>\n<p>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。 在java.nio.BIts.reserveMemory（）方法中，我们能清楚的看到，System.gc（）会被调用，以清理空间。</p>\n</blockquote>\n<p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>\n<p>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</p>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p>\n<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p>\n<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现outofMemory异常，导致程序崩溃。</p>\n<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>\n<blockquote>\n<p>买房子：80平的房子，但是有10平是公摊的面积，我们是无法使用这10平的空间，这就是所谓的内存泄漏</p>\n</blockquote>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/NTTQOYPXBDWREFPV.png\"></p>\n<p>Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><ul>\n<li>单例模式</li>\n</ul>\n<p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>\n<ul>\n<li>一些提供close的资源未关闭导致内存泄漏</li>\n</ul>\n<p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</p>\n<h2 id=\"Stop-The-World\"><a href=\"#Stop-The-World\" class=\"headerlink\" title=\"Stop The World\"></a>Stop The World</h2><p>stop-the-world，简称STw，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>\n<p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p>\n<ul>\n<li>分析工作必须在一个能确保一致性的快照中进行</li>\n<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>\n<li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li>\n</ul>\n<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STw的发生。</p>\n<p>STW事件和采用哪款GC无关所有的GC都有这个事件。</p>\n<p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>\n<p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>\n<p>开发中不要用system.gc() 会导致stop-the-world的发生。</p>\n<h2 id=\"垃圾回收的并行与并发\"><a href=\"#垃圾回收的并行与并发\" class=\"headerlink\" title=\"垃圾回收的并行与并发\"></a>垃圾回收的并行与并发</h2><h3 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>\n<p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/U14BK8Q7Y%60P%60975.png\"></p>\n<h3 id=\"并行\"><a href=\"#并行\" class=\"headerlink\" title=\"并行\"></a>并行</h3><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Paralle1）。</p>\n<p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>\n<p>适合科学计算，后台处理等弱交互场景</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/NO45K~OT4N41V]K.png\"></p>\n<h3 id=\"并发和并行对比\"><a href=\"#并发和并行对比\" class=\"headerlink\" title=\"并发和并行对比\"></a>并发和并行对比</h3><p><strong>并发</strong>，指的是多个事情，在同一时间段内同时发生了。</p>\n<p><strong>并行</strong>，指的是多个事情，在同一时间点上同时发生了。</p>\n<p>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</p>\n<p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。</p>\n<p>否则，看似同时发生的事情，其实都是并发执行的。</p>\n<h3 id=\"垃圾回收的并行与并发-1\"><a href=\"#垃圾回收的并行与并发-1\" class=\"headerlink\" title=\"垃圾回收的并行与并发\"></a>垃圾回收的并行与并发</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>\n<ul>\n<li>并行（Paralle1）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel old；</li>\n<li>串行（Serial）<ul>\n<li>相较于并行的概念，单线程执行。</li>\n<li>如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/FU2LCX7%7B3SN81IF4_2.png\"></p>\n<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>\n<p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。&gt;用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</p>\n<blockquote>\n<p>如：CMS、G1</p>\n</blockquote>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/GV6_DEQS2AYAUAD~9.png\"></p>\n<h2 id=\"安全点与安全区域\"><a href=\"#安全点与安全区域\" class=\"headerlink\" title=\"安全点与安全区域\"></a>安全点与安全区域</h2><h3 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p>\n<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>\n<p>如何在Gc发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>\n<ul>\n<li><strong>抢先式中断</strong>：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>\n<li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li>\n</ul>\n<h3 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于sleep-状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>\n<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>\n<p><strong>执行流程：</strong></p>\n<ul>\n<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li>\n<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li>\n</ul>\n<h2 id=\"再谈引用\"><a href=\"#再谈引用\" class=\"headerlink\" title=\"再谈引用\"></a>再谈引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>\n<p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？ 在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p>\n<ul>\n<li>强引用（Strong Reference）</li>\n<li>软引用（Soft Reference）</li>\n<li>弱引用（Weak Reference）</li>\n<li>虚引用（Phantom Reference）</li>\n</ul>\n<p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.1ang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/CNOQ5[CG0_LLT1Z6.png\"></p>\n<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>\n<ul>\n<li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，==只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象==。</li>\n<li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li>\n<li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>\n<li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。==为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知==。</li>\n</ul>\n<h2 id=\"再谈引用：强引用\"><a href=\"#再谈引用：强引用\" class=\"headerlink\" title=\"再谈引用：强引用\"></a>再谈引用：强引用</h2><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p>\n<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>\n<p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p>\n<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>\n<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p>\n<h3 id=\"举例-1\"><a href=\"#举例-1\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>强引用的案例说明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">StringBuffer str = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">&quot;hello mogublog&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/7D37%60T~6QGR]_10GOPT4.png\"></p>\n<p>如果此时，在运行一个赋值语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">StringBuffer str = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">&quot;hello mogublog&quot;</span>);</span><br><span class=\"line\">StringBuffer str1 = str;</span><br></pre></td></tr></table></figure>\n\n<p>对应的内存结构为:</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/5VBN]PWL17SSFAYTFVBA.png\"></p>\n<p>那么我们将 str = null; 则 原来堆中的对象也不会被回收，因为还有其它对象指向该区域</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>\n<ul>\n<li>强引用可以直接访问目标对象。</li>\n<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li>\n<li>强引用可能导致内存泄漏。</li>\n</ul>\n<h2 id=\"再谈引用：-软引用\"><a href=\"#再谈引用：-软引用\" class=\"headerlink\" title=\"再谈引用： 软引用\"></a>再谈引用： 软引用</h2><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>\n<blockquote>\n<p>注意，这里的第一次回收是不可达的对象</p>\n</blockquote>\n<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>\n<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>\n<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>\n<blockquote>\n<p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</p>\n</blockquote>\n<p>在JDK1.2版之后提供了SoftReference类来实现软引用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明强引用</span></span><br><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"comment\">// 创建一个软引用</span></span><br><span class=\"line\">SoftReference&lt;Object&gt; sf = <span class=\"keyword\">new</span> SoftReference&lt;&gt;(obj);</span><br><span class=\"line\">obj = <span class=\"keyword\">null</span>; <span class=\"comment\">//销毁强引用，这是必须的，不然会存在强引用和软引用</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"再谈引用：弱引用\"><a href=\"#再谈引用：弱引用\" class=\"headerlink\" title=\"再谈引用：弱引用\"></a>再谈引用：弱引用</h2><blockquote>\n<p>发现即回收</p>\n</blockquote>\n<p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>\n<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>\n<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>\n<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>\n<p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明强引用</span></span><br><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"comment\">// 创建一个弱引用</span></span><br><span class=\"line\">WeakReference&lt;Object&gt; sf = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(obj);</span><br><span class=\"line\">obj = <span class=\"keyword\">null</span>; <span class=\"comment\">//销毁强引用，这是必须的，不然会存在强引用和弱引用</span></span><br></pre></td></tr></table></figure>\n\n<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p>\n<p>面试题：你开发中使用过WeakHashMap吗？</p>\n<p>WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM</p>\n<h2 id=\"再谈引用：虚引用\"><a href=\"#再谈引用：虚引用\" class=\"headerlink\" title=\"再谈引用：虚引用\"></a>再谈引用：虚引用</h2><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p>\n<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>\n<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null</p>\n<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>\n<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>\n<p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>\n<blockquote>\n<p>虚引用无法获取到我们的数据</p>\n</blockquote>\n<p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明强引用</span></span><br><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"comment\">// 声明引用队列</span></span><br><span class=\"line\">ReferenceQueue phantomQueue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\"><span class=\"comment\">// 声明虚引用（还需要传入引用队列）</span></span><br><span class=\"line\">PhantomReference&lt;Object&gt; sf = <span class=\"keyword\">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class=\"line\">obj = <span class=\"keyword\">null</span>; </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>我们使用一个案例，来结合虚引用，引用队列，finalize进行讲解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomReferenceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前类对象的声明</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PhantomReferenceTest obj;</span><br><span class=\"line\">    <span class=\"comment\">// 引用队列</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;调用当前类的finalize方法&quot;</span>);</span><br><span class=\"line\">        obj = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (phantomQueue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        e.getStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (objt != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">        thread.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        phantomQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">        obj = <span class=\"keyword\">new</span> PhantomReferenceTest();</span><br><span class=\"line\">        <span class=\"comment\">// 构造了PhantomReferenceTest对象的虚引用，并指定了引用队列</span></span><br><span class=\"line\">        PhantomReference&lt;PhantomReferenceTest&gt; phantomReference = <span class=\"keyword\">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(phantomReference.get());</span><br><span class=\"line\">            <span class=\"comment\">// 去除强引用</span></span><br><span class=\"line\">            obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 第一次进行GC，由于对象可复活，GC无法回收该对象</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第一次GC操作&quot;</span>);</span><br><span class=\"line\">            System.gc();</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obj == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;obj 是 null&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;obj 不是 null&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第二次GC操作&quot;</span>);</span><br><span class=\"line\">            obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            System.gc();</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obj == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;obj 是 null&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;obj 不是 null&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后运行结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">null</span></span><br><span class=\"line\">第一次GC操作</span><br><span class=\"line\">调用当前类的finalize方法</span><br><span class=\"line\">obj 不是 <span class=\"keyword\">null</span></span><br><span class=\"line\">第二次GC操作</span><br><span class=\"line\">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class=\"line\">obj 是 <span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure>\n\n<p>从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次gc，因为会调用finalize方法，将对象复活了，所以对象没有被回收，但是调用第二次gc操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是 将回收的值存入到引用队列中。</p>\n<h2 id=\"终结器引用\"><a href=\"#终结器引用\" class=\"headerlink\" title=\"终结器引用\"></a>终结器引用</h2><p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p>\n<p>无需手动编码，其内部配合引用队列使用</p>\n<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p>\n","categories":["JVM","1.内存与垃圾回收篇"],"tags":["JVM","虚拟机"]},{"title":"开发一个笔记软件","url":"/%E6%80%9D%E8%80%83/%E8%AE%B0%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/","content":"<h1 id=\"开发一个笔记软件\"><a href=\"#开发一个笔记软件\" class=\"headerlink\" title=\"开发一个笔记软件\"></a>开发一个笔记软件</h1><blockquote>\n<p>首先在这里说明以下思考这个标签用于作者平时自己的所感所想 随便记录一下</p>\n</blockquote>\n<h2 id=\"为什么要开发一个笔记软件\"><a href=\"#为什么要开发一个笔记软件\" class=\"headerlink\" title=\"为什么要开发一个笔记软件\"></a>为什么要开发一个笔记软件</h2><p>目前我是一个大三的计算机专业学生，每次都要用电脑区学一些东西但是笔记软件太多以至于我数不过来,我刚开始老师都用的记事本,我发现这东西形同虚设记了等于没记。有时候想看笔记还必要要打开电脑去看笔记,所以我就搭建了一个自己的博客。今天突然想到了为什么不可以开发出来一个手机电脑都可以用的笔记软件的<strong>结构清晰</strong>的笔记软件呢</p>\n<blockquote>\n<p>注:这里的结构清晰指的是逻辑结构 例如目录等</p>\n</blockquote>\n<h2 id=\"自己用笔记软件历程\"><a href=\"#自己用笔记软件历程\" class=\"headerlink\" title=\"自己用笔记软件历程\"></a>自己用笔记软件历程</h2><h3 id=\"一开始用的笔记本记笔记\"><a href=\"#一开始用的笔记本记笔记\" class=\"headerlink\" title=\"一开始用的笔记本记笔记\"></a>一开始用的笔记本记笔记</h3><p>例如这种</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/%60UV%60AB%604IE2VXSTM.png\"></p>\n<p>打开之后</p>\n<img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/JYAPJRM3QTJWM1KGGKJI.png\" style=\"zoom:50%;\" />\n\n<p>这种笔记我就很不喜欢 时间一长自己都不知道第几天讲的什么 当然这里还要提到笔记的作用 可以等等说一下</p>\n<p>我相信如果一个老师如果用这种方式来讲课记笔记,那么他的学生也会感到很痛苦吧。</p>\n<h3 id=\"后面换了mybase\"><a href=\"#后面换了mybase\" class=\"headerlink\" title=\"后面换了mybase\"></a>后面换了mybase</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/BVL8L2GW2HD9M6YBRP.png\"></p>\n<p>这种格式有没有让人看起来很舒服 让人耳目一新,这个记笔记软件是个数据库文件。用起来相当之舒服，这里要感谢我的一个学长给我推荐的这个软件，对我的帮助也很大。不过这样还有一个缺点就是我到晚上睡觉的时候想复习总不能在打开电脑去看吧 后面我就想了自己搭建一个博客</p>\n<h3 id=\"自己搭建一个博客\"><a href=\"#自己搭建一个博客\" class=\"headerlink\" title=\"自己搭建一个博客\"></a>自己搭建一个博客</h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/X9URTOVN~N2FN7NQ6C_J.png\"></p>\n<p>这个博客是通过github和hexo简单的搭建了 刚刚那个不能通过手机访问问题就解决了</p>\n<h3 id=\"markdow-语法\"><a href=\"#markdow-语法\" class=\"headerlink\" title=\"markdow 语法\"></a>markdow 语法</h3><p>markdown语法在我看来是一个很不错很高效的语法,我看b站的视频也有很多的up主在用Typora这款软件来笔记但是同样也解决不了手机访问这个问题</p>\n<h2 id=\"笔记的作用\"><a href=\"#笔记的作用\" class=\"headerlink\" title=\"笔记的作用\"></a>笔记的作用</h2><p>有的笔记只是做一个简单备忘，应该称作备忘录。学习、读书、工作笔记不同，笔记的目的不止备忘，还包括理清、辅助思考、积累…… 深入了解笔记的意义，能够更好的利用笔记，常常能达到事半功倍的效益。</p>\n<p>笔记有以下作用：</p>\n<ul>\n<li>加深记忆、储存备忘。</li>\n<li>捕捉工作、学习、生活中的美好，和自己的思想、灵感。</li>\n<li>通过清晰简明、结构良好的笔记，帮助理清、理解、掌握知识、思想、事情。</li>\n<li>笔记同时也是归纳、整合、条理清晰等能力、习惯锻炼和养成。</li>\n<li>事后，通过笔记就可以快速地概览、重温，是不断地深入理解、记忆、进步的高效方法。</li>\n<li>使用笔记，辅助再次、深入的阅读、复习，以及改进工作。</li>\n<li>重阅笔记，唤醒沉睡的记忆，以及触类旁通。</li>\n</ul>\n<p>可以说，笔记是学习、工作、生活高效的辅助和工具</p>\n<p>上面这些话来自于百度 我认为笔记是特别重要的一个东西 不然学了等于白学 我也是大学的学习中让我认识到笔记重要性。</p>\n<p>我总结的:笔记的作用,在我看来就是整理自己每天所学的，时间长了自己有些知识可能会遗忘,可以快速的查漏补缺</p>\n<h2 id=\"对笔记软件的期许\"><a href=\"#对笔记软件的期许\" class=\"headerlink\" title=\"对笔记软件的期许\"></a>对笔记软件的期许</h2><p>现在是计算机飞速发展的时代,我一个财经的同学都在学c语言，所以我思考能不能开发一个笔记软件，电脑手机都可以去进行读写操作。</p>\n<p>因为每个人都要用电脑和手机 每个人都要学习而笔记软件也成为了我们生活中补课分开的一部分当然这只是一个不成熟的想法。</p>\n","categories":["笔记"],"tags":["思考"]},{"title":"团队精神","url":"/%E6%80%9D%E8%80%83/%E5%9B%A2%E9%98%9F%E7%B2%BE%E7%A5%9E/","content":"<h1 id=\"团队精神\"><a href=\"#团队精神\" class=\"headerlink\" title=\"团队精神\"></a>团队精神</h1><p>为什么要谈这个话题 因为最近读了一本叫做浪潮之巅的书籍 有所思考 首先团队精神是什么呢？</p>\n<p>百度百科中是这样解释的</p>\n<blockquote>\n<p>团队精神是大局意识、协作精神和服务精神的集中体现，核心是协同合作，反映的是个体利益和整体利益的统一，并进而保证组织的高效率运转。 团队精神的形成并不要求团队成员牺牲自我，相反，挥洒个性、表现特长保证了成员共同完成任务目标，而明确的协作意愿和协作方式则产生了真正的内心动力。</p>\n</blockquote>\n<p> 一个团队首先要有一个优秀的领导者，比如IBM的郭士纳,苹果公司的乔布斯,惠普公司的马克赫德。</p>\n<p>优秀的领导者能做什么呢？我认为一个优秀的领导者可以带领你前进的方向，让你的方向正确。我们通常说选择大于努力</p>\n<p>可能也是因为这个吧。</p>\n<blockquote>\n<p>例如现在的it行业培训机构 我认为就是只是培训 而一个行业如果想要做好 不付出是不可能的。大家如果都只是来随便讲讲课</p>\n<p>聊聊天,那么这种培训机构宁愿不要去。老师应该去教会别人怎样去思考,而不是一味的去叫一门技术,难道五年后技术变革之后在</p>\n<p>没人报一个培训班吗？显然不可能</p>\n</blockquote>\n<p> 第二点就是要有“叛逆”精神大家没必要觉得老师说的都是对的,他只不过比我们多学了10几年而已。我们作为二十一实际的年轻人,应该具有思辨性。不应该全部听从老师的,我们应该去多于团队之间的人间交流,进行思维的碰撞。让自己的认知得到提高</p>\n<p>我认为好的团队就是一下几点</p>\n<ul>\n<li>有一个优秀的领导者</li>\n<li>团队氛围(积极的进行思维的交流于碰撞)</li>\n</ul>\n<p>当然这些太过于理想化,如果一个团队有我想象中的这么美好。我相信一定是战无不胜的。</p>\n","categories":["团队"],"tags":["思考"]},{"title":"JUC系列-什么是JUC","url":"/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AFJUC/","content":"<blockquote>\n<p>此篇系列为学习笔记 用于记录学习来自尚硅谷的2021JUC学习教程</p>\n</blockquote>\n<h1 id=\"什么是-JUC\"><a href=\"#什么是-JUC\" class=\"headerlink\" title=\"什么是 JUC\"></a>什么是 JUC</h1><h2 id=\"JUC-简介\"><a href=\"#JUC-简介\" class=\"headerlink\" title=\"JUC 简介\"></a><strong>JUC 简介</strong></h2><p>在 Java 中，线程部分是一个重点，本篇文章说的 JUC 也是关于线程的。JUC就是 java.util .concurrent 工具包的简称。这是一个处理线程的工具包，JDK </p>\n<p>1.5 开始出现的。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/4R5RDNF9PL1YXLZPU4.png\"></p>\n<h2 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a><strong>进程与线程</strong></h2><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>\n<p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>\n<blockquote>\n<p>补充最近出了**协程(coroutine)**：是计算机程序的一类组件，推广了协作式多任务的子例程，允许执行被挂起与被恢复。 相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。 协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无限列表和管道。</p>\n</blockquote>\n<p><strong>总结来说:</strong></p>\n<p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程— —资源分配的最小单位。</p>\n<p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个</p>\n<p>单元执行流。线程——程序执行的最小单位。</p>\n<blockquote>\n<p>协程运行在线程之上<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p>\n</blockquote>\n<h2 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a><strong>线程的状态</strong></h2><h4 id=\"线程状态枚举类\"><a href=\"#线程状态枚举类\" class=\"headerlink\" title=\"线程状态枚举类\"></a><strong>线程状态枚举类</strong></h4><p><strong>Thread.State</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Thread state for a thread which has not yet started.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">NEW,(新建)</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Thread state for a runnable thread. A thread in the runnable</span></span><br><span class=\"line\"><span class=\"comment\">* state is executing in the Java virtual machine but it may</span></span><br><span class=\"line\"><span class=\"comment\">* be waiting for other resources from the operating system</span></span><br><span class=\"line\"><span class=\"comment\">* such as processor.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">RUNNABLE,（准备就绪）</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class=\"line\"><span class=\"comment\">* A thread in the blocked state is waiting for a monitor lock</span></span><br><span class=\"line\"><span class=\"comment\">* to enter a synchronized block/method or</span></span><br><span class=\"line\"><span class=\"comment\">* reenter a synchronized block/method after calling</span></span><br><span class=\"line\"><span class=\"comment\">* &#123;<span class=\"doctag\">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">BLOCKED,（阻塞）</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Thread state for a waiting thread.</span></span><br><span class=\"line\"><span class=\"comment\">* A thread is in the waiting state due to calling one of the</span></span><br><span class=\"line\"><span class=\"comment\">* following methods:</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;li&gt;&#123;<span class=\"doctag\">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;li&gt;&#123;<span class=\"doctag\">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;li&gt;&#123;<span class=\"doctag\">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">** &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class=\"line\"><span class=\"comment\">* perform a particular action.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* on an object is waiting for another thread to call</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class=\"line\"><span class=\"comment\">* that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* is waiting for a specified thread to terminate.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">WAITING,（不见不散）</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Thread state for a waiting thread with a specified waiting time.</span></span><br><span class=\"line\"><span class=\"comment\">* A thread is in the timed waiting state due to calling one of</span></span><br><span class=\"line\"><span class=\"comment\">* the following methods with a specified positive waiting time:</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;li&gt;&#123;<span class=\"doctag\">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;li&gt;&#123;<span class=\"doctag\">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;li&gt;&#123;<span class=\"doctag\">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;li&gt;&#123;<span class=\"doctag\">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;li&gt;&#123;<span class=\"doctag\">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">TIMED_WAITING,（过时不候）</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Thread state for a terminated thread.</span></span><br><span class=\"line\"><span class=\"comment\">* The thread has completed execution.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">TERMINATED;(终结) &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"wait-sleep-的区别\"><a href=\"#wait-sleep-的区别\" class=\"headerlink\" title=\"wait/sleep 的区别\"></a><strong>wait/sleep 的区别</strong></h4><p>（1）sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都</p>\n<p>能调用。</p>\n<p>（2）sleep 不会释放锁，它也不需要占用锁。wait 会释放锁，但调用它的前提</p>\n<p>是当前线程占有锁(即代码要在 synchronized 中)。 </p>\n<p>（3）它们都可以被 interrupted 方法中断。</p>\n<h3 id=\"并发与并行\"><a href=\"#并发与并行\" class=\"headerlink\" title=\"并发与并行\"></a>并发与并行</h3><h4 id=\"串行模式\"><a href=\"#串行模式\" class=\"headerlink\" title=\"串行模式\"></a><strong>串行模式</strong></h4><p>串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步骤，才能进行下一个步骤。</p>\n<p><strong>串行是一次只能取得一个任务，并执行这个任务</strong>。</p>\n<h4 id=\"并行模式\"><a href=\"#并行模式\" class=\"headerlink\" title=\"并行模式\"></a><strong>并行模式</strong></h4><p>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。并行的效率从代码层次上强依赖于多进程/多线程代码，从硬件角度上则依赖于多核 CPU。</p>\n<h4 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h4><p><strong>并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行</strong>。但这不是重点，在描述并发的时候也不会去扣这种字眼是否精确，==并发的重点在于它是一种现象==, ==并发描述的是多进程同时运行的现象==。但实际上，对于单核心 CPU 来说，同一时刻只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占 CPU 的，而是执行一会停一会。</p>\n<p><strong>要解决大并发问题，通常是将大任务分解成多个小任务</strong>, 由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象：</p>\n<p>• 可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用</p>\n<p>队列或类似的数据结构来存放各个小任务的成果</p>\n<p>• 可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或</p>\n<p>异步的方式，比如只有准备好产生了事件通知才执行某个任务。</p>\n<p>• 可以多进程/多线程的方式并行执行这些小任务。也可以单进程/单线程执行这</p>\n<p>些小任务，这时很可能要配合多路复用才能达到较高的效率</p>\n<h4 id=\"小结-重点\"><a href=\"#小结-重点\" class=\"headerlink\" title=\"小结(重点)\"></a><strong>小结(重点)</strong></h4><p><strong>并发：</strong>同一时刻多个线程在访问同一个资源，多个线程对一个点</p>\n<p> 例子：春运抢票 电商秒杀…</p>\n<p><strong>并行：</strong>多项工作一起执行，之后再汇总</p>\n<p> 例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p>\n<h3 id=\"管程\"><a href=\"#管程\" class=\"headerlink\" title=\"管程\"></a><strong>管程</strong></h3><p>管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行</p>\n<p>JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁</p>\n<p>执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行时候会持有管程，其他线程无法再获取同一个管程</p>\n<h3 id=\"用户线程和守护线程\"><a href=\"#用户线程和守护线程\" class=\"headerlink\" title=\"用户线程和守护线程\"></a><strong>用户线程和守护线程</strong></h3><p><strong>用户线程</strong>:平时用到的普通线程,自定义线程</p>\n<p><strong>守护线程</strong>:运行在后台,是一种特殊的线程,比如垃圾回收</p>\n<p><strong>当主线程结束后</strong>,<strong>用户线程还在运行,JVM</strong> <strong>存活</strong></p>\n<p><strong>如果没有用户线程</strong>,<strong>都是守护线程</strong>,<strong>JVM</strong> <strong>结束</strong></p>\n","categories":["JUC"],"tags":["多线程","高并发"]},{"title":"JUC系列-线程间通信","url":"/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","content":"<h1 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h1><p>线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模</p>\n<p>型来实现的。我们来基本一道面试常见的题目来分析</p>\n<p><strong>场景—两个线程，一个线程对当前数值加 1，另一个线程对当前数值减 1,要求</strong></p>\n<p><strong>用线程间通信</strong></p>\n<h2 id=\"synchronized-方案\"><a href=\"#synchronized-方案\" class=\"headerlink\" title=\"synchronized 方案\"></a>synchronized 方案</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一步 创建资源类，定义属性和操作方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Share</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> number = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//+1的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">incr</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//第二步 判断 干活 通知</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(number != <span class=\"number\">0</span>) &#123; <span class=\"comment\">//判断number值是否是0，如果不是0，等待</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.wait(); <span class=\"comment\">//在哪里睡，就在哪里醒</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果number值是0，就+1操作</span></span><br><span class=\"line\">        number++;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; :: &quot;</span>+number);</span><br><span class=\"line\">        <span class=\"comment\">//通知其他线程</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//-1的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">decr</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.wait();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//干活</span></span><br><span class=\"line\">        number--;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; :: &quot;</span>+number);</span><br><span class=\"line\">        <span class=\"comment\">//通知其他线程</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDemo1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//第三步 创建多个线程，调用资源类的操作方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Share share = <span class=\"keyword\">new</span> Share();</span><br><span class=\"line\">        <span class=\"comment\">//创建线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;=<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    share.incr(); <span class=\"comment\">//+1</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;AA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;=<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    share.decr(); <span class=\"comment\">//-1</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BB&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>代码截图</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/CW3UWLTRMWP%60GWC0%7BV5.png\"></p>\n<p>如果使用多个线程，添加额外两个线程，且操作要依次执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;=<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            share.incr(); <span class=\"comment\">//+1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,<span class=\"string\">&quot;CC&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;=<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            share.decr(); <span class=\"comment\">//-1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,<span class=\"string\">&quot;DD&quot;</span>).start();</span><br></pre></td></tr></table></figure>\n\n<p>但截图是</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/6IN8QO8WFM~R3NHE330.png\"></p>\n<p>主要是虚拟唤醒导致：如果一个线程执行完毕后，通知其他线程，该线程又进入等待睡眠，可能会因为某些原因被唤醒后，if结构的语句就不会判断了，一直往下执行，所以需要将if换成while结构，每次都判断。因为wait在哪里睡眠就在哪里被唤醒，结果被某个异常唤醒了后回不去了，if结构不会在判断了，需要更改为while</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(number != <span class=\"number\">0</span>) &#123; <span class=\"comment\">//判断number值是否是0，如果不是0，等待</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.wait(); <span class=\"comment\">//在哪里睡，就在哪里醒</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现中断和虚假唤醒是可能的，需要将其while方法用在循环中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">incr</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//上锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (number != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            condition.await();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//干活</span></span><br><span class=\"line\">        number++;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() +<span class=\"string\">&quot;: :&quot;</span> + number);</span><br><span class=\"line\">        <span class=\"comment\">//通知</span></span><br><span class=\"line\">        condition.signalAll();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//解锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lock方案\"><a href=\"#Lock方案\" class=\"headerlink\" title=\"Lock方案\"></a>Lock方案</h2><p>使用lock先要创建锁的对象以及通知的对象<br>放置在资源类中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建Lock</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"keyword\">private</span> Condition condition = lock.newCondition();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上锁<code>lock.lock();</code><br>解锁<code>lock.unlock();</code><br><strong>以下都为condition类：</strong><br>唤醒所有等待的线程<code>signalAll()</code>，带上类名<code>condition.signalAll();</code><br>唤醒一个等待线程<code>signal()</code>，带上类名，<code>condition.signal();</code></p>\n</blockquote>\n<p>造成当前线程在接到信号或者被中断之前一直处于等待状态<code>await()</code>，带上类名，<code>condition.await();</code></p>\n<p>同样是上面的案例题目换成lock<br>比如一个加1操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//+1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">incr</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//上锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (number != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            condition.await();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//干活</span></span><br><span class=\"line\">        number++;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; :: &quot;</span>+number);</span><br><span class=\"line\">        <span class=\"comment\">//通知</span></span><br><span class=\"line\">        condition.signalAll();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//解锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体完整的代码示列<br><strong>一般调用资源类的方法，先调用，在idea中使用快捷键抛出异常</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一步 创建资源类，定义属性和操作方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Share</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> number = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建Lock</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Condition condition = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//+1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">incr</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//上锁</span></span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (number != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                condition.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//干活</span></span><br><span class=\"line\">            number++;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; :: &quot;</span>+number);</span><br><span class=\"line\">            <span class=\"comment\">//通知</span></span><br><span class=\"line\">            condition.signalAll();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//解锁</span></span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//-1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">decr</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(number != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                condition.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            number--;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; :: &quot;</span>+number);</span><br><span class=\"line\">            condition.signalAll();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDemo2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Share share = <span class=\"keyword\">new</span> Share();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;=<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    share.incr();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;AA&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;=<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    share.decr();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BB&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;=<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    share.incr();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;CC&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;=<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    share.decr();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;DD&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["JUC"],"tags":["多线程","高并发"]},{"title":"JUC系列-Lock接口","url":"/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%BA%8C%E7%AB%A0-Lock%E6%8E%A5%E5%8F%A3/","content":"<h1 id=\"Lock接口\"><a href=\"#Lock接口\" class=\"headerlink\" title=\"Lock接口\"></a>Lock接口</h1><h2 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a><strong>Synchronized</strong></h2><h3 id=\"Synchronized-关键字回顾\"><a href=\"#Synchronized-关键字回顾\" class=\"headerlink\" title=\"Synchronized 关键字回顾\"></a><strong>Synchronized 关键字回顾</strong></h3><p>synchronized 是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：</p>\n<ol>\n<li><p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</p>\n</li>\n<li><p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p>\n</li>\n</ol>\n<p>o 虽然可以使用 synchronized 来定义方法，但 synchronized 并不属于方法定</p>\n<p>义的一部分，因此，synchronized 关键字不能被继承。如果在父类中的某个方法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p>\n<ol start=\"3\">\n<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的</li>\n</ol>\n<p>所有对象；</p>\n<ol start=\"4\">\n<li>修改一个类，其作用的范围是 synchronized 后面括号括起来的部分，作用主</li>\n</ol>\n<p>的对象是这个类的所有对象。</p>\n<h3 id=\"售票案例\"><a href=\"#售票案例\" class=\"headerlink\" title=\"售票案例\"></a>售票案例</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ticket</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//票数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> number = <span class=\"number\">30</span>;</span><br><span class=\"line\">    <span class=\"comment\">//操作方法：卖票</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">sale</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断：是否有票</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(number &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; : &quot;</span>+(number--)+<span class=\"string\">&quot; &quot;</span>+number);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果一个代码块被 synchronized 修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p>\n<ul>\n<li><p>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</p>\n</li>\n<li><p>线程执行发生异常，此时 JVM 会让线程自动释放锁。</p>\n</li>\n</ul>\n<p> 那么如果这个获取锁的线程由于要等待 IO 或者其他原因（比如调用 sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过 Lock 就可以办到。</p>\n<h2 id=\"什么是-Lock\"><a href=\"#什么是-Lock\" class=\"headerlink\" title=\"什么是 Lock\"></a><strong>什么是 Lock</strong></h2><p>Lock 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。Lock 提供了比 synchronized 更多的功能。</p>\n<p>Lock 与的 Synchronized 区别</p>\n<p>Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问；</p>\n<p>• Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p>\n<h3 id=\"Lock-接口\"><a href=\"#Lock-接口\" class=\"headerlink\" title=\"Lock 接口\"></a><strong>Lock 接口</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Lock</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\">Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面来逐个讲述 Lock 接口中每个方法的使用</p>\n<h3 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock\"></a>lock</h3><p>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p>\n<p>采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用 Lock 必须在 try{}catch{}块中进行，并且将释放锁的操作放在finally 块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用 Lock来进行同步的话，是以下面这种形式去使用的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Lock lock = ...;</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//处理任务</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception ex)&#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    lock.unlock(); <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"newCondition\"><a href=\"#newCondition\" class=\"headerlink\" title=\"newCondition\"></a>newCondition</h3><p>关键字 synchronized 与 wait()/notify()这两个方法一起使用可以实现等待/通知模式， Lock 锁的 newContition()方法返回 Condition 对象，Condition 类也可以实现等待/通知模式。</p>\n<p>用 notify()通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以进行选择性通知， Condition 比较常用的两个方法：</p>\n<p>• await()会使当前线程等待,同时会释放锁,当其他线程调用 signal()时,线程会重新获得锁并继续执行。</p>\n<p>• signal()用于唤醒一个等待的线程。</p>\n<p>==注意：在调用 Condition 的 await()/signal()方法前，也需要线程持有相关的 Lock 锁，调用 await()后线程会释放这个锁，在 singal()调用后会从当前Condition 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦获得锁成功就继续执行。</p>\n<h2 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h2><p>ReentrantLock，意思是“可重入锁”，关于可重入锁的概念将在后面讲述。</p>\n<p>ReentrantLock 是唯一实现了 Lock 接口的类，并且 ReentrantLock 提供了更多的方法。下面通过一些实例看具体看一下如何使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        final Test test = new Test();</span><br><span class=\"line\">        new Thread()&#123;</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                test.insert(Thread.currentThread());</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">        new Thread()&#123;</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                test.insert(Thread.currentThread());</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void insert(Thread thread) &#123;</span><br><span class=\"line\">        Lock lock = new ReentrantLock(); //注意这个地方</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(thread.getName()+&quot;得到了锁&quot;);</span><br><span class=\"line\">            for(int i=0;i&lt;5;i++) &#123;</span><br><span class=\"line\">                arrayList.add(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">// TODO: handle exception</span><br><span class=\"line\">        &#125;finally &#123;</span><br><span class=\"line\">            System.out.println(thread.getName()+&quot;释放了锁&quot;);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h2><p>ReadWriteLock 也是一个接口，在它里面只定义了两个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ReadWriteLock</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the lock used for reading.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the lock used for reading.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"function\">Lock <span class=\"title\">readLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the lock used for writing.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the lock used for writing.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"function\">Lock <span class=\"title\">writeLock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成 2 个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的<strong>ReentrantReadWriteLock</strong> 实现了 ReadWriteLock 接口。</p>\n<p>ReentrantReadWriteLock 里面提供了很多丰富的方法，不过最主要的有两个</p>\n<p>方法：readLock()和 writeLock()用来获取读锁和写锁。</p>\n<p>下面通过几个例子来看一下 ReentrantReadWriteLock 具体用法。</p>\n<p>假如有多个线程要同时进行读操作的话，先看一下 synchronized 达到的效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantReadWriteLock rwl = <span class=\"keyword\">new</span></span><br><span class=\"line\">            ReentrantReadWriteLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Test test = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                test.get(Thread.currentThread());</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                test.get(Thread.currentThread());</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">(Thread thread)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(System.currentTimeMillis() - start &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(thread.getName()+<span class=\"string\">&quot;正在进行读操作&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(thread.getName()+<span class=\"string\">&quot;读操作完毕&quot;</span>);</span><br><span class=\"line\">    &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>而改成用读写锁的话：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReentrantReadWriteLock rwl = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Test test = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                test.get(Thread.currentThread());</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                test.get(Thread.currentThread());</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">get</span><span class=\"params\">(Thread thread)</span> </span>&#123;</span><br><span class=\"line\">        rwl.readLock().lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(System.currentTimeMillis() - start &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println(thread.getName()+<span class=\"string\">&quot;正在进行读操作&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(thread.getName()+<span class=\"string\">&quot;读操作完毕&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            rwl.readLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>说明 thread1 和 thread2 在同时进行读操作。这样就大大提升了读操作的效率。</p>\n<p>==<strong>注意:</strong>==</p>\n<ul>\n<li><p>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</p>\n</li>\n<li><p> 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p>\n</li>\n</ul>\n<h2 id=\"小结-重点\"><a href=\"#小结-重点\" class=\"headerlink\" title=\"小结(重点)\"></a><strong>小结(重点)</strong></h2><p>Lock 和 synchronized 有以下几点不同：</p>\n<ol>\n<li><p>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；</p>\n</li>\n<li><p>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；</p>\n</li>\n<li><p>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用synchronized 时，等待的线程会一直等待下去，不能够响应中断；</p>\n</li>\n<li><p> 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p>\n</li>\n<li><p>Lock 可以提高多个线程进行读操作的效率。在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时 Lock 的性能要远远优于synchronized。 </p>\n</li>\n</ol>\n","categories":["JUC"],"tags":["多线程","高并发"]},{"title":"JUC系列-多线程锁","url":"/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/","content":"<h1 id=\"多线程锁\"><a href=\"#多线程锁\" class=\"headerlink\" title=\"多线程锁\"></a>多线程锁</h1><h2 id=\"锁的八个问题演示\"><a href=\"#锁的八个问题演示\" class=\"headerlink\" title=\"锁的八个问题演示\"></a><strong>锁的八个问题演示</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Phone</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">sendSMS</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//停留4秒</span></span><br><span class=\"line\">        TimeUnit.SECONDS.sleep(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;------sendSMS&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;------sendEmail&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;------getHello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过调用锁的对象机制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lock_8</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Phone phone = <span class=\"keyword\">new</span> Phone();</span><br><span class=\"line\">        Phone phone2 = <span class=\"keyword\">new</span> Phone();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                phone.sendSMS();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;AA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">               <span class=\"comment\">// phone.sendEmail();</span></span><br><span class=\"line\">               <span class=\"comment\">// phone.getHello();</span></span><br><span class=\"line\">                phone2.sendEmail();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;BB&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>具体八种情况为</p>\n<blockquote>\n<p>1 标准访问，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>2 停4秒在短信方法内，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>3 新增普通的hello方法，是先打短信还是hello<br>——getHello<br>——sendSMS<br>4 现在有两部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS<br>5 两个静态同步方法，1部手机，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>6 两个静态同步方法，2部手机，先打印短信还是邮件<br>——sendSMS<br>——sendEmail<br>7 1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS<br>8 1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS</p>\n</blockquote>\n<p><strong>结论</strong><strong>:</strong></p>\n<p>一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，</p>\n<p>其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized 方法</p>\n<p>锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized 方法</p>\n<p>加个普通方法后发现和同步锁无关</p>\n<p>换成两个对象后，不是同一把锁了，情况立刻变化。</p>\n<p>synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。</p>\n<p><strong>具体表现为以下</strong> <strong>3</strong> <strong>种形式。</strong></p>\n<p><strong>对于普通同步方法，锁是当前实例对象。</strong></p>\n<p><strong>对于静态同步方法，锁是当前类的</strong> <strong>Class</strong> <strong>对象。</strong></p>\n<p><strong>对于同步方法块，锁是</strong> <strong>Synchonized</strong> <strong>括号里配置的对象</strong></p>\n<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，</p>\n<p>可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</p>\n<p>但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p>\n<h2 id=\"公平锁和非公平锁\"><a href=\"#公平锁和非公平锁\" class=\"headerlink\" title=\"公平锁和非公平锁\"></a>公平锁和非公平锁</h2><ul>\n<li><strong>公平锁</strong>：效率相对低</li>\n<li><strong>非公平锁</strong>：效率高，但是线程容易饿死</li>\n</ul>\n<p>通过查看源码<br>带有参数的<code>ReentrantLock(true)</code>为<strong>公平锁</strong><br><code>ReentrantLock(false)</code>为<strong>非公平锁</strong><br>主要是调用<code>NonfairSync()</code>与<code>FairSync()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        sync = <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates an instance of &#123;<span class=\"doctag\">@code</span> ReentrantLock&#125; with the</span></span><br><span class=\"line\"><span class=\"comment\">     * given fairness policy.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> fair &#123;<span class=\"doctag\">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">        sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体其非公平锁与公平锁的源码<br>查看公平锁的源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3000897897090466540L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Acquires only if reentrant or queue is empty.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">initialTryLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   Thread current = Thread.currentThread();</span><br><span class=\"line\">   <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!hasQueuedThreads() &amp;&amp; compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">     setExclusiveOwnerThread(current);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (getExclusiveOwnerThread() == current) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (++c &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class=\"line\">         setState(c);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>通过代码实例具体操作</p>\n<p>在最前面售票代码中<br>继续引用前面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一步  创建资源类，定义属性和和操作方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LTicket</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//票数量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> number = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建可重入锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//卖票方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sale</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//上锁</span></span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断是否有票</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(number &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; ：卖出&quot;</span>+(number--)+<span class=\"string\">&quot; 剩余：&quot;</span>+number);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//解锁</span></span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LSaleTicket</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//第二步 创建多个线程，调用资源类的操作方法</span></span><br><span class=\"line\">    <span class=\"comment\">//创建三个线程</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        LTicket ticket = <span class=\"keyword\">new</span> LTicket();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">40</span>; i++) &#123;</span><br><span class=\"line\">        ticket.sale();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,<span class=\"string\">&quot;AA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">40</span>; i++) &#123;</span><br><span class=\"line\">                ticket.sale();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;BB&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">40</span>; i++) &#123;</span><br><span class=\"line\">                ticket.sale();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;CC&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>都是A线程执行，而BC线程都没执行到，出现了<strong>非公平锁</strong><br>具体改变其设置可以通过可重入锁中的一个有参构造方法</p>\n<p>修改代码为<code>private final ReentrantLock lock = new ReentrantLock(true);</code><br>代码截图为</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/R07HNGWKR.png\"></p>\n<h2 id=\"可重入锁\"><a href=\"#可重入锁\" class=\"headerlink\" title=\"可重入锁\"></a>可重入锁</h2><p>synchronized和lock都是可重入锁</p>\n<ul>\n<li>sychronized是隐式锁，不用手工上锁与解锁，而lock为显示锁，需要手工上锁与解锁</li>\n<li>可重入锁也叫递归锁</li>\n</ul>\n<p>而且有了可重入锁之后，破解第一把之后就可以一直进入到内层结构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object o = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(o) &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; 外层&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (o) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; 中层&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (o) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; 内层&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,<span class=\"string\">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure>\n\n<p><code>synchronized (o)</code>代表锁住当前<code>&#123; &#125;</code>内的代码块</p>\n<p>以上都是synchronized锁机制<br>下面讲解lock锁机制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncLockDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        add();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//Lock演示可重入锁</span></span><br><span class=\"line\">        Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        <span class=\"comment\">//创建线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//上锁</span></span><br><span class=\"line\">                lock.lock();</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; 外层&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//上锁</span></span><br><span class=\"line\">                    lock.lock();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; 内层&quot;</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//释放做</span></span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;t1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建新线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;aaaa&quot;</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;aa&quot;</span>).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在同一把锁中的嵌套锁，内部嵌套锁没解锁还是可以输出，但是如果跳出该线程，执行另外一个线程就会造成死锁<br>要把握上锁与解锁的概念，都要写上</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/16-%E6%AD%BB%E9%94%81.png\"></p>\n<p><strong>产生死锁的原因：</strong></p>\n<ol>\n<li>系统资源不足</li>\n<li>系统资源分配不当</li>\n<li>进程运行顺序不当</li>\n</ol>\n<p><strong>验证是否是死锁</strong></p>\n<ol>\n<li>jps 类似于linux中的<code>ps -ef</code>查看进程号</li>\n<li>jstack 自带的堆栈跟踪工具</li>\n</ol>\n<p>通过用idea自带的命令行输入 <code>jps -l</code><br>查看其编译代码的进程号后<code>jstack 进程号</code></p>\n<p><strong>具体死锁的操作代码实列</strong><br>可理解背下来，大厂面试可考，死锁的简单案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建两个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Object a = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Object b = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (a) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; 持有锁a，试图获取锁b&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (b) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; 获取锁b&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (b) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; 持有锁b，试图获取锁a&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (a) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; 获取锁a&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,<span class=\"string\">&quot;B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["JUC"],"tags":["多线程","高并发"]},{"title":"JUC系列-集合的线程安全","url":"/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%9B%86%E5%90%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","content":"<h1 id=\"集合的线程安全\"><a href=\"#集合的线程安全\" class=\"headerlink\" title=\"集合的线程安全\"></a>集合的线程安全</h1><h2 id=\"集合操作-Demo\"><a href=\"#集合操作-Demo\" class=\"headerlink\" title=\"集合操作 Demo\"></a><strong>集合操作 Demo</strong></h2><p>NotSafeDemo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotSafeDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 多个线程同时对集合进行修改</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">                list.add(UUID.randomUUID().toString());</span><br><span class=\"line\">                System.out.println(list);</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;线程&quot;</span> + i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>异常内容</p>\n<p>java.util.ConcurrentModificationException</p>\n<p><strong>问题: 为什么会出现并发修改异常?</strong></p>\n<p>查看 ArrayList 的 add 方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Appends the specified element to the end of this list.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> e element to be appended to this list</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class=\"doctag\">@link</span> Collection#add&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">\tensureCapacityInternal(size + <span class=\"number\">1</span>); <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">\telementData[size++] = e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>==<strong>那么我们如何去解决 List 类型的线程安全问题?</strong>==</p>\n<h2 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a><strong>Vector</strong></h2><p>Vector 是<strong>矢量队列</strong>，它是 JDK1.0 版本添加的类。继承于 AbstractList，实现了 List, RandomAccess, Cloneable 这些接口。 Vector 继承了 AbstractList，实现了 List；所以，<strong>它是一个队列，支持相关的添加、删除、修改、遍历等功能</strong>。 Vector 实现了 RandmoAccess 接口，即<strong>提供了随机访问功能</strong>。</p>\n<p>RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在Vector 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 Vector 实现了 Cloneable 接口，即实现 clone()函数。它能被克隆。</p>\n<p><strong>==和 ArrayList 不同，Vector 中的操作是线程安全的。==</strong></p>\n<p>NotSafeDemo 代码修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.UUID;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Vector;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 集合线程安全案例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotSafeDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 多个线程同时对集合进行修改</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List list = <span class=\"keyword\">new</span> Vector();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">                list.add(UUID.randomUUID().toString());</span><br><span class=\"line\">                System.out.println(list);</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;线程&quot;</span> + i).start();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>现在没有运行出现并发异常,为什么?</strong></p>\n<p>查看 Vector 的 add 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Appends the specified element to the end of this Vector.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> e element to be appended to this Vector</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; (as specified by &#123;<span class=\"doctag\">@link</span> Collection#add&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@since</span> 1.2</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">\tmodCount++;</span><br><span class=\"line\">\tensureCapacityHelper(elementCount + <span class=\"number\">1</span>);</span><br><span class=\"line\">\telementData[elementCount++] = e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>add 方法被 synchronized 同步修辞,线程安全!因此没有并发异常</strong></p>\n<h2 id=\"Collections\"><a href=\"#Collections\" class=\"headerlink\" title=\"Collections\"></a><strong>Collections</strong></h2><p>Collections 提供了方法 synchronizedList 保证 list 是同步线程安全的</p>\n<p>NotSafeDemo 代码修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 集合线程安全案例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotSafeDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 多个线程同时对集合进行修改</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List list = Collections.synchronizedList(<span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">                list.add(UUID.randomUUID().toString());</span><br><span class=\"line\">                System.out.println(list);</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;线程&quot;</span> + i).start();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没有并发修改异常</p>\n<p>查看方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Returns a synchronized (thread-safe) list backed by the specified</span></span><br><span class=\"line\"><span class=\"comment\">* list. In order to guarantee serial access, it is critical that</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;strong&gt;all&lt;/strong&gt; access to the backing list is accomplished</span></span><br><span class=\"line\"><span class=\"comment\">* through the returned list.&lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* It is imperative that the user manually synchronize on the returned</span></span><br><span class=\"line\"><span class=\"comment\">* list when iterating over it:</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* List list = Collections.synchronizedList(new ArrayList());</span></span><br><span class=\"line\"><span class=\"comment\">* ...</span></span><br><span class=\"line\"><span class=\"comment\">* synchronized (list) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">* Iterator i = list.iterator(); // Must be in synchronized block</span></span><br><span class=\"line\"><span class=\"comment\">* while (i.hasNext())</span></span><br><span class=\"line\"><span class=\"comment\">* foo(i.next());</span></span><br><span class=\"line\"><span class=\"comment\">* &#125;</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">* Failure to follow this advice may result in non-deterministic behavior.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;p&gt;The returned list will be serializable if the specified list is</span></span><br><span class=\"line\"><span class=\"comment\">* serializable.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> &lt;T&gt; the class of the objects in the list</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> list the list to be &quot;wrapped&quot; in a synchronized list.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span> a synchronized view of the specified list.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">synchronizedList</span><span class=\"params\">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (list <span class=\"keyword\">instanceof</span> RandomAccess ?</span><br><span class=\"line\"><span class=\"keyword\">new</span> SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class=\"line\"><span class=\"keyword\">new</span> SynchronizedList&lt;&gt;(list));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"CopyOnWriteArrayList-重点\"><a href=\"#CopyOnWriteArrayList-重点\" class=\"headerlink\" title=\"CopyOnWriteArrayList(重点)\"></a><strong>CopyOnWriteArrayList(重点)</strong></h2><p>首先我们对 CopyOnWriteArrayList 进行学习,其特点如下:</p>\n<p>它相当于线程安全的 ArrayList。和 ArrayList 一样，它是个可变数组；但是和</p>\n<p>ArrayList 不同的时，它具有以下特性：</p>\n<ol>\n<li>它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多</li>\n</ol>\n<p>于可变操作，需要在遍历期间防止线程间的冲突。</p>\n<ol start=\"2\">\n<li><p>它是线程安全的。</p>\n</li>\n<li><p>因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() </p>\n</li>\n</ol>\n<p>等等）的开销很大。</p>\n<ol start=\"4\">\n<li><p>迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。</p>\n</li>\n<li><p>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代</p>\n</li>\n</ol>\n<p>器时，迭代器依赖于不变的数组快照。</p>\n<p><strong>1. 独占锁效率低：采用读写分离思想解决</strong></p>\n<p><strong>2. 写线程获取到锁，其他写线程阻塞</strong></p>\n<p><strong>3. 复制思想</strong></p>\n<p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p>\n<p><strong>这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来</strong></p>\n<p><strong>得及写会内存，其他的线程就会读到了脏数据。</strong></p>\n<p>==<strong>这就是 CopyOnWriteArrayList 的思想和原理。就是拷贝一份。</strong>==</p>\n<p>NotSafeDemo 代码修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 集合线程安全案例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotSafeDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 多个线程同时对集合进行修改</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List list = <span class=\"keyword\">new</span> CopyOnWriteArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">                list.add(UUID.randomUUID().toString());</span><br><span class=\"line\">                System.out.println(list);</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;线程&quot;</span> + i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没有线程安全问题</p>\n<p><strong>原因分析</strong>(<strong>重点</strong>):==<strong>动态数组与线程安全</strong>==</p>\n<p>下面从“动态数组”和“线程安全”两个方面进一步对</p>\n<p>CopyOnWriteArrayList 的原理进行说明。</p>\n<p><strong>“动态数组”机制</strong></p>\n<ul>\n<li>它内部有个“volatile 数组”(array)来保持数据。在“添加/修改/删除”数据</li>\n</ul>\n<p>时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该</p>\n<p>数组赋值给“volatile 数组”, 这就是它叫做 CopyOnWriteArrayList 的原因</p>\n<ul>\n<li><strong>由于它在“添加/修改/删除”数据时，都会新建数组，所以涉及到修改数据的</strong></li>\n</ul>\n<p><strong>操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，</strong></p>\n<p><strong>效率比较高。</strong></p>\n<p><strong>“线程安全”机制</strong></p>\n<ul>\n<li><p>通过 volatile 和互斥锁来实现的。</p>\n</li>\n<li><p>通过“volatile 数组”来保存数据的。一个线程读取 volatile 数组时，总能看</p>\n</li>\n</ul>\n<p>到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了“读</p>\n<p>取到的数据总是最新的”这个机制的保证。</p>\n<ul>\n<li>通过互斥锁来保护数据。在“添加/修改/删除”数据时，会先“获取互斥锁”，</li>\n</ul>\n<p>再修改完毕之后，先将数据更新到“volatile 数组”中，然后再“释放互斥</p>\n<p>锁”，就达到了保护数据的目的。</p>\n<h2 id=\"CopyOnWriteArraySet\"><a href=\"#CopyOnWriteArraySet\" class=\"headerlink\" title=\"CopyOnWriteArraySet\"></a>CopyOnWriteArraySet</h2><p>该类是HashSet的实现类<br>同样使用HashSet类，也会出现线程不安全<br>java Set<String> set = new HashSet&lt;&gt;();<br>需要将上面的代码改为<br>Set<String> set = new CopyOnWriteArraySet&lt;&gt;();</p>\n<p>具体操作代码为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">30</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"comment\">//向集合添加内容</span></span><br><span class=\"line\">        set.add(UUID.randomUUID().toString().substring(<span class=\"number\">0</span>,<span class=\"number\">8</span>));</span><br><span class=\"line\">        <span class=\"comment\">//从集合获取内容</span></span><br><span class=\"line\">        System.out.println(set);</span><br><span class=\"line\">    &#125;,String.valueOf(i)).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code>类是HashMap的实现类<br>先讲述其线程不安全实列</p>\n<p>HashMap不安全线程也同理<code>Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</code><br>具体实现代码是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;<span class=\"number\">30</span>; i++) &#123;</span><br><span class=\"line\">    String key = String.valueOf(i);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"comment\">//向集合添加内容</span></span><br><span class=\"line\">        map.put(key,UUID.randomUUID().toString().substring(<span class=\"number\">0</span>,<span class=\"number\">8</span>));</span><br><span class=\"line\">        <span class=\"comment\">//从集合获取内容</span></span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">    &#125;,String.valueOf(i)).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将其代码修改为<br><code>Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();</code><br>通过这行代码可以编程线程安全</p>\n<h2 id=\"小结-重点\"><a href=\"#小结-重点\" class=\"headerlink\" title=\"小结(重点)\"></a><strong>小结(重点)</strong></h2><p><strong>1.线程安全与线程不安全集合</strong></p>\n<p>集合类型中存在线程安全与线程不安全的两种,常见例如:</p>\n<p>ArrayList —– Vector</p>\n<p>HashMap —–HashTable</p>\n<p>但是以上都是通过 synchronized 关键字实现,效率较低</p>\n<p><strong>2.Collections 构建的线程安全集合</strong></p>\n<p><strong>3.java.util.concurrent 并发包下</strong></p>\n<p>CopyOnWriteArrayList CopyOnWriteArraySet 类型,通过动态数组与线程安</p>\n<p>全个方面保证线程安全</p>\n","categories":["JUC"],"tags":["多线程","高并发"]},{"title":"JUC系列-JUC 三大辅助类","url":"/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%83%E7%AB%A0-JUC-%E4%B8%89%E5%A4%A7%E8%BE%85%E5%8A%A9%E7%B1%BB/","content":"<h1 id=\"JUC-三大辅助类\"><a href=\"#JUC-三大辅助类\" class=\"headerlink\" title=\"JUC 三大辅助类\"></a><strong>JUC 三大辅助类</strong></h1><p>JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时 Lock 锁的频繁操作。这三种辅助类为：</p>\n<p>• CountDownLatch: 减少计数</p>\n<p>• CyclicBarrier: 循环栅栏</p>\n<p>• Semaphore: 信号灯</p>\n<p>下面我们分别进行详细的介绍和学习</p>\n<h2 id=\"减少计数-CountDownLatch\"><a href=\"#减少计数-CountDownLatch\" class=\"headerlink\" title=\"减少计数 CountDownLatch\"></a><strong>减少计数 CountDownLatch</strong></h2><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。</p>\n<ul>\n<li>CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，这</li>\n</ul>\n<p>些线程会阻塞</p>\n<ul>\n<li>其它线程调用 countDown 方法会将计数器减 1(调用 countDown 方法的线程</li>\n</ul>\n<p>不会阻塞) </p>\n<ul>\n<li>当计数器的值变为 0 时，因 await 方法阻塞的线程会被唤醒，继续执行</li>\n</ul>\n<p><strong>场景: 6 个同学陆续离开教室后值班同学才可以关门。</strong></p>\n<p>CountDownLatchDemo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.juc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//演示CountDownLatch</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountDownLatchDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//六个同学陆续离开教室之后,班长锁门</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建CountDownLatch对象m设置初始值</span></span><br><span class=\"line\">        CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"comment\">//六个同学陆续离开教室之后</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName()+ <span class=\"string\">&quot;号同学离开了教室&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//计数</span></span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;,String.valueOf(i)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//等待</span></span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;班长锁门走人了&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环栅栏-CyclicBarrier\"><a href=\"#循环栅栏-CyclicBarrier\" class=\"headerlink\" title=\"循环栅栏 CyclicBarrier\"></a><strong>循环栅栏 CyclicBarrier</strong></h2><p>CyclicBarrier 看英文单词可以看出大概就是循环阻塞的意思，在使用中CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</p>\n<p>该类是一个同步辅助类，允许一组县城互相等到，直到到达某个公共屏障点，在设计一组固定大小的线程的程序中，这些线程必须互相等待，这个类很有用，因为barrier在释放等待线程后可以重用，所以称为循环barrier</p>\n<p>常用的构造方法有：<br>CyclicBarrier(int parties，Runnable barrierAction)创建一个新的CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动barrier时执行给定的屏障操作，该操作由最后一个进入barrier的线程操作</p>\n<p>常用的方法有：</p>\n<blockquote>\n<p>await()在所有的参与者都已 经在此barrier上调用await方法之前一直等待</p>\n</blockquote>\n<p><strong>场景: 集齐 7 颗龙珠就可以召唤神龙</strong></p>\n<p>CyclicBarrierDemo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.juc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//集齐7颗龙珠可以召唤神龙</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建固定值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NUMBER = <span class=\"number\">7</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建CyclicBarrier</span></span><br><span class=\"line\">        CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(NUMBER,()-&gt;&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;集齐7颗龙珠就可以召唤神龙&quot;</span>);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//集齐七颗龙珠过程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">7</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"comment\">//等待</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()+ <span class=\"string\">&quot;星龙珠收集到了&quot;</span>);</span><br><span class=\"line\">                    cyclicBarrier.await();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,String.valueOf(i)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong><br>CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作</p>\n<h2 id=\"信号灯-Semaphore\"><a href=\"#信号灯-Semaphore\" class=\"headerlink\" title=\"信号灯 Semaphore\"></a><strong>信号灯 Semaphore</strong></h2><p>Semaphore 的构造方法中传入的第一个参数是最大信号量（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证。使用 acquire 方法获得许可证，release 方法释放许可</p>\n<p>场景: 抢车位, 6 部汽车 3 个停车位</p>\n<p>SemaphoreDemo</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.juc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Semaphore;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//六辆汽车,停三个停车位</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SemaphoreDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建Semaphore,设置许可数量</span></span><br><span class=\"line\">        Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//模拟六辆汽车</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//抢占</span></span><br><span class=\"line\">                   semaphore.acquire();</span><br><span class=\"line\">                   System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;抢到了车位&quot;</span>);</span><br><span class=\"line\">                   <span class=\"comment\">//设置随机停车时间</span></span><br><span class=\"line\">                   TimeUnit.SECONDS.sleep(<span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">5</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                   System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;------离开了车位&quot;</span>);</span><br><span class=\"line\">               &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                   e.printStackTrace();</span><br><span class=\"line\">               &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//释放</span></span><br><span class=\"line\">                   semaphore.release();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;,String.valueOf(i)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["JUC"],"tags":["多线程","高并发"]},{"title":"JUC系列-阻塞队列","url":"/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","content":"<h1 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a><strong>阻塞队列</strong></h1><h2 id=\"BlockingQueue-简介\"><a href=\"#BlockingQueue-简介\" class=\"headerlink\" title=\"BlockingQueue 简介\"></a><strong>BlockingQueue 简介</strong></h2><p>Concurrent 包中，BlockingQueue 很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了 BlockingQueue 家庭中的所有成员，包括他们各自的功能以及常见使用场景。</p>\n<p>阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/07-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png\"></p>\n<p>当队列是空的，从队列中获取元素的操作将会被阻塞</p>\n<p>当队列是满的，从队列中添加元素的操作将会被阻塞</p>\n<p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</p>\n<p>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</p>\n<p>常用的队列主要有以下两种：</p>\n<ul>\n<li><p>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性</p>\n</li>\n<li><p>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)</p>\n</li>\n</ul>\n<p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p>\n<p>为什么需要 BlockingQueue</p>\n<p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都给你一手包办了</p>\n<p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细</p>\n<p>节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>\n<p>多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和 “消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。</p>\n<ul>\n<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），</li>\n</ul>\n<p>直到有数据放入队列</p>\n<ul>\n<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），</li>\n</ul>\n<p>直到队列中有空的位置，线程被自动唤醒</p>\n<h2 id=\"BlockingQueue-核心方法\"><a href=\"#BlockingQueue-核心方法\" class=\"headerlink\" title=\"BlockingQueue 核心方法\"></a><strong>BlockingQueue 核心方法</strong></h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/2SZZBY7T3L~[P3]YPH.png\"></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/37DFEN2P99JCAYRGAP.png\"></p>\n<p><strong>BlockingQueue 的核心方法</strong>：</p>\n<p><strong>1.放入数据</strong></p>\n<ul>\n<li><p>offer(anObject):表示如果可能的话,将 anObject 加BlockingQueue 里,即如果 BlockingQueue 可以容纳,则返回 true,否则返回 false.<strong>（本方法不阻塞当前执行方法的线程）</strong></p>\n</li>\n<li><p>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败</p>\n</li>\n<li><p>put(anObject):把 anObject 加到 BlockingQueue 里,如果 BlockQueue 没有空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续.</p>\n</li>\n</ul>\n<p><strong>2.获取数据</strong></p>\n<ul>\n<li><p>poll(time): 取走 BlockingQueue 里排在首位的对象,若不能立即取出,<strong>则可以等****time 参数规定的时间,取不到时返回 null</strong></p>\n</li>\n<li><p>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</p>\n</li>\n<li><p>take(): 取走 BlockingQueue 里排在首位的对象,BlockingQueue 为空,<strong>阻断进入等待状态直到 BlockingQueue 有新的数据被加入</strong>; </p>\n</li>\n<li><p>drainTo(): 一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p>\n</li>\n</ul>\n<h2 id=\"入门案例\"><a href=\"#入门案例\" class=\"headerlink\" title=\"入门案例\"></a><strong>入门案例</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.blockingqueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.BlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 阻塞队列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlockingQueueDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// List list = new ArrayList();</span></span><br><span class=\"line\">        BlockingQueue&lt;String&gt; blockingQueue = <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">//第一组</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.add(&quot;a&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.add(&quot;b&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.add(&quot;c&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.element());</span></span><br><span class=\"line\"><span class=\"comment\">//System.out.println(blockingQueue.add(&quot;x&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.remove());</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.remove());</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.remove());</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.remove());</span></span><br><span class=\"line\"><span class=\"comment\">// 第二组</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.offer(&quot;a&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.offer(&quot;b&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.offer(&quot;c&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.offer(&quot;x&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.poll());</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.poll());</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.poll());</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.poll());</span></span><br><span class=\"line\"><span class=\"comment\">// 第三组</span></span><br><span class=\"line\"><span class=\"comment\">// blockingQueue.put(&quot;a&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">// blockingQueue.put(&quot;b&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">// blockingQueue.put(&quot;c&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">// //blockingQueue.put(&quot;x&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.take());</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.take());</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.take());</span></span><br><span class=\"line\"><span class=\"comment\">// System.out.println(blockingQueue.take());</span></span><br><span class=\"line\"><span class=\"comment\">// 第四组</span></span><br><span class=\"line\">        System.out.println(blockingQueue.offer(<span class=\"string\">&quot;a&quot;</span>));</span><br><span class=\"line\">        System.out.println(blockingQueue.offer(<span class=\"string\">&quot;b&quot;</span>));</span><br><span class=\"line\">        System.out.println(blockingQueue.offer(<span class=\"string\">&quot;c&quot;</span>));</span><br><span class=\"line\">        System.out.println(blockingQueue.offer(<span class=\"string\">&quot;a&quot;</span>,<span class=\"number\">3L</span>, TimeUnit.SECONDS));</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见的-BlockingQueue\"><a href=\"#常见的-BlockingQueue\" class=\"headerlink\" title=\"常见的 BlockingQueue\"></a><strong>常见的 BlockingQueue</strong></h2><h3 id=\"ArrayBlockingQueue-常用\"><a href=\"#ArrayBlockingQueue-常用\" class=\"headerlink\" title=\"ArrayBlockingQueue(常用)\"></a><strong>ArrayBlockingQueue(常用)</strong></h3><p>基于数组的阻塞队列实现，在 ArrayBlockingQueue 内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p>\n<p>ArrayBlockingQueue 在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue 完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea 之所以没这样去做，也许是因为 ArrayBlockingQueue 的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue 和LinkedBlockingQueue 间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node 对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC 的影响还是存在一定的区别。而在创建 ArrayBlockingQueue 时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>\n<p><strong>一句话总结: 由数组结构组成的有界阻塞队列。</strong></p>\n<h3 id=\"LinkedBlockingQueue-常用\"><a href=\"#LinkedBlockingQueue-常用\" class=\"headerlink\" title=\"LinkedBlockingQueue(常用)\"></a><strong>LinkedBlockingQueue(常用)</strong></h3><p>基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue 可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>\n<p><strong>ArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</strong></p>\n<p><strong>一句话总结: 由链表结构组成的有界（但大小默认值integer.MAX_VALUE）阻塞队列。</strong></p>\n<h3 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a><strong>DelayQueue</strong></h3><p>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>\n<p><strong>一句话总结: 使用优先级队列实现的延迟无界阻塞队列。</strong></p>\n<h3 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a><strong>PriorityBlockingQueue</strong></h3><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的 Compator 对象来决定），但需要注意的是 PriorityBlockingQueue 并<strong>不会阻塞数据生产者，而****只会在没有可消费的数据时，阻塞数据的消费者</strong>。</p>\n<p>因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费****数据的速度</strong>，否则时间一长，会最终耗尽所有的可用堆内存空间。</p>\n<p>在实现 PriorityBlockingQueue 时，内部控制线程同步的锁采用的是<strong>公平锁</strong>。</p>\n<p><strong>一句话总结: 支持优先级排序的无界阻塞队列。</strong></p>\n<h3 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a><strong>SynchronousQueue</strong></h3><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p>\n<p>声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的行为</p>\n<p><strong>公平模式和非公平模式的区别:</strong> </p>\n<ul>\n<li><p>公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</p>\n</li>\n<li><p>非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>\n</li>\n</ul>\n<p><strong>一句话总结: 不存储元素的阻塞队列，也即单个元素的队列。</strong></p>\n<h3 id=\"LinkedTransferQueue\"><a href=\"#LinkedTransferQueue\" class=\"headerlink\" title=\"LinkedTransferQueue\"></a><strong>LinkedTransferQueue</strong></h3><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和transfer 方法。</p>\n<p>LinkedTransferQueue 采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。</p>\n<p><strong>一句话总结: 由链表组成的无界阻塞队列。</strong></p>\n<h3 id=\"LinkedBlockingDeque\"><a href=\"#LinkedBlockingDeque\" class=\"headerlink\" title=\"LinkedBlockingDeque\"></a><strong>LinkedBlockingDeque</strong></h3><p>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。</p>\n<p>对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况 </p>\n<ul>\n<li><p>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异 常 </p>\n</li>\n<li><p>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</p>\n</li>\n</ul>\n<p><strong>一句话总结: 由链表组成的双向阻塞队列</strong></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h3><p><strong>1. 在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</strong></p>\n<p><strong>2. 为什么需要 BlockingQueue?</strong> 在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给你一手包办了</p>\n","categories":["JUC"],"tags":["多线程","高并发"]},{"title":"JUC系列-读写锁","url":"/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%AF%BB%E5%86%99%E9%94%81/","content":"<h1 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a><strong>读写锁</strong></h1><h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p><strong>回顾悲观锁和乐观锁的概念</strong><br><strong>悲观锁</strong>：单独每个人完成事情的时候，执行上锁解锁。解决并发中的问题，不支持并发操作，只能一个一个操作，效率低<br><strong>乐观锁</strong>：每执行一件事情，都会比较数据版本号，谁先提交，谁先提交版本号</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/05-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.png\"></p>\n<p>新概念：<br>表锁：整个表操作，不会发生死锁<br>行锁：每个表中的单独一行进行加锁，会发生死锁<br>读锁：共享锁（可以有多个人读），会发生死锁<br>写锁：独占锁（只能有一个人写），会发生死锁</p>\n<p>读写锁：一个资源可以被多个读线程访问，也可以被一个写线程访问，但不能同时存在读写线程，读写互斥，读读共享</p>\n<p>读写锁ReentrantReadWriteLock<br>读锁为ReentrantReadWriteLock.ReadLock，readLock()方法<br>写锁为ReentrantReadWriteLock.WriteLock，writeLock()方法</p>\n<p>创建读写锁对象private ReadWriteLock rwLock = new ReentrantReadWriteLock();<br>写锁 加锁 rwLock.writeLock().lock();，解锁为rwLock.writeLock().unlock();<br>读锁 加锁rwLock.readLock().lock();，解锁为rwLock.readLock().unlock();</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/08-%E8%AF%BB%E5%86%99%E9%94%81.png\"></p>\n<h2 id=\"读写锁介绍\"><a href=\"#读写锁介绍\" class=\"headerlink\" title=\"读写锁介绍\"></a><strong>读写锁介绍</strong></h2><p>现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。</p>\n<p>针对这种场景，<strong>JAVA 的并发包提供了读写锁 ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁</strong></p>\n<ol>\n<li>线程进入读锁的前提条件：</li>\n</ol>\n<ul>\n<li><p>没有其他线程的写锁</p>\n</li>\n<li><p>没有写请求, 或者==有写请求，但调用线程和持有锁的线程是同一个(可重入锁)。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>线程进入写锁的前提条件：</li>\n</ol>\n<ul>\n<li><p>没有其他线程的读锁</p>\n</li>\n<li><p>没有其他线程的写锁</p>\n</li>\n</ul>\n<p>而读写锁有以下三个重要的特性：</p>\n<p>（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公</p>\n<p>平优于公平。</p>\n<p>（2）重进入：读锁和写锁都支持线程重进入。</p>\n<p>（3）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为</p>\n<p>读锁。</p>\n<h2 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a><strong>ReentrantReadWriteLock</strong></h2><p>ReentrantReadWriteLock 类的整体结构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantReadWriteLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">ReadWriteLock</span>,</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 读锁 */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class=\"line\">    <span class=\"comment\">/** 写锁 */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 使用默认（非公平）的排序属性创建一个新的</span></span><br><span class=\"line\"><span class=\"comment\">     ReentrantReadWriteLock */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantReadWriteLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantReadWriteLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">        sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">        readerLock = <span class=\"keyword\">new</span> ReadLock(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        writerLock = <span class=\"keyword\">new</span> WriteLock(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** 返回用于写入操作的锁 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ReentrantReadWriteLock.<span class=\"function\">WriteLock <span class=\"title\">writeLock</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span></span><br><span class=\"line\">            writerLock; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 返回用于读取操作的锁 */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ReentrantReadWriteLock.<span class=\"function\">ReadLock <span class=\"title\">readLock</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span></span><br><span class=\"line\">            readerLock; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WriteLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，ReentrantReadWriteLock 实现了 ReadWriteLock 接口，ReadWriteLock 接口定义了获取读锁和写锁的规范，具体需要实现类去实现；同时其还实现了 Serializable 接口，表示可以进行序列化，在源代码中可以看到 ReentrantReadWriteLock 实现了自己的序列化逻辑。</p>\n<h2 id=\"入门案例\"><a href=\"#入门案例\" class=\"headerlink\" title=\"入门案例\"></a><strong>入门案例</strong></h2><p><strong>场景: 使用 ReentrantReadWriteLock 对一个 hashmap 进行读和写操作</strong></p>\n<p>实现案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.readwrite;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//资源类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCache</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建map集合</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建读写锁的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReadWriteLock rwLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//放数据</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String key,Object value)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加写锁</span></span><br><span class=\"line\">        rwLock.writeLock().lock();</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+ <span class=\"string\">&quot;正在写操作&quot;</span> + key);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//暂停一会</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.MILLISECONDS.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">            <span class=\"comment\">//放数据</span></span><br><span class=\"line\">            map.put(key,value);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;写完了&quot;</span> + key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            rwLock.writeLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//取数据</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">get</span><span class=\"params\">(String key)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加读锁</span></span><br><span class=\"line\">        rwLock.readLock().lock();</span><br><span class=\"line\">        Object result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;正在取操作&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//暂停一会</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.MILLISECONDS.sleep(<span class=\"number\">300</span>);</span><br><span class=\"line\">            result = map.get(key);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;取完 &quot;</span> + key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//释放读锁</span></span><br><span class=\"line\">            rwLock.readLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadWriteDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyCache myCache = <span class=\"keyword\">new</span> MyCache();</span><br><span class=\"line\">        <span class=\"comment\">//创建线程放数据</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> num = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">                myCache.put(num+<span class=\"string\">&quot;&quot;</span>,num+<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">            &#125;,String.valueOf(i)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//创建线程取数据</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> num = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">                myCache.get(num+<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">            &#125;,String.valueOf(i)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结-重要\"><a href=\"#小结-重要\" class=\"headerlink\" title=\"小结(重要)\"></a><strong>小结(重要)</strong></h2><ul>\n<li><p>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。 </p>\n</li>\n<li><p>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p>\n</li>\n</ul>\n<p>原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p>\n","categories":["JUC"],"tags":["多线程","高并发"]},{"title":"JUC系列-Callable&Future 接口","url":"/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%85%AD%E7%AB%A0-Callable-Future-%E6%8E%A5%E5%8F%A3/","content":"<h1 id=\"Callable-amp-Future-接口\"><a href=\"#Callable-amp-Future-接口\" class=\"headerlink\" title=\"Callable&amp;Future 接口\"></a><strong>Callable&amp;Future 接口</strong></h1><h2 id=\"Callable-接口\"><a href=\"#Callable-接口\" class=\"headerlink\" title=\"Callable 接口\"></a><strong>Callable 接口</strong></h2><p>目前我们学习了有两种创建线程的方法-一种是通过创建 Thread 类，另一种是通过使用 Runnable 创建线程。但是，Runnable 缺少的一项功能是，当线程终止时（即 run（）完成时），我们无法使线程返回结果。为了支持此功能，</p>\n<p>Java 中提供了 Callable 接口。</p>\n<p>==<strong>现在我们学习的是创建线程的第三种方案—Callable 接口</strong>==</p>\n<p><strong>Callable 接口的特点如下(重点)</strong> </p>\n<ul>\n<li>为了实现 Runnable，需要实现不返回任何内容的 run（）方法，而对于</li>\n</ul>\n<p>Callable，需要实现在完成时返回结果的 call（）方法。</p>\n<ul>\n<li><p> call（）方法可以引发异常，而 run（）则不能。</p>\n</li>\n<li><p>为实现 Callable 而必须重写 call 方法</p>\n</li>\n<li><p>不能直接替换 runnable,因为 Thread 类的构造方法根本没有 Callable</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">创建新类 MyThread1 实现 runnable 接口</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现Callable接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">200</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Future-接口\"><a href=\"#Future-接口\" class=\"headerlink\" title=\"Future 接口\"></a><strong>Future 接口</strong></h2><p>当 call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用 Future 对象。</p>\n<p>将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦Callable 返回）。Future 基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下: </p>\n<p>• <strong>public boolean cancel（boolean mayInterrupt）：</strong>用于停止任务。</p>\n<p>==如果尚未启动，它将停止任务。如果已启动，则仅在 mayInterrupt 为 true时才会中断任务。==</p>\n<p>• <strong>public Object get（）抛出 InterruptedException，ExecutionException：</strong>用于获取任务的结果。</p>\n<p>==如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。</p>\n<p>==</p>\n<p>• <strong>public boolean isDone（）：</strong>如果任务完成，则返回 true，否则返回 false可以看到 Callable 和 Future 做两件事-Callable 与 Runnable 类似，因为它封装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结果。实际上，future 也可以与 Runnable 一起使用。</p>\n<p>要创建线程，需要 Runnable。为了获得结果，需要 future。 </p>\n<h2 id=\"FutureTask\"><a href=\"#FutureTask\" class=\"headerlink\" title=\"FutureTask\"></a><strong>FutureTask</strong></h2><p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建Thread 对象。因此，间接地使用 Callable 创建线程。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/06-futureTask.png\"></p>\n<p><strong>核心原理:(重点)</strong></p>\n<p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成</p>\n<ul>\n<li><p>当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执行状态</p>\n</li>\n<li><p> 一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>\n</li>\n<li><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法</p>\n</li>\n<li><p>一旦计算完成，就不能再重新开始或取消计算</p>\n</li>\n<li><p>get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常</p>\n</li>\n<li><p>get 只计算一次,因此 get 方法放到最后</p>\n</li>\n</ul>\n<p><strong>demo 案例</strong></p>\n<h2 id=\"使用-Callable-和-Future\"><a href=\"#使用-Callable-和-Future\" class=\"headerlink\" title=\"使用 Callable 和 Future\"></a><strong>使用 Callable 和 Future</strong></h2><p>CallableDemo 案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.callable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Callable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.FutureTask;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//比较两个接口</span></span><br><span class=\"line\"><span class=\"comment\">//实现Runnable接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现Callable接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">200</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//Runnable接口创建线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyThread1(),<span class=\"string\">&quot;AA&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Callable接口创建线程</span></span><br><span class=\"line\">        <span class=\"comment\">//new Thread(new MyThread2(),&quot;BB&quot;).start();</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//FutureTask</span></span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask1 = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(<span class=\"keyword\">new</span> MyThread2());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//lam表达式</span></span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask2 = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(() -&gt;&#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;come in callable&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1024</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建一个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(futureTask2,<span class=\"string\">&quot;luck&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!futureTask2.isDone())&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;wait.....&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//调用FutureTask的get方法</span></span><br><span class=\"line\">        System.out.println(futureTask2.get());</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+ <span class=\"string\">&quot;come over&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//FutureTask原理  未来任务</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 1.老师来了,口渴了,去买水不合适,讲课线程继续</span></span><br><span class=\"line\"><span class=\"comment\">         * 单开启线程找班上班长帮我买水,把水买回来,需要时直接get</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 2.4个同学, 1同学 1+2...5 , 2同学 10+11+12...50 3同学 60+61+62， 4同学 100+200</span></span><br><span class=\"line\"><span class=\"comment\">         *  第二个同学计算量比较大,</span></span><br><span class=\"line\"><span class=\"comment\">         *  FutureTask单开启线程给2同学计算,先汇总 1 3 4, 最后等2同学计算位完成,统一汇总</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 3.考试, 做会做的题目,最后看不会做的题目</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 汇总一次</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结-重点\"><a href=\"#小结-重点\" class=\"headerlink\" title=\"小结(重点)\"></a><strong>小结(重点)</strong></h2><ul>\n<li><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成, 当主线程将来需要时，就可以通过 Future对象获得后台作业的计算结果或者执行状态</p>\n</li>\n<li><p>  一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果</p>\n</li>\n<li><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</p>\n</li>\n<li><p> 只计算一次</p>\n</li>\n</ul>\n","categories":["JUC"],"tags":["多线程","高并发"]},{"title":"JUC系列-ThreadPool 线程池","url":"/JUC/JUC%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%8D%81%E7%AB%A0-ThreadPool-%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"<h1 id=\"ThreadPool-线程池\"><a href=\"#ThreadPool-线程池\" class=\"headerlink\" title=\"ThreadPool 线程池\"></a><strong>ThreadPool 线程池</strong></h1><h2 id=\"线程池简介\"><a href=\"#线程池简介\" class=\"headerlink\" title=\"线程池简介\"></a><strong>线程池简介</strong></h2><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p>\n<p>例子： 10 年前单核 CPU 电脑，假的多线程，像马戏团小丑玩多个球，CPU 需要来回切换。 现在是多核电脑，多个线程各自跑在独立的 CPU 上，不用切换效率高</p>\n<p><strong>线程池的优势：</strong> 线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>\n<p><strong>它的主要特点为：</strong></p>\n<ul>\n<li><p>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</p>\n</li>\n<li><p>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</p>\n</li>\n<li><p>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>\n</li>\n<li><p><strong>Java</strong> <strong>中的线程池是通过</strong> <strong>Executor</strong> <strong>框架实现的，该框架中用到了Executor，Executors，ExecutorService</strong>，<strong>ThreadPoolExecutor</strong> <strong>这几个类</strong></p>\n</li>\n</ul>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/NX1E6OPFO~GALUZ2.png\"></p>\n<h2 id=\"线程池参数说明\"><a href=\"#线程池参数说明\" class=\"headerlink\" title=\"线程池参数说明\"></a><strong>线程池参数说明</strong></h2><p>本次介绍 5 种类型的线程池</p>\n<h3 id=\"常用参数-重点\"><a href=\"#常用参数-重点\" class=\"headerlink\" title=\"常用参数(重点)\"></a><strong>常用参数(重点)</strong></h3><ul>\n<li><p>corePoolSize 线程池的核心线程数</p>\n</li>\n<li><p>maximumPoolSize 能容纳的最大线程数</p>\n</li>\n<li><p>keepAliveTime 空闲线程存活时间</p>\n</li>\n<li><p>unit 存活的时间单位</p>\n</li>\n<li><p>workQueue 存放提交但未执行任务的队列</p>\n</li>\n<li><p>threadFactory 创建线程的工厂类</p>\n</li>\n<li><p>handler 等待队列满后的拒绝策略</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/09-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%83%E4%B8%AA%E5%8F%82%E6%95%B0.png\"></p>\n</li>\n</ul>\n<p>线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize -最大线程数</p>\n<p>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p>\n<p>总结起来，也就是一句话，<strong>当提交的任务数大于（workQueue.size() +</strong> <strong>maximumPoolSize ），就会触发线程池的拒绝策略</strong>。</p>\n<h3 id=\"拒绝策略-重点\"><a href=\"#拒绝策略-重点\" class=\"headerlink\" title=\"拒绝策略(重点)\"></a><strong>拒绝策略(重点)</strong></h3><p><strong>CallerRunsPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</p>\n<p><strong>AbortPolicy</strong>: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</p>\n<p><strong>DiscardPolicy</strong>: 直接丢弃，其他啥都没有</p>\n<p><strong>DiscardOldestPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</p>\n<h2 id=\"线程池的种类与创建\"><a href=\"#线程池的种类与创建\" class=\"headerlink\" title=\"线程池的种类与创建\"></a><strong>线程池的种类与创建</strong></h2><h3 id=\"newCachedThreadPool-常用\"><a href=\"#newCachedThreadPool-常用\" class=\"headerlink\" title=\"newCachedThreadPool(常用)\"></a><strong>newCachedThreadPool(常用)</strong></h3><p><strong>作用</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</p>\n<p><strong>特点</strong>: </p>\n<ul>\n<li><p>线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE） </p>\n</li>\n<li><p>线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</p>\n</li>\n<li><p>当线程池中，没有可用线程，会重新创建一个线程</p>\n</li>\n</ul>\n<p><strong>创建方式：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 可缓存线程池</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * corePoolSize 线程池的核心线程数</span></span><br><span class=\"line\"><span class=\"comment\"> * maximumPoolSize 能容纳的最大线程数</span></span><br><span class=\"line\"><span class=\"comment\"> * keepAliveTime 空闲线程存活时间</span></span><br><span class=\"line\"><span class=\"comment\"> * unit 存活的时间单位</span></span><br><span class=\"line\"><span class=\"comment\"> * workQueue 存放提交但未执行任务的队列</span></span><br><span class=\"line\"><span class=\"comment\"> * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>,</span><br><span class=\"line\">            Integer.MAX_VALUE,</span><br><span class=\"line\">            <span class=\"number\">60L</span>,</span><br><span class=\"line\">            TimeUnit.SECONDS,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SynchronousQueue&lt;&gt;(),</span><br><span class=\"line\">            Executors.defaultThreadFactory(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>场景:</strong> 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景</p>\n<h3 id=\"newFixedThreadPool-常用\"><a href=\"#newFixedThreadPool-常用\" class=\"headerlink\" title=\"newFixedThreadPool(常用)\"></a><strong>newFixedThreadPool(常用)</strong></h3><p><strong>作用</strong>：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>\n<p><strong>特征：</strong></p>\n<ul>\n<li><p>线程池中的线程处于一定的量，可以很好的控制线程的并发量</p>\n</li>\n<li><p>线程可以重复被使用，在显示关闭之前，都将一直存在</p>\n</li>\n<li><p>超出一定量的线程被提交时候需在队列中等待</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 固定长度线程池</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * corePoolSize 线程池的核心线程数</span></span><br><span class=\"line\"><span class=\"comment\"> * maximumPoolSize 能容纳的最大线程数</span></span><br><span class=\"line\"><span class=\"comment\"> * keepAliveTime 空闲线程存活时间</span></span><br><span class=\"line\"><span class=\"comment\"> * unit 存活的时间单位</span></span><br><span class=\"line\"><span class=\"comment\"> * workQueue 存放提交但未执行任务的队列</span></span><br><span class=\"line\"><span class=\"comment\"> * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"number\">0L</span>,</span><br><span class=\"line\">            TimeUnit.SECONDS,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class=\"line\">            Executors.defaultThreadFactory(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>场景:</strong> 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景</p>\n<h3 id=\"newSingleThreadExecutor-常用\"><a href=\"#newSingleThreadExecutor-常用\" class=\"headerlink\" title=\"newSingleThreadExecutor(常用)\"></a><strong>newSingleThreadExecutor(常用)</strong></h3><p><strong>作用</strong>：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p>\n<p><strong>特征：</strong> 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行</p>\n<p><strong>创建方式：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 单一线程池</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * corePoolSize 线程池的核心线程数</span></span><br><span class=\"line\"><span class=\"comment\"> * maximumPoolSize 能容纳的最大线程数</span></span><br><span class=\"line\"><span class=\"comment\"> * keepAliveTime 空闲线程存活时间</span></span><br><span class=\"line\"><span class=\"comment\"> * unit 存活的时间单位</span></span><br><span class=\"line\"><span class=\"comment\"> * workQueue 存放提交但未执行任务的队列</span></span><br><span class=\"line\"><span class=\"comment\"> * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">            <span class=\"number\">0L</span>,</span><br><span class=\"line\">            TimeUnit.SECONDS,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class=\"line\">            Executors.defaultThreadFactory(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>场景:</strong> 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景</p>\n<h3 id=\"newScheduleThreadPool-了解\"><a href=\"#newScheduleThreadPool-了解\" class=\"headerlink\" title=\"newScheduleThreadPool(了解)\"></a><strong>newScheduleThreadPool(了解)</strong></h3><p><strong>作用:</strong> 线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池</p>\n<p><strong>特征:</strong> </p>\n<p>（1）线程池中具有指定数量的线程，即便是空线程也将保留 </p>\n<p>（2）可定时或者延迟执行线程活动</p>\n<p><strong>创建方式:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">corePoolSize, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPoolExecutor(corePoolSize, </span><br><span class=\"line\">threadFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>场景:</strong> 适用于需要多个后台线程执行周期任务的场景</p>\n<h3 id=\"newWorkStealingPool\"><a href=\"#newWorkStealingPool\" class=\"headerlink\" title=\"newWorkStealingPool\"></a><strong>newWorkStealingPool</strong></h3><p>jdk1.8 提供的线程池，底层使用的是 ForkJoinPool 实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务</p>\n<p><strong>创建方式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newWorkStealingPool</span><span class=\"params\">(<span class=\"keyword\">int</span> parallelism)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * parallelism：并行级别，通常默认为 JVM 可用的处理器个数</span></span><br><span class=\"line\"><span class=\"comment\"> * factory：用于创建 ForkJoinPool 中使用的线程。</span></span><br><span class=\"line\"><span class=\"comment\"> * handler：用于处理工作线程未处理的异常，默认为 null</span></span><br><span class=\"line\"><span class=\"comment\"> * asyncMode：用于控制 WorkQueue 的工作模式:队列---反队列</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ForkJoinPool(parallelism,</span><br><span class=\"line\">            ForkJoinPool.defaultForkJoinWorkerThreadFactory, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">            <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>场景:</strong> 适用于大耗时，可并行执行的场景</p>\n<h2 id=\"线程池入门案例\"><a href=\"#线程池入门案例\" class=\"headerlink\" title=\"线程池入门案例\"></a><strong>线程池入门案例</strong></h2><p>案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hao.pool;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//自定义线程池的创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadPoolDemo2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ThreadPoolExecutor threadPool = <span class=\"keyword\">new</span> ThreadPoolExecutor(</span><br><span class=\"line\">                <span class=\"number\">2</span>,</span><br><span class=\"line\">                <span class=\"number\">5</span>,</span><br><span class=\"line\">                <span class=\"number\">2L</span>,</span><br><span class=\"line\">                TimeUnit.SECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">3</span>),</span><br><span class=\"line\">                Executors.defaultThreadFactory(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"comment\">//10个顾客请求</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//执行</span></span><br><span class=\"line\">                threadPool.execute(()-&gt;&#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;办理业务&quot;</span>);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//关闭</span></span><br><span class=\"line\">            threadPool.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程池底层工作原理-重要\"><a href=\"#线程池底层工作原理-重要\" class=\"headerlink\" title=\"线程池底层工作原理(重要)\"></a><strong>线程池底层工作原理(重要)</strong></h2><ol>\n<li><p>在创建了线程池后，线程池中的线程数为零</p>\n</li>\n<li><p>当调用 execute()方法添加一个请求任务时，线程池会做出如下判断： </p>\n<p>  2.1 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p>\n</li>\n</ol>\n<p>​         2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p>\n<p>​         2.3 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p>\n<p>​         2.4 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</p>\n<ol start=\"3\">\n<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p>\n</li>\n<li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p>\n</li>\n</ol>\n<p>​        4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。 </p>\n<p>​        4.2 所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/MVHC8Z%60_WAQLC_HX.png\"></p>\n<h2 id=\"注意事项-重要\"><a href=\"#注意事项-重要\" class=\"headerlink\" title=\"注意事项(重要)\"></a><strong>注意事项(重要)</strong></h2><ol>\n<li><p>项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参数，自定义线程池</p>\n</li>\n<li><p>创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建</p>\n</li>\n</ol>\n<p>o corePoolSize 线程池的核心线程数</p>\n<p>o maximumPoolSize 能容纳的最大线程数</p>\n<p>o keepAliveTime 空闲线程存活时间</p>\n<p>o unit 存活的时间单位</p>\n<p>o workQueue 存放提交但未执行任务的队列</p>\n<p>o threadFactory 创建线程的工厂类</p>\n<p>o handler 等待队列满后的拒绝策略</p>\n<ol start=\"3\">\n<li>为什么不允许适用不允许 Executors.的方式手动创建线程池,如下图</li>\n</ol>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/~ZC%7DKX7O11V40S2TZGE.png\"></p>\n","categories":["JUC"],"tags":["多线程","高并发"]},{"title":"MySQL的数据目录","url":"/MySQL/mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/","content":"<blockquote>\n<p> 这份笔记是康师傅的笔记 不得不说康师傅讲的是真好 自己整理这份笔记只是为了更好的复习，MySQL篇都是所以后面就不一一标注了<a href=\"https://www.bilibili.com/video/BV1iq4y1u7vj?p=52&amp;spm_id_from=pageDriver%E8%A7%86%E9%A2%91%E5%9C%A8%E8%BF%99\">https://www.bilibili.com/video/BV1iq4y1u7vj?p=52&amp;spm_id_from=pageDriver视频在这</a></p>\n</blockquote>\n<h1 id=\"MySQL的数据目录\"><a href=\"#MySQL的数据目录\" class=\"headerlink\" title=\"MySQL的数据目录\"></a>MySQL的数据目录</h1><h2 id=\"MySQL8的主要目录结构\"><a href=\"#MySQL8的主要目录结构\" class=\"headerlink\" title=\"MySQL8的主要目录结构\"></a>MySQL8的主要目录结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@atguigu01 ~]# find / -name mysql</span><br></pre></td></tr></table></figure>\n\n<p>安装好MySQL 8之后，我们查看如下的目录结构：</p>\n<h3 id=\"数据库文件的存放路劲\"><a href=\"#数据库文件的存放路劲\" class=\"headerlink\" title=\"数据库文件的存放路劲\"></a>数据库文件的存放路劲</h3><p>MySQL数据库文件的存放路径：/var/lib/mysql/</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;datadir&#x27;; +---------------+-----------------+</span><br><span class=\"line\">| Variable_name | Value | +---------------+-----------------+</span><br><span class=\"line\">| datadir | /var/lib/mysql/ | +---------------+-----------------+</span><br><span class=\"line\">1 row in set (0.04 sec)</span><br></pre></td></tr></table></figure>\n\n<p>从结果中可以看出，在我的计算机上MySQL的数据目录就是 /var/lib/mysql/ 。 </p>\n<h3 id=\"相关命令目录\"><a href=\"#相关命令目录\" class=\"headerlink\" title=\"相关命令目录\"></a>相关命令目录</h3><p>相关命令目录：/usr/bin（mysqladmin、mysqlbinlog、mysqldump等命令）和/usr/sbin。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/awdasda32.png\"></p>\n<h3 id=\"配置文件目录\"><a href=\"#配置文件目录\" class=\"headerlink\" title=\"配置文件目录\"></a>配置文件目录</h3><p><strong>配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）</strong> </p>\n<h2 id=\"数据库和文件系统的关系\"><a href=\"#数据库和文件系统的关系\" class=\"headerlink\" title=\"数据库和文件系统的关系\"></a>数据库和文件系统的关系</h2><h3 id=\"查看默认数据库\"><a href=\"#查看默认数据库\" class=\"headerlink\" title=\"查看默认数据库\"></a>查看默认数据库</h3><p>查看一下在我的计算机上当前有哪些数据库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW DATABASES;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到有4个数据库是属于MySQL自带的系统数据库。</p>\n<ul>\n<li><p>mysql</p>\n<p>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p>\n</li>\n<li><p>information_schema</p>\n</li>\n</ul>\n<p>​    MySQL 系统自带的数据库，这个数据库保存着MySQL服务器 维护的所有其他数据库的信息 ，比如有哪些表、哪些视图、哪些触发          器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为 元数据 。在系统数据库          information_schema 中提供了一些以innodb_sys 开头的表，用于表示内部系统表。</p>\n<figure class=\"highlight gherkin\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; USE information_schema; Database changed mysql&gt; SHOW TABLES LIKE &#x27;innodb_sys%&#x27;; +--------------------------------------------+</span><br><span class=\"line\">|<span class=\"string\"> Tables_in_information_schema (innodb_sys%) </span>|</span><br><span class=\"line\">+--------------------------------------------+</span><br><span class=\"line\">|<span class=\"string\"> INNODB_SYS_DATAFILES </span>|<span class=\"string\"> </span>|<span class=\"string\"> INNODB_SYS_VIRTUAL </span>|<span class=\"string\"> </span>|<span class=\"string\"> INNODB_SYS_INDEXES </span>|<span class=\"string\"> </span>|<span class=\"string\"> INNODB_SYS_TABLES </span>|<span class=\"string\"> </span>|<span class=\"string\"> INNODB_SYS_FIELDS </span>|<span class=\"string\"> </span>|<span class=\"string\"> INNODB_SYS_TABLESPACES </span>|<span class=\"string\"> </span>|<span class=\"string\"> INNODB_SYS_FOREIGN_COLS </span>|<span class=\"string\"> </span>|<span class=\"string\"> INNODB_SYS_COLUMNS </span>|<span class=\"string\"> </span>|<span class=\"string\"> INNODB_SYS_FOREIGN </span>|<span class=\"string\"> </span>|<span class=\"string\"> INNODB_SYS_TABLESTATS </span>|<span class=\"string\"> +--------------------------------------------+</span></span><br><span class=\"line\"><span class=\"string\">10 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>performance_schema </p>\n<p>MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等信息。</p>\n</li>\n<li><p>sys </p>\n<p>MySQL 系统自带的数据库，这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p>\n</li>\n</ul>\n<h3 id=\"表在文件系统中的表示\"><a href=\"#表在文件系统中的表示\" class=\"headerlink\" title=\"表在文件系统中的表示\"></a>表在文件系统中的表示</h3><h4 id=\"InnoDB存储引擎模式\"><a href=\"#InnoDB存储引擎模式\" class=\"headerlink\" title=\"InnoDB存储引擎模式\"></a><strong>InnoDB</strong>存储引擎模式</h4><p><strong>1.</strong> <strong>表结构</strong></p>\n<p>为了保存表结构， InnoDB 在 数据目录 下对应的数据库子目录下创建了一个专门用于 描述表结构的文件 ，文件名是这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">表名.frm</span><br></pre></td></tr></table></figure>\n\n<p>比方说我们在 atguigu 数据库下创建一个名为 test 的表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; USE atguigu; </span><br><span class=\"line\">Database changed </span><br><span class=\"line\">mysql&gt; CREATE TABLE test (</span><br><span class=\"line\">\t-&gt; c1 INT</span><br><span class=\"line\">\t-&gt; );</span><br><span class=\"line\">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>\n\n<p>那在数据库 atguigu 对应的子目录下就会创建一个名为 test.frm 的用于描述表结构的文件。.frm文件的格式在不同的平台上都是相同的。这个后缀名为.frm是以 二进制格式 存储的，我们直接打开是乱码的</p>\n<p><strong>2.</strong> <strong>表中数据和索引</strong></p>\n<p><strong>① 系统表空间</strong>（system tablespace）</p>\n<p>默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应的 系统表空间 在文件系统上的表示。怎么才12M？注意这个文件是 自扩展文件 ，当不够用的时候它会自己增加文件大小。</p>\n<p>当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的 ibdata1 这个文件名难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[server] innodb_data_file_path=data1:512M;data2:512M:autoextend</span><br></pre></td></tr></table></figure>\n\n<p><strong>② 独立表空间</strong>(file-per-table tablespace)</p>\n<p>在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为 每 一个表建立一个独立表空间 ，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个 .ibd 的扩展名而已，所以完整的文件名称长这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">表名.ibd</span><br></pre></td></tr></table></figure>\n\n<p>比如：我们使用了 独立表空间 去存储 atguigu 数据库下的 test 表的话，那么在该表所在数据库对应的 atguigu 目录下会为 test 表创建这两个文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">test.frm </span><br><span class=\"line\">test.ibd</span><br></pre></td></tr></table></figure>\n\n<p>其中 test.ibd 文件就用来存储 test 表中的数据和索引。</p>\n<p><strong>③ 系统表空间与独立表空间的设置</strong></p>\n<p>我们可以自己指定使用 系统表空间 还是 独立表空间 来存储数据，这个功能由启动参数innodb_file_per_table 控制，比如说我们想刻意将表数据都存储到 系统表空间 时，可以在启动MySQL服务器的时候这样配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[server] innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间</span><br></pre></td></tr></table></figure>\n\n<p>默认情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;innodb_file_per_table&#x27;; +-----------------------+-------+</span><br><span class=\"line\">| Variable_name | Value | +-----------------------+-------+</span><br><span class=\"line\">| innodb_file_per_table | ON | +-----------------------+-------+</span><br><span class=\"line\">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>\n\n<p><strong>④ 其他类型的表空间</strong></p>\n<p>随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。</p>\n<h4 id=\"MyISAM存储引擎模式\"><a href=\"#MyISAM存储引擎模式\" class=\"headerlink\" title=\"MyISAM存储引擎模式\"></a><strong>MyISAM</strong>存储引擎模式</h4><p><strong>1.</strong> <strong>表结构</strong></p>\n<p>在存储表结构方面， MyISAM 和 InnoDB 一样，也是在 数据目录 下对应的数据库子目录下创建了一个专门用于描述表结构的文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">表名.frm</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.</strong> <strong>表中数据和索引</strong></p>\n<p>在MyISAM中的索引全部都是 二级索引 ，该存储引擎的 数据和索引是分开存放 的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。假如 test表使用MyISAM存储引擎的话，那么在它所在数据库对应的 atguigu 目录下会为 test 表创建这三个文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">test.frm 存储表结构 </span><br><span class=\"line\">test.MYD 存储数据 (MYData)</span><br><span class=\"line\">test.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure>\n\n<p>举例：创建一个 MyISAM 表，使用 ENGINE 选项显式指定引擎。因为 InnoDB 是默认引擎。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `student_myisam` (</span><br><span class=\"line\">`id` bigint NOT NULL AUTO_INCREMENT, </span><br><span class=\"line\">`name` varchar(64) DEFAULT NULL, </span><br><span class=\"line\">`age` int DEFAULT NULL, </span><br><span class=\"line\">`sex` varchar(2) DEFAULT NULL, </span><br><span class=\"line\">PRIMARY KEY (`id`) </span><br><span class=\"line\">)ENGINE=MYISAM AUTO_INCREMENT=0 DEFAULTCHARSET=utf8mb3;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h4><p>举例： 数据库a ， 表b 。 </p>\n<p>1、如果表b采用 InnoDB ，data\\a中会产生1个或者2个文件：</p>\n<ul>\n<li><p>b.frm ：描述表结构文件，字段长度等</p>\n</li>\n<li><p>如果采用 系统表空间 模式的，数据信息和索引信息都存储在 ibdata1 中</p>\n</li>\n<li><p>如果采用 独立表空间 存储模式，data\\a中还会产生 b.ibd 文件（存储数据信息和索引信息）</p>\n<p>此外：</p>\n</li>\n</ul>\n<p>① MySQL5.7 中会在data/a的目录下生成 db.opt 文件用于保存数据库的相关配置。比如：字符集、比较规则。而MySQL8.0不再提供db.opt文件。</p>\n<p>② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。</p>\n<p>2、如果表b采用 MyISAM ，data\\a中会产生3个文件：</p>\n<ul>\n<li><p>MySQL5.7 中： b.frm ：描述表结构文件，字段长度等。</p>\n<p>MySQL8.0 中 b.xxx.sdi ：描述表结构文件，字段长度等</p>\n</li>\n<li><p>b.MYD (MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式) </p>\n</li>\n<li><p>b.MYI (MYIndex)：存放索引信息文件</p>\n</li>\n</ul>\n","categories":["MySQL高级","数据库"],"tags":["MySQL","数据库"]},{"title":"寒假规划","url":"/%E6%80%9D%E8%80%83/%E5%AF%92%E5%81%87%E8%A7%84%E5%88%92/","content":"<h1 id=\"寒假规划\"><a href=\"#寒假规划\" class=\"headerlink\" title=\"寒假规划\"></a>寒假规划</h1><p>目前欠缺项目经验,前几天面试感觉有些东西记得不够清楚,这段时间复习一下,在学习心得知识,学习MySQL高级,Redis,SpringCloud,以及设计模式,在自己独立做一个项目。</p>\n","categories":["规划"],"tags":["思考"]},{"title":"逻辑架构","url":"/MySQL/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/","content":"<h1 id=\"逻辑架构\"><a href=\"#逻辑架构\" class=\"headerlink\" title=\"逻辑架构\"></a><strong>逻辑架构</strong></h1><h2 id=\"逻辑架构剖析\"><a href=\"#逻辑架构剖析\" class=\"headerlink\" title=\"逻辑架构剖析\"></a><strong>逻辑架构剖析</strong></h2><h3 id=\"服务器处理客户端请求\"><a href=\"#服务器处理客户端请求\" class=\"headerlink\" title=\"服务器处理客户端请求\"></a><strong>服务器处理客户端请求</strong></h3><p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/asdaweawefdsss.png\"></p>\n<p>下面具体展开看一下：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/19W8M1J4XS5G0.png\"></p>\n<h3 id=\"Connectors\"><a href=\"#Connectors\" class=\"headerlink\" title=\"Connectors\"></a><strong>Connectors</strong></h3><p>Connectors,指的是不同语言中与SQL得交互。MySQL首先是一个网络程序,在TCP之上定义了自己得应用层协议。所以要用MySQL,我们可以编写代码,根MySQL Server建立TCP连接,之后按照其定义好的协议进行交互。或者比较方便的方法是调用SDK，比如Native C API，JDBC,PHP等各语言MySQL Connectors,或者通过ODBC。但通过SDK来访问MySQL ，本质上还是在TCP连接上通过MySQL协议根MySQL进行交互。</p>\n<p><strong>接下来MySQL Server结构可以分为如下的三层:</strong></p>\n<h3 id=\"第1层：连接层\"><a href=\"#第1层：连接层\" class=\"headerlink\" title=\"第1层：连接层\"></a><strong>第1层：连接层</strong></h3><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。</p>\n<p>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p>\n<ul>\n<li><p><strong>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</strong></p>\n</li>\n<li><p><strong>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</strong></p>\n</li>\n</ul>\n<p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>\n<h3 id=\"第2层：服务层\"><a href=\"#第2层：服务层\" class=\"headerlink\" title=\"第2层：服务层\"></a><strong>第2层：服务层</strong></h3><ul>\n<li><p><strong>SQL Interface: SQL接口</strong></p>\n<ul>\n<li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface </li>\n<li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li>\n</ul>\n</li>\n<li><p><strong>Parser: 解析器</strong></p>\n<ul>\n<li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li>\n<li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。</li>\n</ul>\n</li>\n<li><p><strong>Optimizer:</strong> <strong>查询优化器</strong></p>\n<ul>\n<li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 。</li>\n<li>这个执行计划表明应该 使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li>\n<li>它使用“ 选取-投影-连接 ”策略进行查询。例如：</li>\n</ul>\n</li>\n</ul>\n<p>​       </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT id,name FROM student WHERE gender = &#x27;女&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p>这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接 起来生成最终查询结果。</p>\n<ul>\n<li><strong>Caches &amp; Buffers： 查询缓存组件</strong><ul>\n<li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端</li>\n<li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li>\n<li>这个查询缓存可以在 不同客户端之间共享 。</li>\n<li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第3层：引擎层\"><a href=\"#第3层：引擎层\" class=\"headerlink\" title=\"第3层：引擎层\"></a><strong>第3层：引擎层</strong></h3><p>插件式存储引擎层（ Storage Engines），<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别</strong>维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>\n<p>MySQL 8.0.25默认支持的存储引擎如下：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/59XUUR45UEI_Z8.png\"></p>\n<h3 id=\"存储层\"><a href=\"#存储层\" class=\"headerlink\" title=\"存储层\"></a><strong>存储层</strong></h3><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h3><p>MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/QR_1IP4IS3L37NT7D27PH.png\"></p>\n<p>简化为三层结构：</p>\n<ol>\n<li><p>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</p>\n</li>\n<li><p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</p>\n</li>\n<li><p>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</p>\n</li>\n</ol>\n<h2 id=\"SQL执行流程\"><a href=\"#SQL执行流程\" class=\"headerlink\" title=\"SQL执行流程\"></a><strong>SQL执行流程</strong></h2><h3 id=\"MySQL-中的-SQL执行流程\"><a href=\"#MySQL-中的-SQL执行流程\" class=\"headerlink\" title=\"MySQL 中的 SQL执行流程\"></a><strong>MySQL</strong> <strong>中的</strong> <strong>SQL执行流程</strong></h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/qwesdfds.png\"></p>\n<p><strong>MySQL的查询流程：</strong></p>\n<p><strong>1.</strong> <strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</p>\n<p><strong>大多数情况查询缓存就是个鸡肋，为什么呢？</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT employee_id,last_name FROM employees WHERE employee_id = 101;</span><br></pre></td></tr></table></figure>\n\n<p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的 鲁棒性大大降 低 ，只有 相同的查询操作才会命中查询缓存 。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。</p>\n<p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW ，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！</p>\n<p>此外，既然是缓存，那就有它 缓存失效的时候 。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了 INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或 DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于 更新压力大的数据库 来说，查询缓存的命中率会非常低。</p>\n<p><strong>2.</strong> <strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/OIP6RMA8ZE1ZEFUO.png\"></p>\n<p>分析器先做“ 词法分析 ”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>\n<p>接着，要做“ 语法分析 ”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输入的这个 SQL 语句是否 满足 MySQL 语法 。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">select department_id,job_id,avg(salary) from employees group by department_id;</span><br></pre></td></tr></table></figure>\n\n<p>如果SQL语句正确，则会生成一个这样的语法树：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/R123123W6UGUM4MK.png\"></p>\n<p><strong>3.</strong> <strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索 ，还是根据 索引检索 等。</p>\n<p>举例：如下语句是执行两个表的 join： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from test1 join test2 using(ID) where test1.name=&#x27;zhangwei&#x27; and test2.name=&#x27;mysql高级课程&#x27;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>方案1：可以先从表 test1 里面取出 name=’zhangwei’的记录的 ID 值，再根据 ID 值关联到表 test2，再判 断 test2 里面 name的值是否等于 ‘mysql高级课程’。 </p>\n<p>方案2：可以先从表 test2 里面取出 name=’mysql高级课程’ 的记录的 ID 值，再根据 ID 值关联到 test1， 再判断 test1 里面 name的值是否等于 zhangwei。 </p>\n<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化 器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。 </p>\n<p>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。</p>\n</blockquote>\n<p>在查询优化器中，可以分为 逻辑查询 优化阶段和 物理查询 优化阶段。</p>\n<p><strong>4.</strong> <strong>执行器</strong>：</p>\n<p>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 执行器阶段 。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/17AGB9PDY8Q.png\"></p>\n<p>在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">select * from test where id=1;</span><br></pre></td></tr></table></figure>\n\n<p>比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>\n<blockquote>\n<p>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 </p>\n<p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p>\n</blockquote>\n<p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。</p>\n<p>SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/Y5126Q%600MXNSVW2R%60QBG7~D.png\"></p>\n<h3 id=\"MySQL8中SQL执行原理\"><a href=\"#MySQL8中SQL执行原理\" class=\"headerlink\" title=\"MySQL8中SQL执行原理\"></a><strong>MySQL8中SQL执行原理</strong></h3><p><strong>1.</strong> <strong>确认profiling是否开启</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; select @@profiling; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show variables like &#x27;profiling&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/asdawraw55.png\"></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/TAEK474]4JGYM8J.png\"></p>\n<p>profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; set profiling=1;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.</strong> <strong>多次执行相同SQL查询</strong></p>\n<p>然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from employees;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.</strong> <strong>查看profiles</strong></p>\n<p>查看当前会话所产生的所有 profiles： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; show profiles; # 显示最近的几次查询</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/86416541adwae.png\"></p>\n<p><strong>4.</strong> <strong>查看profile</strong></p>\n<p>显示执行计划，查看程序的执行步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; show profile;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/8FN6WFL1F5544QW.png\"></p>\n<p>当然你也可以查询指定的 Query ID，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; show profile for query 7;</span><br></pre></td></tr></table></figure>\n\n<p>查询 SQL 的执行时间结果和上面是一样的。</p>\n<p>此外，还可以查询更丰富的内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; show profile cpu,block io for query 6;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/asdawr324234ss.png\"></p>\n<p>继续</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; <span class=\"built_in\">show</span> profile cpu,<span class=\"built_in\">block</span> io <span class=\"keyword\">for</span> query <span class=\"number\">7</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/85QAFXQ94KNLJB.png\"></p>\n<h3 id=\"MySQL5-7中SQL执行原理\"><a href=\"#MySQL5-7中SQL执行原理\" class=\"headerlink\" title=\"MySQL5.7中SQL执行原理\"></a><strong>MySQL5.7中SQL执行原理</strong></h3><p><strong>1.</strong> <strong>配置文件中开启查询缓存</strong> </p>\n<p>在 /etc/my.cnf 中新增一行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">query_cache_type=1</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.</strong> <strong>重启mysql服务</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart mysqld</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.</strong> <strong>开启查询执行计划</strong></p>\n<p>由于重启过服务，需要重新执行如下指令，开启profiling。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; set profiling=1;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.</strong> <strong>执行语句两次：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from locations; </span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from locations;</span><br></pre></td></tr></table></figure>\n\n<p>当 查看profile执行编号2时，比执行编号1时少了很多信息，可以看出查询语句直接从缓存中获取数据 这里就不演示了</p>\n<h3 id=\"SQL语法顺序\"><a href=\"#SQL语法顺序\" class=\"headerlink\" title=\"SQL语法顺序\"></a><strong>SQL语法顺序</strong></h3><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。</p>\n<p>需求：查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息</p>\n<p>下面是经常出现的查询顺序：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/557sdgsdfsdf.png\"></p>\n<h3 id=\"Oracle中的SQL执行流程-了解\"><a href=\"#Oracle中的SQL执行流程-了解\" class=\"headerlink\" title=\"Oracle中的SQL执行流程(了解)\"></a><strong>Oracle中的SQL执行流程(了解)</strong></h3><p>Oracle 中采用了 共享池 来判断 SQL 语句是否存在缓存和执行计划，通过这一步骤我们可以知道应该采用硬解析还是软解析。</p>\n<p>我们先来看下 SQL 在 Oracle 中的执行过程：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/PQPIUJA6QTO1DD5TK2XA.png\"></p>\n<p>从上面这张图中可以看出，SQL 语句在 Oracle 中经历了以下的几个步骤。</p>\n<p><strong>1.语法检查</strong>：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</p>\n<p><strong>2.语义检查</strong>：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</p>\n<p><strong>3.权限检查</strong>：看用户是否具备访问该数据的权限。</p>\n<p><strong>4.共享池检查</strong>：共享池（Shared Pool）是一块内存池，**最主要的作用是缓存 **SQL <strong>语句和该语句的执行计</strong>划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？</p>\n<p>在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算 ，然后根据 Hash 值在库缓存（Library Cache）中查找，如果 存在 SQL 语句的执行计划 ，就直接拿来执行，直接进入“执行器”的环节，这就是 软解析 。</p>\n<p>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是 硬解析 。</p>\n<p><strong>5.优化器</strong>：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</p>\n<p><strong>6.执行器</strong>：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。</p>\n<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要缓存 SQL 语句和执行计划。而 数据字典缓冲区 存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</p>\n<p>库缓存 这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。</p>\n<p>你可能会问，如何避免硬解析，尽量使用软解析呢？在 Oracle 中， 绑定变量 是它的一大特色。绑定变量就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能 提升软解 析的可能性 ，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</p>\n<p>举个例子，我们可以使用下面的查询语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SQL&gt; select * from player where player_id = 10001;</span><br></pre></td></tr></table></figure>\n\n<p>你也可以使用绑定变量，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SQL&gt; select * from player where player_id = :player_id;</span><br></pre></td></tr></table></figure>\n\n<p>这两个查询语句的效率在 Oracle 中是完全不同的。如果你在查询 player_id = 10001 之后，还会查询10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。</p>\n<p>因此，<strong>我们可以通过使用绑定变量来减少硬解析，减少</strong> <strong>Oracle</strong> <strong>的解析工作量。</strong>但是这种方式也有缺点，使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。</p>\n<p><strong>Oracle的架构图：</strong></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/X1TZP9OCWRT29I0M.png\"></p>\n<p><strong>简图：</strong></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/LPFFHLBNWHKB65%60V1T15.png\"></p>\n<p>小结：</p>\n<p>Oracle 和 MySQL 在进行 SQL 的查询上面有软件实现层面的差异。Oracle 提出了共享池的概念，通过共享池来判断是进行软解析，还是硬解析。</p>\n<h2 id=\"数据库缓冲池-buffer-pool\"><a href=\"#数据库缓冲池-buffer-pool\" class=\"headerlink\" title=\"数据库缓冲池(buffer pool)\"></a><strong>数据库缓冲池(buffer pool)</strong></h2><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 占用内存来作为 数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。</p>\n<p>这样做的好处是可以让磁盘活动最小化，从而 减少与磁盘直接进行 I/O 的时间 。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>\n<h3 id=\"缓冲池-vs-查询缓存\"><a href=\"#缓冲池-vs-查询缓存\" class=\"headerlink\" title=\"缓冲池 vs 查询缓存\"></a><strong>缓冲池</strong> <strong>vs</strong> <strong>查询缓存</strong></h3><p><strong>缓冲池和查询缓存是一个东西吗？不是。</strong></p>\n<p><strong>1.</strong> <strong>缓冲池（Buffer Pool）</strong></p>\n<p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。</p>\n<p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种</p>\n<p>数据的缓存，如下图所示：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/STTND03RFB44PGU.png\"></p>\n<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p>\n<p><strong>缓存池的重要性：</strong></p>\n<p><strong>缓存原则：</strong></p>\n<p>“ 位置 * 频次 ”这个原则，可以帮我们对 I/O 访问效率进行优化。</p>\n<p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p>\n<p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 优先对使用频次高 的热数据进行加载 。</p>\n<p><strong>缓冲池的预读特性：</strong></p>\n<p><strong>2.</strong> <strong>查询缓存</strong></p>\n<p>那么什么是查询缓存呢？</p>\n<p>查询缓存是提前把 查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p>\n<h3 id=\"缓冲池如何读取数据\"><a href=\"#缓冲池如何读取数据\" class=\"headerlink\" title=\"缓冲池如何读取数据\"></a><strong>缓冲池如何读取数据</strong></h3><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p>\n<p>缓存在数据库中的结构和作用如下图所示：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/UGRKJJX14ZKTBQ6W4RA.png\"></p>\n<p><strong>如果我们执行</strong> <strong>SQL</strong> <strong>语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</strong> </p>\n<h3 id=\"查看-设置缓冲池的大小\"><a href=\"#查看-设置缓冲池的大小\" class=\"headerlink\" title=\"查看/设置缓冲池的大小\"></a><strong>查看/设置缓冲池的大小</strong></h3><p>如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大小。命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/LAPCFBNOLKR5L1.png\"></p>\n<p>你能看到此时 InnoDB 的缓冲池大小只有 134217728/1024/1024=128MB。我们可以修改缓冲池大小，比如改为256MB，方法如下：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> innodb_buffer_pool_size = <span class=\"number\">268435456</span>;</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[server] </span><br><span class=\"line\">innodb_buffer_pool_size = 268435456</span><br></pre></td></tr></table></figure>\n\n<p>然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB： </p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/12312czsdsa.png\"></p>\n<h3 id=\"多个Buffer-Pool实例\"><a href=\"#多个Buffer-Pool实例\" class=\"headerlink\" title=\"多个Buffer Pool实例\"></a><strong>多个Buffer Pool实例</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[server] </span><br><span class=\"line\">innodb_buffer_pool_instances = 2</span><br></pre></td></tr></table></figure>\n\n<p>这样就表明我们要创建2个 Buffer Pool 实例。</p>\n<p>我们看下如何查看缓冲池的个数，使用命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">show variables like &#x27;innodb_buffer_pool_instances&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p>那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">innodb_buffer_pool_size/innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure>\n\n<p>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p>\n<h3 id=\"引申问题\"><a href=\"#引申问题\" class=\"headerlink\" title=\"引申问题\"></a><strong>引申问题</strong></h3><p>Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。</p>\n<p><strong>黑盒下的更新数据流程</strong></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/12312dffsdfse.png\"></p>\n<p>我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？</p>\n<p>答案：<strong>Redo Log &amp; Undo Log</strong></p>\n<p>这份笔记是康师傅的笔记 不得不说康师傅讲的是真好 写这份笔记只是为了更好的复习<a href=\"https://www.bilibili.com/video/BV1iq4y1u7vj?p=52&amp;spm_id_from=pageDriver%E8%A7%86%E9%A2%91%E5%9C%A8%E8%BF%99\">https://www.bilibili.com/video/BV1iq4y1u7vj?p=52&amp;spm_id_from=pageDriver视频在这</a></p>\n","categories":["MySQL高级","数据库"],"tags":["MySQL","数据库"]},{"title":"存储引擎","url":"/MySQL/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","content":"<h1 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h1><h2 id=\"查看存储引擎\"><a href=\"#查看存储引擎\" class=\"headerlink\" title=\"查看存储引擎\"></a><strong>查看存储引擎</strong></h2><ul>\n<li>查看mysql提供什么存储引擎：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">show engines;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/124134513sdfsdf.png\"></p>\n<h2 id=\"设置系统默认的存储引擎\"><a href=\"#设置系统默认的存储引擎\" class=\"headerlink\" title=\"设置系统默认的存储引擎\"></a><strong>设置系统默认的存储引擎</strong></h2><ul>\n<li>查看默认的存储引擎：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">show variables like &#x27;%storage_engine%&#x27;; </span><br><span class=\"line\">#或</span><br><span class=\"line\">SELECT @@default_storage_engine;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/564564qweqweq.png\"></p>\n<ul>\n<li>修改默认的存储引擎</li>\n</ul>\n<p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SET DEFAULT_STORAGE_ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>\n\n<p>或者修改 my.cnf 文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">default-storage-engine=MyISAM </span><br><span class=\"line\"></span><br><span class=\"line\"># 重启服务 </span><br><span class=\"line\">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设置表的存储引擎\"><a href=\"#设置表的存储引擎\" class=\"headerlink\" title=\"设置表的存储引擎\"></a><strong>设置表的存储引擎</strong></h2><p>存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 不同的表设置不同的存储引擎 ，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p>\n<h3 id=\"创建表时指定存储引擎\"><a href=\"#创建表时指定存储引擎\" class=\"headerlink\" title=\"创建表时指定存储引擎\"></a><strong>创建表时指定存储引擎</strong></h3><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB 。如果我们想显式的指定一下表的存储引擎，那可以这么写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE 表名( </span><br><span class=\"line\">    建表语句; </span><br><span class=\"line\">) ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改表的存储引擎\"><a href=\"#修改表的存储引擎\" class=\"headerlink\" title=\"修改表的存储引擎\"></a>修改表的存储引擎</h3><p>如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER TABLE 表名 ENGINE = 存储引擎名称;</span><br></pre></td></tr></table></figure>\n\n<p>比如我们修改一下 engine_demo_table 表的存储引擎：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; ALTER TABLE engine_demo_table ENGINE =InnoDB; Query OK, 0 rows affected (0.05 sec) </span><br><span class=\"line\">Records: 0 Duplicates: 0 Warnings: 0</span><br></pre></td></tr></table></figure>\n\n<p>这时我们再查看一下 engine_demo_table 的表结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW CREATE TABLE engine_demo_table\\G</span><br><span class=\"line\">*************************** 1. row *************************** </span><br><span class=\"line\">\t\tTable: engine_demo_table </span><br><span class=\"line\">Create Table: CREATE TABLE `engine_demo_table` ( </span><br><span class=\"line\">`i` int(11) DEFAULT NULL </span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class=\"line\">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"引擎介绍\"><a href=\"#引擎介绍\" class=\"headerlink\" title=\"引擎介绍\"></a><strong>引擎介绍</strong></h2><h3 id=\"InnoDB-引擎：具备外键支持功能的事务存储引擎\"><a href=\"#InnoDB-引擎：具备外键支持功能的事务存储引擎\" class=\"headerlink\" title=\"InnoDB 引擎：具备外键支持功能的事务存储引擎\"></a><strong>InnoDB</strong> <strong>引擎：具备外键支持功能的事务存储引擎</strong></h3><ul>\n<li><p>MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎 。</p>\n</li>\n<li><p>InnoDB是MySQL的 默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</p>\n</li>\n<li><p>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</p>\n</li>\n<li><p><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></p>\n</li>\n<li><p>数据文件结构：（在《_MySQL数据目录》章节已讲）</p>\n<ul>\n<li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li>\n<li>表名.ibd 存储数据和索引</li>\n</ul>\n</li>\n<li><p>InnoDB是 为处理巨大数据量的最大性能设计 。</p>\n<ul>\n<li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。</li>\n</ul>\n</li>\n<li><p>对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和索引。</p>\n</li>\n<li><p>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响。</p>\n</li>\n</ul>\n<h3 id=\"MyISAM-引擎：主要的非事务处理存储引擎\"><a href=\"#MyISAM-引擎：主要的非事务处理存储引擎\" class=\"headerlink\" title=\"MyISAM 引擎：主要的非事务处理存储引擎\"></a><strong>MyISAM</strong> <strong>引擎：主要的非事务处理存储引擎</strong></h3><ul>\n<li><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务、行级 锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。 </p>\n</li>\n<li><p>5.5之前默认的存储引擎</p>\n</li>\n<li><p>优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用</p>\n</li>\n<li><p>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高</p>\n</li>\n<li><p>数据文件结构：（在《MySQL数据目录》章节已讲）</p>\n<ul>\n<li>表名.frm 存储表结构</li>\n<li>表名.MYD 存储数据 (MYData)</li>\n<li>表名.MYI 存储索引 (MYIndex)</li>\n</ul>\n</li>\n<li><p>应用场景：只读应用或者以读为主的业务</p>\n</li>\n</ul>\n<h3 id=\"Archive-引擎：用于数据存档\"><a href=\"#Archive-引擎：用于数据存档\" class=\"headerlink\" title=\"Archive 引擎：用于数据存档\"></a><strong>Archive</strong> <strong>引擎：用于数据存档</strong></h3><ul>\n<li><strong>下表展示了ARCHIVE存储引擎功能</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特征</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>B树索引</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>备份/时间点恢复 （在服务器中实现，而不是在存储引擎中）</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>集群数据库支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>聚集索引</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>压缩数据</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>数据缓存</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>加密数据（加密功能在服务器中实现）</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>外键支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>全文检索索引</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>地理空间数据类型支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>地理空间索引支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>哈希索引</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>索引缓存</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>锁粒度</td>\n<td>行锁</td>\n</tr>\n<tr>\n<td>MVCC</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>存储限制</td>\n<td>没有任何限制</td>\n</tr>\n<tr>\n<td>交易</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>支持更新数据字典的统计信息</td>\n<td>支持</td>\n</tr>\n</tbody></table>\n<h3 id=\"Blackhole-引擎：丢弃写操作，读操作会返回空内容\"><a href=\"#Blackhole-引擎：丢弃写操作，读操作会返回空内容\" class=\"headerlink\" title=\"Blackhole 引擎：丢弃写操作，读操作会返回空内容\"></a><strong>Blackhole</strong> <strong>引擎：丢弃写操作，读操作会返回空内容</strong></h3><h3 id=\"CSV-引擎：存储数据时，以逗号分隔各个数据项\"><a href=\"#CSV-引擎：存储数据时，以逗号分隔各个数据项\" class=\"headerlink\" title=\"CSV 引擎：存储数据时，以逗号分隔各个数据项\"></a><strong>CSV</strong> <strong>引擎：存储数据时，以逗号分隔各个数据项</strong></h3><p>使用案例如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE TABLE test (i INT NOT NULL, c CHAR(10) NOT NULL) ENGINE = CSV; </span><br><span class=\"line\">Query OK, 0 rows affected (0.06 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; INSERT INTO test VALUES(1,&#x27;record one&#x27;),(2,&#x27;record two&#x27;); </span><br><span class=\"line\">Query OK, 2 rows affected (0.05 sec) </span><br><span class=\"line\">Records: 2 Duplicates: 0 Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT * FROM test;</span><br><span class=\"line\">+---+------------+</span><br><span class=\"line\">| i | c | </span><br><span class=\"line\">+---+------------+</span><br><span class=\"line\">| 1 | record one | </span><br><span class=\"line\">| 2 | record two |</span><br><span class=\"line\">+---+------------+</span><br><span class=\"line\">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>创建CSV表还会创建相应的 元文件 ，用于 存储表的状态 和 表中存在的行数 。此文件的名称与表的名称相同，后缀为 CSM 。如图所示</p>\n<p>如果检查 test.CSV 通过执行上述语句创建的数据库目录中的文件，其内容使用Notepad++打开如下：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;record one&quot;</span> </span><br><span class=\"line\"><span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;record two&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这种格式可以被 Microsoft Excel 等电子表格应用程序读取，甚至写入。使用Microsoft Excel打开如图所示</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/239IVP45EER9KZ.png\"></p>\n<h3 id=\"Memory-引擎：置于内存的表\"><a href=\"#Memory-引擎：置于内存的表\" class=\"headerlink\" title=\"Memory 引擎：置于内存的表\"></a>Memory <strong>引擎：置于内存的表</strong></h3><p><strong>概述：</strong></p>\n<p>Memory采用的逻辑介质是 内存 ， 响应速度很快 ，但是当mysqld守护进程崩溃的时候 数据会丢失 。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。</p>\n<p><strong>主要特征：</strong></p>\n<ul>\n<li><p>Memory同时 支持哈希（HASH）索引 和 B+树索引 。</p>\n</li>\n<li><p>Memory表至少比MyISAM表要 快一个数量级 。 </p>\n</li>\n<li><p>MEMORY 表的大小是受到限制 的。表的大小主要取决于两个参数，分别是 max_rows 和 max_heap_table_size 。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默认为16MB，可以按需要进行扩大。</p>\n</li>\n<li><p>数据文件与索引文件分开存储。</p>\n</li>\n<li><p>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心</p>\n</li>\n</ul>\n<p><strong>使用Memory存储引擎的场景：</strong></p>\n<ol>\n<li><p>目标数据比较小 ，而且非常 频繁的进行访问 ，在内存中存放数据，如果太大的数据会造成 内存溢 出 。可以通过参数 max_heap_table_size 控制Memory表的大小，限制Memory表的最大的大小。</p>\n</li>\n<li><p>如果 数据是临时的 ，而且 必须立即可用 得到，那么就可以放在内存中。</p>\n</li>\n<li><p>存储在Memory表中的数据如果突然间 丢失的话也没有太大的关系 。</p>\n</li>\n</ol>\n<h3 id=\"Federated-引擎：访问远程表\"><a href=\"#Federated-引擎：访问远程表\" class=\"headerlink\" title=\"Federated 引擎：访问远程表\"></a><strong>Federated</strong> <strong>引擎：访问远程表</strong></h3><ul>\n<li>Federated引擎是访问其他MySQL服务器的一个 代理 ，尽管该引擎看起来提供了一种很好的 跨服务 器的灵活性 ，但也经常带来问题，因此 默认是禁用的 。</li>\n</ul>\n<h3 id=\"Merge引擎：管理多个MyISAM构成的表集合\"><a href=\"#Merge引擎：管理多个MyISAM构成的表集合\" class=\"headerlink\" title=\"Merge引擎：管理多个MyISAM构成的表集合\"></a><strong>Merge引擎：管理多个MyISAM构成的表集合</strong></h3><h3 id=\"NDB引擎-MySQL集群专用存储引擎\"><a href=\"#NDB引擎-MySQL集群专用存储引擎\" class=\"headerlink\" title=\"NDB引擎:MySQL集群专用存储引擎\"></a><strong>NDB引擎:MySQL集群专用存储引擎</strong></h3><p>也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群 环境，类似于 Oracle 的 RAC 集群。</p>\n<h3 id=\"引擎对比\"><a href=\"#引擎对比\" class=\"headerlink\" title=\"引擎对比\"></a><strong>引擎对比</strong></h3><p>MySQL中同一个数据库，不同的表可以选择不同的存储引擎。如下表对常用存储引擎做出了对比。</p>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th><strong>MyISAM</strong></th>\n<th><strong>InnoDB</strong></th>\n<th><strong>MEMORY</strong></th>\n<th><strong>MERGE</strong></th>\n<th><strong>NDB</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存储限制</td>\n<td>有</td>\n<td>64TB</td>\n<td>有</td>\n<td>没有</td>\n<td>有</td>\n</tr>\n<tr>\n<td>事务安全</td>\n<td></td>\n<td>支持</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锁机制</td>\n<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>\n<td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>\n<td>表锁</td>\n<td>表锁</td>\n<td>行锁</td>\n</tr>\n<tr>\n<td>B树索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>哈希索引</td>\n<td></td>\n<td></td>\n<td>支持</td>\n<td></td>\n<td>支持</td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>支持</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>集群索引</td>\n<td></td>\n<td>支持</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>数据缓存</td>\n<td></td>\n<td>支持</td>\n<td>支持</td>\n<td></td>\n<td>支持</td>\n</tr>\n<tr>\n<td>索引缓存</td>\n<td>只缓存索引，不缓存真实数据</td>\n<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>数据可压缩</td>\n<td>支持</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>空间使用</td>\n<td>低</td>\n<td>高</td>\n<td>N/A</td>\n<td>低</td>\n<td>低</td>\n</tr>\n<tr>\n<td>内存使用</td>\n<td>低</td>\n<td>高</td>\n<td>中等</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>批量插入的速度</td>\n<td>高</td>\n<td>低</td>\n<td>高</td>\n<td>高</td>\n<td>高</td>\n</tr>\n<tr>\n<td>支持外键</td>\n<td></td>\n<td>支持</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>其实我们最常用的就是 InnoDB 和 MyISAM ，有时会提一下 Memory 。其中 InnoDB 是 MySQL 默认的存储引擎。</p>\n<h2 id=\"MyISAM和InnoDB\"><a href=\"#MyISAM和InnoDB\" class=\"headerlink\" title=\"MyISAM和InnoDB\"></a><strong>MyISAM和InnoDB</strong></h2><p><strong>很多人对</strong> <strong>InnoDB</strong> <strong>和</strong> <strong>MyISAM</strong> <strong>的取舍存在疑问，到底选择哪个比较好呢？</strong></p>\n<p>MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/4QXT3VWSNVYXCIS.png\"></p>\n<h2 id=\"阿里巴巴、淘宝用哪个\"><a href=\"#阿里巴巴、淘宝用哪个\" class=\"headerlink\" title=\"阿里巴巴、淘宝用哪个\"></a><strong>阿里巴巴、淘宝用哪个</strong></h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/FWMWKSPSIEOB9DIUPU9P8.png\"></p>\n<ul>\n<li><p><strong>Percona</strong> 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。</p>\n</li>\n<li><p>该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外</p>\n</li>\n<li><p>有更多的参数和命令来控制服务器行为。该公司新建了一款存储引擎叫 Xtradb 完全可以替代 Innodb ，并且在性能和并发上做得更好</p>\n</li>\n<li><p>阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改。</p>\n</li>\n</ul>\n<h2 id=\"课外补充：\"><a href=\"#课外补充：\" class=\"headerlink\" title=\"课外补充：\"></a><strong>课外补充：</strong></h2><p><strong>1</strong>、<strong>InnoDB表的优势</strong></p>\n<p>InnoDB存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。</p>\n<p>InnoDB存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p>\n<p>在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。 InnoDB不仅支持当前读写，也会 缓冲改变的数据到数据流磁盘 。 </p>\n<p>InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度。使用InnoDB可以压缩表和相关的索引，可以 在不影响性能和可用性的情况下创建或删除索 引 。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。 当处理大数据量时， InnoDB兼顾CPU，以达到最大性能 。 </p>\n<p><strong>2、InnoDB和ACID模型</strong> </p>\n<p>ACID模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应用非常重要。MySQL包含类似InnoDB存储引擎的组件，与ACID模型紧密相连，这样出现意外时，数据不会崩溃，结果不会失真。如果依赖ACID模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将MySQL设置调整为只依赖部分ACID特性，以达到更高的性能。下面讲解InnoDB存储引擎与ACID模型相同作用的四个方面。</p>\n<p><strong>1.</strong> <strong>原子方面</strong> ACID的原子方面主要涉及InnoDB事务，与MySQL相关的特性主要包括：</p>\n<ul>\n<li>自动提交设置。</li>\n<li>COMMIT语句。</li>\n<li>ROLLBACK语句。</li>\n<li>操作INFORMATION_SCHEMA库中的表数据。</li>\n</ul>\n<p><strong>2.</strong> <strong>一致性方面</strong> ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程，与MySQL相关的特性主要包括：</p>\n<ul>\n<li>InnoDB双写缓存。</li>\n<li>InnoDB崩溃恢复。</li>\n</ul>\n<p><strong>3.</strong> <strong>隔离方面</strong> 隔离是应用于事务的级别，与MySQL相关的特性主要包括：</p>\n<ul>\n<li>自动提交设置。</li>\n<li>SET ISOLATION LEVEL语句。</li>\n<li>InnoDB锁的低级别信息。</li>\n</ul>\n<p><strong>4.</strong> <strong>耐久性方面</strong> ACID模型的耐久性主要涉及与硬件配置相互影响的MySQL软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循。与MySQL相关的特性有：</p>\n<ul>\n<li>InnoDB双写缓存，通过innodb_doublewrite配置项配置。</li>\n<li>配置项innodb_flush_log_at_trx_commit。</li>\n<li>配置项sync_binlog。</li>\n<li>配置项innodb_file_per_table。</li>\n<li>存储设备的写入缓存。</li>\n<li>存储设备的备用电池缓存。</li>\n<li>运行MySQL的操作系统。</li>\n<li>持续的电力供应。</li>\n<li>备份策略。</li>\n<li>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。</li>\n</ul>\n<p><strong>3、InnoDB架构</strong></p>\n<p><strong>1.</strong> <strong>缓冲池</strong> 缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的</p>\n<p>数据能够直接在内存中获得，从而提高速度。</p>\n<p><strong>2.</strong> <strong>更改缓存</strong> 更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索</p>\n<p>引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索</p>\n<p>引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁</p>\n<p>盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。</p>\n<p>在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由innodb_change_buffering配置项管</p>\n<p>理。</p>\n<p><strong>3.</strong> <strong>自适应哈希索引</strong> 自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行，</p>\n<p>不需要降低事务上的性能或可靠性。这个特性通过innodb_adaptive_hash_index选项配置，或者通过– </p>\n<p>skip-innodb_adaptive_hash_index命令行在服务启动时关闭。</p>\n<p><strong>4.</strong> <strong>重做日志缓存</strong> 重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过</p>\n<p>innodb_log_buffer_size配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存</p>\n<p>使得大型事务能够正常运行而不需要写入磁盘。</p>\n<p><strong>5.</strong> <strong>系统表空间</strong> 系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引</p>\n<p>数据。多表共享，系统表空间被视为共享表空间。</p>\n<p><strong>6.</strong> <strong>双写缓存</strong> 双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存</p>\n<p>后，InnoDB才会将数据页写入合适的位置。</p>\n<p><strong>7.</strong> <strong>撤销日志</strong> 撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他</p>\n<p>事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这</p>\n<p>些片段包含于回滚片段中。</p>\n<p><strong>8.</strong> <strong>每个表一个文件的表空间</strong> 每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，</p>\n<p>而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数</p>\n<p>据文件代表，该文件默认被创建在数据库目录中。</p>\n<p><strong>9.</strong> <strong>通用表空间</strong> 使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数</p>\n<p>据目录之外能够管理多个表并支持所有行格式的表。</p>\n<p><strong>10.</strong> <strong>撤销表空间</strong> 撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由</p>\n<p>innodb_undo_tablespaces配置项配置。</p>\n<p><strong>11.</strong> <strong>临时表空间</strong> 用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。</p>\n<p>innodb_temp_data_file_path配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在</p>\n<p>innodb_data_home_dir变量指定的目录下创建一个自动扩展的数据文件。</p>\n<p><strong>12.</strong> <strong>重做日志</strong> 重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，</p>\n<p>重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自</p>\n<p>动在初始化期间重新进行。</p>\n","categories":["MySQL高级","数据库"],"tags":["MySQL","数据库"]},{"title":"索引的数据结构","url":"/MySQL/%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"<h1 id=\"索引的数据结构\"><a href=\"#索引的数据结构\" class=\"headerlink\" title=\"索引的数据结构\"></a><strong>索引的数据结构</strong></h1><h2 id=\"为什么使用索引\"><a href=\"#为什么使用索引\" class=\"headerlink\" title=\"为什么使用索引\"></a><strong>为什么使用索引</strong></h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/1232143sdfsdfsfsd.png\"></p>\n<p>假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/3WDAHAK5VN0HPBE.png\"></p>\n<h2 id=\"索引及其优缺点\"><a href=\"#索引及其优缺点\" class=\"headerlink\" title=\"索引及其优缺点\"></a><strong>索引及其优缺点</strong></h2><h3 id=\"索引概述\"><a href=\"#索引概述\" class=\"headerlink\" title=\"索引概述\"></a><strong>索引概述</strong></h3><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p>\n<p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。 </p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a><strong>优点</strong></h3><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主要的原因。 （2）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。 （3）在实现数据的参考完整性方面，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 （4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时 间 ，降低了CPU的消耗。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a><strong>缺点</strong></h3><p>增加索引也有许多不利的方面，主要表现在如下几个方面： （1）创建索引和维护索引要 耗费时间 ，并且随着数据量的增加，所耗费的时间也会增加。 （2）索引需要占 磁盘空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 （3）虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>\n<h2 id=\"InnoDB中索引的推演\"><a href=\"#InnoDB中索引的推演\" class=\"headerlink\" title=\"InnoDB中索引的推演\"></a>InnoDB中索引的推演</h2><h3 id=\"索引之前的查找\"><a href=\"#索引之前的查找\" class=\"headerlink\" title=\"索引之前的查找\"></a><strong>索引之前的查找</strong></h3><p>先来看一个精确匹配的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</span><br></pre></td></tr></table></figure>\n\n<p><strong>1.</strong> <strong>在一个页中的查找</strong> </p>\n<p><strong>2.</strong> <strong>在很多页中查找</strong></p>\n<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页 沿着 双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/9H1HQW083W5M9T446UEE.png\"></p>\n<h3 id=\"设计索引\"><a href=\"#设计索引\" class=\"headerlink\" title=\"设计索引\"></a><strong>设计索引</strong></h3><p>建一个表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE TABLE index_demo(</span><br><span class=\"line\">    -&gt; c1 INT,</span><br><span class=\"line\">    -&gt; c2 INT,</span><br><span class=\"line\">    -&gt; c3 CHAR(1),</span><br><span class=\"line\">    -&gt; PRIMARY KEY(c1)</span><br><span class=\"line\">    -&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure>\n\n<p>这个新建的 index_demo 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用 Compact 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/BYUXX7125EU7.png\"></p>\n<p>我们只在示意图里展示记录的这几个部分：</p>\n<ul>\n<li><p>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。</p>\n</li>\n<li><p>next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</p>\n</li>\n<li><p>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。 </p>\n</li>\n<li><p>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</p>\n</li>\n</ul>\n<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/213456ythgfdfdd.png\"></p>\n<p>把一些记录放到页里的示意图就是：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/V45Z8R01YXT36EPJDC.png\"></p>\n<p><strong>1.</strong> <strong>一个简单的索引设计方案</strong></p>\n<p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 <strong>想快速的定位到需要查找的记录在哪些数据页</strong> 中该咋办？我们可以为快速定位记录所在的数据页而 <strong>建 立一个目录</strong> ，建这个目录必须完成下边这些事：</p>\n<ul>\n<li><strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</strong></li>\n<li><strong>给所有的页建立一个目录项。</strong></li>\n</ul>\n<p>所以我们为上边几个页做好的目录就像这样子：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/7HGHB47HHL04S4MRXK.png\"></p>\n<p>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p>\n<ol>\n<li><p>先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是 页9 。 </p>\n</li>\n<li><p>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</p>\n</li>\n</ol>\n<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 索引 。 </p>\n<p><strong>2. InnoDB中的索引方案</strong> </p>\n<p><strong>① 迭代1次：目录项纪录的页</strong></p>\n<p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/91ZVYHMS522C2S1QA3.png\"></p>\n<p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 目录项记录和普通的 用户记录 的<strong>不同点</strong>： </p>\n<ul>\n<li><p>目录项记录 的 record_type 值是1，而 普通用户记录 的 record_type 值是0。</p>\n</li>\n<li><p>目录项记录只有 主键值和页的编号 两个列，而普通的用户记录的列是用户自己定义的，可能包含 很 多列 ，另外还有InnoDB自己添加的隐藏列。</p>\n</li>\n<li><p>了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 目录项记录 的页中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。</p>\n</li>\n</ul>\n<p><strong>相同点：</strong>两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用 二分法 来加快查询速度。</p>\n<p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>\n<ul>\n<li><p>先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</p>\n</li>\n<li><p>再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。</p>\n</li>\n</ul>\n<p><strong>② 迭代2次：多个目录项纪录的页</strong></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/I681X7RC5U.png\"></p>\n<p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p>\n<ul>\n<li><p>为存储该用户记录而新生成了 页31 。</p>\n</li>\n<li><p>因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得不需要一个新的 页32 来存放 页31 对应的目录项。</p>\n</li>\n</ul>\n<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：</p>\n<ol>\n<li>确定 目录项记录页</li>\n</ol>\n<p> 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页       30表示的目录项的主键值的范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目录项记录在 页30 中。</p>\n<ol start=\"2\">\n<li>通过目录项记录页 确定用户记录真实所在的页 。</li>\n</ol>\n<p>在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。</p>\n<ol start=\"3\">\n<li>在真实存储用户记录的页中定位到具体的记录。</li>\n</ol>\n<p><strong>③ 迭代3次：目录项记录页的目录页</strong></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/60JSW7YGLOPG9QK.png\"></p>\n<p>如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的话，就到页32中查找更详细的目录项记录。</p>\n<p>我们可以用下边这个图来描述它：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/KPXVS96XU99I7]BHB.png\"></p>\n<p>这个数据结构，它的名称是 B+树 。</p>\n<p><strong>④</strong> <strong>B+Tree</strong></p>\n<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存放 1000条目录项记录 ，那么：</p>\n<ul>\n<li><p>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</p>\n</li>\n<li><p>如果B+树有2层，最多能存放 1000×100=10,0000 条记录。</p>\n</li>\n<li><p>如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。</p>\n</li>\n<li><p>如果B+树有4层，最多能存f1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录！！！</p>\n</li>\n</ul>\n<p>你的表里能存放 100000000000 条记录吗？所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速定位记录。</p>\n<h3 id=\"常见索引概念\"><a href=\"#常见索引概念\" class=\"headerlink\" title=\"常见索引概念\"></a><strong>常见索引概念</strong></h3><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。</p>\n<h4 id=\"1-聚簇索引\"><a href=\"#1-聚簇索引\" class=\"headerlink\" title=\"1. 聚簇索引\"></a><strong>1.</strong> <strong>聚簇索引</strong></h4><p><strong>特点：</strong></p>\n<ol>\n<li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>\n<ul>\n<li>页内 的记录是按照主键的大小顺序排成一个 单向链表 。</li>\n<li>各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。</li>\n<li>存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 双向链表 。 </li>\n</ul>\n</li>\n<li><p>B+树的 叶子节点 存储的是完整的用户记录</p>\n</li>\n</ol>\n<p><strong>优点：</strong></p>\n<ul>\n<li><p>数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</p>\n</li>\n<li><p>聚簇索引对于主键的 排序查找 和 范围查找 速度非常快</p>\n</li>\n<li><p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 节省了大量的io操作 。</p>\n</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><p>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong></p>\n</li>\n<li><p>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></p>\n</li>\n<li><p>二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据</p>\n</li>\n</ul>\n<h4 id=\"2-二级索引（辅助索引、非聚簇索引）\"><a href=\"#2-二级索引（辅助索引、非聚簇索引）\" class=\"headerlink\" title=\"2. 二级索引（辅助索引、非聚簇索引）\"></a><strong>2.</strong> <strong>二级索引（辅助索引、非聚簇索引）</strong></h4><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/BPSZ4KNX8JAS8.png\"></p>\n<p><strong>概念：回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p>\n<p><strong>问题：</strong>为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/8APZQ5EG3Z1WMJ3D.png\"></p>\n<h4 id=\"3-联合索引\"><a href=\"#3-联合索引\" class=\"headerlink\" title=\"3. 联合索引\"></a><strong>3.</strong> <strong>联合索引</strong></h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义：</p>\n<ul>\n<li>先把各个记录和页按照c2列进行排序。</li>\n<li>在记录的c2列相同的情况下，采用c3列进行排序</li>\n</ul>\n<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>\n<ul>\n<li><p>建立 联合索引 只会建立如上图一样的1棵B+树</p>\n</li>\n<li><p>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</p>\n</li>\n</ul>\n<h3 id=\"InnoDB的B-树索引的注意事项\"><a href=\"#InnoDB的B-树索引的注意事项\" class=\"headerlink\" title=\"InnoDB的B+树索引的注意事项\"></a>InnoDB的B+树索引的注意事项</h3><p><strong>1.</strong> <strong>根页面位置万年不动</strong> </p>\n<p><strong>2.</strong> <strong>内节点中目录项记录的唯一性</strong> </p>\n<p><strong>3.</strong> <strong>一个页面最少存储2条记录</strong> </p>\n<h2 id=\"MyISAM中的索引方案\"><a href=\"#MyISAM中的索引方案\" class=\"headerlink\" title=\"MyISAM中的索引方案\"></a><strong>MyISAM中的索引方案</strong></h2><p><strong>B树索引适用存储引擎如表所示：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>索引</strong> <strong>/</strong> <strong>存储引擎</strong></th>\n<th><strong>MyISAM</strong></th>\n<th><strong>InnoDB</strong></th>\n<th><strong>Memory</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>B-Tree索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n</tbody></table>\n<p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p>\n<p>MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址 。 </p>\n<h3 id=\"MyISAM索引的原理\"><a href=\"#MyISAM索引的原理\" class=\"headerlink\" title=\"MyISAM索引的原理\"></a><strong>MyISAM索引的原理</strong></h3><p>下图是MyISAM索引的原理图。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/MZ47U7DXQCOIAXYN9L.png\"></p>\n<p>如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/PYPNC2VA2HPMJA.png\"></p>\n<h3 id=\"MyISAM-与-InnoDB对比\"><a href=\"#MyISAM-与-InnoDB对比\" class=\"headerlink\" title=\"MyISAM 与 InnoDB对比\"></a><strong>MyISAM</strong> <strong>与</strong> InnoDB对比</h3><p><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：</strong></p>\n<p>① 在InnoDB存储引擎中，我们只需要根据主键值对 <strong>聚簇索引</strong> 进行一次查找就能找到对应的记录，而在**MyISAM <strong>中却需要进行一次 <strong>回表</strong> 操作，意味着MyISAM中建立的索引相当于全部都是</strong>二级索引 **。 </p>\n<p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 <strong>分离的</strong> ，索引文件仅保存数据记录的地址。</p>\n<p>③ InnoDB的非聚簇索引data域存储相应记录**主键的值 **，而MyISAM索引记录的是 <strong>地址</strong> 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</p>\n<p>④ MyISAM的回表操作是十分<strong>快速</strong>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p>\n<p>⑤ InnoDB要求表<strong>必须有主键 （ MyISAM可以没有 ）</strong>。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/85Y7FESL[LA7A4C.png\"></p>\n<h2 id=\"索引的代价\"><a href=\"#索引的代价\" class=\"headerlink\" title=\"索引的代价\"></a><strong>索引的代价</strong></h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>\n<ul>\n<li><strong>空间上的代价</strong></li>\n</ul>\n<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>\n<ul>\n<li><strong>时间上的代价</strong></li>\n</ul>\n<p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>\n<h2 id=\"MySQL数据结构选择的合理性\"><a href=\"#MySQL数据结构选择的合理性\" class=\"headerlink\" title=\"MySQL数据结构选择的合理性\"></a><strong>MySQL数据结构选择的合理性</strong></h2><h3 id=\"Hash结构\"><a href=\"#Hash结构\" class=\"headerlink\" title=\"Hash结构\"></a><strong>Hash结构</strong></h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/O1XHTMLSE01Z3MAP2L8L.png\"></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/P1LI8GSYZG454ELIW.png\"></p>\n<p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链 接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/9S2Q4U8IKOOHOY.png\"></p>\n<p>实验：体会数组和hash表的查找方面的效率区别 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">100000</span>]; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; arr.length;i++)&#123; </span><br><span class=\"line\">        arr[i] = i + <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis(); </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j&lt;=<span class=\"number\">100000</span>;j++)&#123; </span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = j; </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; arr.length;i++)&#123; </span><br><span class=\"line\">        \t<span class=\"keyword\">if</span>(temp == arr[i])&#123; </span><br><span class=\"line\">       \t\t <span class=\"keyword\">break</span>; </span><br><span class=\"line\">        \t&#125; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis(); </span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;time： &quot;</span> + (end - start));<span class=\"comment\">//time： 823 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//算法复杂度为 O(1) </span></span><br><span class=\"line\"><span class=\"meta\">@Test</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">    HashSet&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;(<span class=\"number\">100000</span>); </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">100000</span>;i++)&#123; </span><br><span class=\"line\">    \tset.add(i + <span class=\"number\">1</span>); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis(); </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j&lt;=<span class=\"number\">100000</span>;j++) &#123; </span><br><span class=\"line\">    \t<span class=\"keyword\">int</span> temp = j; </span><br><span class=\"line\">    \t<span class=\"keyword\">boolean</span> contains = set.contains(temp); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis(); </span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;time： &quot;</span> + (end - start));<span class=\"comment\">//time： 5 </span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p><strong>Hash结构效率高，那为什么索引结构要设计成树型呢？</strong></p>\n<p><strong>Hash索引适用存储引擎如表所示：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>索引</strong> <strong>/</strong> <strong>存储引擎</strong></th>\n<th><strong>MyISAM</strong></th>\n<th><strong>InnoDB</strong></th>\n<th><strong>Memory</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HASH索引</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n</tbody></table>\n<p><strong>Hash索引的适用性：</strong></p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/234567fbgdfg.png\"></p>\n<p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p>\n<p>我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#x27;%adaptive_hash_index&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AVL树\"><a href=\"#AVL树\" class=\"headerlink\" title=\"AVL树\"></a><strong>AVL树</strong></h3><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/sdadwe234234.png\"></p>\n<p>针对同样的数据，如果我们把二叉树改成 M 叉树 （M&gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/40MMX8UPXYEO.png\"></p>\n<h3 id=\"B-Tree\"><a href=\"#B-Tree\" class=\"headerlink\" title=\"B-Tree\"></a><strong>B-Tree</strong></h3><p>B 树的结构如下图所示：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/PH]50RKFKTA32.png\"></p>\n<p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p>\n<ol>\n<li><p>根节点的儿子数的范围是 [2,M]。 </p>\n</li>\n<li><p>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。 </p>\n</li>\n<li><p>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。 </p>\n</li>\n<li><p>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] &lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。</p>\n</li>\n<li><p>所有叶子节点位于同一层。</p>\n</li>\n</ol>\n<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，刚好符合刚才我们给出的特征。</p>\n<p>然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步：</p>\n<ol>\n<li><p>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； </p>\n</li>\n<li><p>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； </p>\n</li>\n<li><p>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</p>\n</li>\n</ol>\n<p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。 <strong>B 树相比于平衡二叉树来说磁盘 I/O 操作要少</strong> ，在数据查询中比平衡二叉树效率要高。所以<strong>只要树的高度足够低，IO次数足够少，就可以提高查询性能</strong> 。</p>\n<p><strong>再举例1：</strong> </p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/QVIL4F7HWIQ.png\"></p>\n<h3 id=\"B-Tree-1\"><a href=\"#B-Tree-1\" class=\"headerlink\" title=\"B+Tree\"></a><strong>B+Tree</strong></h3><p><strong>B+</strong> <strong>树和</strong> <strong>B</strong> <strong>树的差异：</strong></p>\n<ol>\n<li><p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数+1。</p>\n</li>\n<li><p>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</p>\n</li>\n<li><p>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非<strong>叶子节点既保存索引，也保存数据记录</strong> 。 </p>\n</li>\n<li><p>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p>\n</li>\n</ol>\n<blockquote>\n<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p>\n<p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p>\n</blockquote>\n<p><strong>思考题：为了减少IO，索引树会一次性加载吗？</strong></p>\n<blockquote>\n<p> 1.数据库索引是存在磁盘上的,如果数据量很大,必然导致索引也会很大，超过几个G。</p>\n<p>2.当我们利用索引查询时候,是不可能将全部几个G的索引都加载进内存的,我们做的只能是:逐一加载每一个磁盘页,因为磁盘页对应着索引数的节点。</p>\n</blockquote>\n<p><strong>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</strong></p>\n<blockquote>\n<p>InnoDB存储引擎中页的大小为16KB，一般表的主键为INT(占用四个字节)或BIGINT(占用8个字节),指针类型一般为4或8个字节,也就是说一个页(B+Tree中的一个节点)大概存储16KB/(8B+8B)=1K个键值(因为是估值,为方便计算,这里的K取值为10^3,也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿条数据。这里假定一个数据页也存储10^3条行记录数据了)</p>\n<p>实际情况中每个节点可能不被充满,因此在数据库中,B+Tree的高度一般都在2 ~ 4层,MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的,也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p>\n</blockquote>\n<p><strong>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>\n<blockquote>\n<p>1、B+树的磁盘读写代价更低</p>\n<p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说Io读写次数也就降低了。</p>\n<p>2、B+树的查询效率更加稳定</p>\n<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>\n</blockquote>\n<p><strong>思考题：Hash索引与</strong> <strong>B+</strong> <strong>树索引的区别</strong></p>\n<p><strong>思考题：Hash索引与</strong> <strong>B+</strong> <strong>树索引是在建索引的时候手动指定的吗？</strong></p>\n","categories":["MySQL高级","数据库"],"tags":["MySQL","数据库"]},{"title":"索引的创建与设计原则","url":"/MySQL/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","content":"<h1 id=\"索引的声明与使用\"><a href=\"#索引的声明与使用\" class=\"headerlink\" title=\"索引的声明与使用\"></a><strong>索引的声明与使用</strong></h1><h2 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h2><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p>\n<ul>\n<li>从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引</li>\n<li>按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。</li>\n<li>按照 作用字段个数 进行划分，分成单列索引和联合索引。</li>\n</ul>\n<p><strong>1.</strong> <strong>普通索引</strong></p>\n<p><strong>2.</strong> <strong>唯一性索引</strong></p>\n<p><strong>3.</strong> <strong>主键索引</strong></p>\n<p><strong>4.</strong> <strong>单列索引</strong></p>\n<p><strong>5.</strong> <strong>多列(组合、联合)索引</strong></p>\n<p><strong>6.</strong> <strong>全文索引</strong></p>\n<p><strong>7.</strong> <strong>补充：空间索引</strong></p>\n<p><strong>小结：不同的存储引擎支持的索引类型也不一样</strong> <strong>InnoDB</strong> <strong>：</strong>支持 B-tree、Full-text 等索引，不支持 Hash索引； <strong>MyISAM</strong> <strong>：</strong> 支持 B-tree、Full-text 等索引，不支持 Hash 索引； <strong>Memory</strong> <strong>：</strong>支持 B-tree、Hash 等索引，不支持 Full-text 索引； <strong>NDB</strong> <strong>：</strong>支持 Hash 索引，不支持 B-tree、Full-text 等索引； <strong>Archive</strong> <strong>：</strong>不支持 B-tree、Hash、Full-text 等索引；</p>\n<h2 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a><strong>创建索引</strong></h2><h3 id=\"创建表的时候创建索引\"><a href=\"#创建表的时候创建索引\" class=\"headerlink\" title=\"创建表的时候创建索引\"></a><strong>创建表的时候创建索引</strong></h3><p>举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE dept( </span><br><span class=\"line\">dept_id INT PRIMARY KEY AUTO_INCREMENT, </span><br><span class=\"line\">dept_name VARCHAR(20)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE emp( </span><br><span class=\"line\">emp_id INT PRIMARY KEY AUTO_INCREMENT, </span><br><span class=\"line\">emp_name VARCHAR(20) UNIQUE, </span><br><span class=\"line\">dept_id INT, </span><br><span class=\"line\">CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id) );</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果显式创建表时创建索引的话，基本语法格式如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE table_name [col_name data_type] </span><br><span class=\"line\">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；</li>\n<li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；</li>\n<li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li>\n<li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li>\n<li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li>\n<li>ASC 或 DESC 指定升序或者降序的索引值存储。</li>\n</ul>\n<p><strong>1.</strong> <strong>创建普通索引</strong></p>\n<p>在book表中的year_publication字段上建立普通索引，SQL语句如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE book( </span><br><span class=\"line\">book_id INT , </span><br><span class=\"line\">book_name VARCHAR(100), </span><br><span class=\"line\">authors VARCHAR(100), </span><br><span class=\"line\">info VARCHAR(100) , </span><br><span class=\"line\">comment VARCHAR(100), </span><br><span class=\"line\">year_publication YEAR, </span><br><span class=\"line\">INDEX(year_publication) </span><br><span class=\"line\">); </span><br></pre></td></tr></table></figure>\n\n<p><strong>2.</strong> <strong>创建唯一索引</strong></p>\n<p>举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE test1( </span><br><span class=\"line\">id INT NOT NULL, </span><br><span class=\"line\">name varchar(30) NOT NULL, </span><br><span class=\"line\">UNIQUE INDEX uk_idx_id(id) </span><br><span class=\"line\">); </span><br></pre></td></tr></table></figure>\n\n<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SHOW INDEX FROM test1 \\G</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.</strong> <strong>主键索引</strong></p>\n<p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法：</p>\n<ul>\n<li>随表一起建索引：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE student ( </span><br><span class=\"line\">id INT(10) UNSIGNED AUTO_INCREMENT , </span><br><span class=\"line\">student_no VARCHAR(200), </span><br><span class=\"line\">student_name VARCHAR(200), </span><br><span class=\"line\">PRIMARY KEY(id) </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>删除主键索引</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER TABLE student </span><br><span class=\"line\">drop PRIMARY KEY ;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引</li>\n</ul>\n<p><strong>4.</strong> <strong>创建单列索引</strong></p>\n<p>举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE test2( </span><br><span class=\"line\">id INT NOT NULL, </span><br><span class=\"line\">name CHAR(50) NULL, </span><br><span class=\"line\">INDEX single_idx_name(name(20)) </span><br><span class=\"line\">); </span><br></pre></td></tr></table></figure>\n\n<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SHOW INDEX FROM test2 \\G</span><br></pre></td></tr></table></figure>\n\n<p><strong>5.</strong> <strong>创建组合索引</strong></p>\n<p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE test3( </span><br><span class=\"line\">id INT(11) NOT NULL, </span><br><span class=\"line\">name CHAR(30) NOT NULL, </span><br><span class=\"line\">age INT(11) NOT NULL, </span><br><span class=\"line\">info VARCHAR(255), </span><br><span class=\"line\">INDEX multi_idx(id,name,age) </span><br><span class=\"line\">); </span><br></pre></td></tr></table></figure>\n\n<p>该语句执行完毕之后，使用SHOW INDEX 查看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SHOW INDEX FROM test3 \\G</span><br></pre></td></tr></table></figure>\n\n<p><strong>6.</strong> <strong>创建全文索引</strong></p>\n<p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE test4( </span><br><span class=\"line\">id INT NOT NULL, </span><br><span class=\"line\">name CHAR(30) NOT NULL, </span><br><span class=\"line\">age INT NOT NULL, </span><br><span class=\"line\">info VARCHAR(255), </span><br><span class=\"line\">FULLTEXT INDEX futxt_idx_info(info) </span><br><span class=\"line\">) ENGINE=MyISAM; </span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</p>\n</blockquote>\n<p>举例2： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE articles ( </span><br><span class=\"line\">id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, </span><br><span class=\"line\">title VARCHAR (200), </span><br><span class=\"line\">body TEXT, </span><br><span class=\"line\">FULLTEXT index (title, body) </span><br><span class=\"line\">) ENGINE = INNODB ;</span><br></pre></td></tr></table></figure>\n\n<p>创建了一个给title和body字段添加全文索引的表。</p>\n<p>举例3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `papers` ( </span><br><span class=\"line\">`id` int(10) unsigned NOT NULL AUTO_INCREMENT, </span><br><span class=\"line\">`title` varchar(200) DEFAULT NULL, </span><br><span class=\"line\">`content` text, </span><br><span class=\"line\">PRIMARY KEY (`id`), </span><br><span class=\"line\">FULLTEXT KEY `title` (`title`,`content`) </span><br><span class=\"line\">) ENGINE=MyISAM DEFAULT CHARSET=utf8; </span><br></pre></td></tr></table></figure>\n\n<p>不同于like方式的的查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;</span><br></pre></td></tr></table></figure>\n\n<p>全文索引用match+against方式查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意点</p>\n<ol>\n<li><p>使用全文索引前，搞清楚版本支持情况；</p>\n</li>\n<li><p>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</p>\n</li>\n<li><p>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</p>\n</li>\n</ol>\n</blockquote>\n<p><strong>7.</strong> <strong>创建空间索引</strong></p>\n<p>空间索引创建中，要求空间类型的字段必须为 非空 。</p>\n<p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE test5( </span><br><span class=\"line\">geo GEOMETRY NOT NULL, </span><br><span class=\"line\">SPATIAL INDEX spa_idx_geo(geo) </span><br><span class=\"line\">) ENGINE=MyISAM; </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在已经存在的表上创建索引\"><a href=\"#在已经存在的表上创建索引\" class=\"headerlink\" title=\"在已经存在的表上创建索引\"></a><strong>在已经存在的表上创建索引</strong></h3><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。</p>\n<p><strong>1.</strong> <strong>使用ALTER TABLE语句创建索引</strong> ALTER TABLE语句创建索引的基本语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.</strong> <strong>使用CREATE INDEX创建索引</strong> CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a><strong>删除索引</strong></h2><p><strong>1.</strong> <strong>使用ALTER TABLE删除索引</strong> ALTER TABLE删除索引的基本语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.</strong> <strong>使用DROP INDEX语句删除索引</strong> DROP INDEX删除索引的基本语法格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>提示 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p>\n</blockquote>\n<h1 id=\"MySQL8-0索引新特性\"><a href=\"#MySQL8-0索引新特性\" class=\"headerlink\" title=\"MySQL8.0索引新特性\"></a><strong>MySQL8.0索引新特性</strong></h1><h2 id=\"支持降序索引\"><a href=\"#支持降序索引\" class=\"headerlink\" title=\"支持降序索引\"></a><strong>支持降序索引</strong></h2><p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));</span><br></pre></td></tr></table></figure>\n\n<p>在MySQL 5.7版本中查看数据表ts1的结构，结果如下：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/VW2I77ZC3MEC%600_ILWYOZ1F.png\"></p>\n<p>从结果可以看出，索引仍然是默认的升序。</p>\n<p>在MySQL 8.0版本中查看数据表ts1的结构，结果如下：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/1321sdfsdfsdf.png\"></p>\n<p>从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。</p>\n<p>分别在MySQL5.7版本和MySQL8.0版本的数据表ts1中插入800条随机数据，执行语句如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DELIMITER // </span><br><span class=\"line\">CREATE PROCEDURE ts_insert() </span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">DECLARE i INT DEFAULT 1; </span><br><span class=\"line\">WHILE i &lt; 800 </span><br><span class=\"line\">DO </span><br><span class=\"line\">insert into ts1 select rand()*80000,rand()*80000; </span><br><span class=\"line\">SET i = i + 1; </span><br><span class=\"line\">END WHILE; </span><br><span class=\"line\">commit; </span><br><span class=\"line\">END // </span><br><span class=\"line\">DELIMITER ; </span><br><span class=\"line\">#调用</span><br><span class=\"line\">CALL ts_insert();</span><br></pre></td></tr></table></figure>\n\n<p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EXPLAIN SELECT * FROM ts1 ORDER BY a,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure>\n\n<p>从结果可以看出，执行计划中扫描数为799，而且使用了Using filesort。</p>\n<blockquote>\n<p>提示 Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。</p>\n</blockquote>\n<p>在MySQL 8.0版本中查看数据表ts1的执行计划。从结果可以看出，执行计划中扫描数为5，而且没有使用Using filesort。</p>\n<blockquote>\n<p>注意 降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。</p>\n</blockquote>\n<p>将排序条件修改为order by a desc, b desc后，下面来对比不同版本中执行计划的效果。 在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EXPLAIN SELECT * FROM ts1 ORDER BY a DESC,b DESC LIMIT 5;</span><br></pre></td></tr></table></figure>\n\n<p>在MySQL 8.0版本中查看数据表ts1的执行计划。</p>\n<p>从结果可以看出，修改后MySQL 5.7的执行计划要明显好于MySQL 8.0</p>\n<h2 id=\"隐藏索引\"><a href=\"#隐藏索引\" class=\"headerlink\" title=\"隐藏索引\"></a><strong>隐藏索引</strong></h2><p>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>\n<p>从MySQL 8.x开始支持 隐藏索引（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除 。 </p>\n<p><strong>1.</strong> <strong>创建表时直接创建</strong> 在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE tablename( </span><br><span class=\"line\">propname1 type1[CONSTRAINT1], </span><br><span class=\"line\">propname2 type2[CONSTRAINT2], </span><br><span class=\"line\">……</span><br><span class=\"line\">propnamen typen, </span><br><span class=\"line\">INDEX [indexname](propname1 [(length)]) INVISIBLE </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。</p>\n<p><strong>2.</strong> <strong>在已经存在的表上创建</strong></p>\n<p>可以为已经存在的表设置隐藏索引，其语法形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE INDEX indexname </span><br><span class=\"line\">ON tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.</strong> <strong>通过ALTER TABLE语句创建</strong></p>\n<p>语法形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tablename </span><br><span class=\"line\">ADD INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.</strong> <strong>切换索引可见状态</strong> 已存在的索引可通过如下语句切换可见状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引 </span><br><span class=\"line\">ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure>\n\n<p>如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。</p>\n<blockquote>\n<p>注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>\n</blockquote>\n<p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p>\n<p><strong>5.</strong> <strong>使隐藏索引对查询优化器可见</strong></p>\n<p>在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关（use_invisible_indexes）来打开某个设置，使隐藏索引对查询优化器可见。如果 use_invisible_indexes设置为off(默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。</p>\n<p>（1）在MySQL命令行执行如下命令查看查询优化器的开关设置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; select @@optimizer_switch \\G</span><br></pre></td></tr></table></figure>\n\n<p>在输出的结果信息中找到如下属性配置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">use_invisible_indexes=off</span><br></pre></td></tr></table></figure>\n\n<p>此属性配置值为off，说明隐藏索引默认对查询优化器不可见。</p>\n<p>（2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=on&quot;; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>SQL语句执行成功，再次查看查询优化器的开关设置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; select @@optimizer_switch \\G </span><br><span class=\"line\">*************************** 1. row *************************** </span><br><span class=\"line\">@@optimizer_switch: </span><br><span class=\"line\">index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_ </span><br><span class=\"line\">intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_co </span><br><span class=\"line\">st_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on </span><br><span class=\"line\">,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on </span><br><span class=\"line\">,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_ind </span><br><span class=\"line\">exes=on,skip_scan=on,hash_join=on </span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>此时，在输出结果中可以看到如下属性配置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">use_invisible_indexes=on</span><br></pre></td></tr></table></figure>\n\n<p>use_invisible_indexes属性的值为on，说明此时隐藏索引对查询优化器可见。</p>\n<p>（3）使用EXPLAIN查看以字段invisible_column作为查询条件时的索引使用情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">explain select * from classes where cname = &#x27;高一2班&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p>查询优化器会使用隐藏索引来查询数据。</p>\n<p>（4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=off&quot;; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>再次查看查询优化器的开关设置。</p>\n<p>mysql&gt; select @@optimizer_switch \\G </p>\n<p>此时，use_invisible_indexes属性的值已经被设置为“off”。 </p>\n<h1 id=\"索引的设计原则\"><a href=\"#索引的设计原则\" class=\"headerlink\" title=\"索引的设计原则\"></a><strong>索引的设计原则</strong></h1><h2 id=\"数据准备\"><a href=\"#数据准备\" class=\"headerlink\" title=\"数据准备\"></a><strong>数据准备</strong></h2><p><strong>第1步：创建数据库、创建表</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE DATABASE atguigudb1; </span><br><span class=\"line\">USE atguigudb1; </span><br><span class=\"line\">#1.创建学生表和课程表 </span><br><span class=\"line\">CREATE TABLE `student_info` ( </span><br><span class=\"line\">`id` INT(11) NOT NULL AUTO_INCREMENT, </span><br><span class=\"line\">`student_id` INT NOT NULL , </span><br><span class=\"line\">`name` VARCHAR(20) DEFAULT NULL, </span><br><span class=\"line\">`course_id` INT NOT NULL , </span><br><span class=\"line\">`class_id` INT(11) DEFAULT NULL, </span><br><span class=\"line\">`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, </span><br><span class=\"line\">PRIMARY KEY (`id`) </span><br><span class=\"line\">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; </span><br><span class=\"line\">CREATE TABLE `course` ( </span><br><span class=\"line\">`id` INT(11) NOT NULL AUTO_INCREMENT, </span><br><span class=\"line\">`course_id` INT NOT NULL , </span><br><span class=\"line\">`course_name` VARCHAR(40) DEFAULT NULL, </span><br><span class=\"line\">PRIMARY KEY (`id`) </span><br><span class=\"line\">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; </span><br></pre></td></tr></table></figure>\n\n<p><strong>第2步：创建模拟数据必需的存储函数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#函数1：创建随机产生字符串函数 </span><br><span class=\"line\">DELIMITER // </span><br><span class=\"line\">CREATE FUNCTION rand_string(n INT) </span><br><span class=\"line\">RETURNS VARCHAR(255) #该函数会返回一个字符串 </span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">DECLARE chars_str VARCHAR(100) DEFAULT </span><br><span class=\"line\">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;; </span><br><span class=\"line\">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class=\"line\">#函数1：创建随机产生字符串函数 </span><br><span class=\"line\">DELIMITER // </span><br><span class=\"line\">CREATE FUNCTION rand_string(n INT) </span><br><span class=\"line\">RETURNS VARCHAR(255) #该函数会返回一个字符串 </span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">DECLARE chars_str VARCHAR(100) DEFAULT </span><br><span class=\"line\">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;; </span><br><span class=\"line\">DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#函数2：创建随机数函数 </span><br><span class=\"line\">DELIMITER // </span><br><span class=\"line\">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11) </span><br><span class=\"line\">BEGIN </span><br><span class=\"line\">DECLARE i INT DEFAULT 0; </span><br><span class=\"line\">SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ; </span><br><span class=\"line\">RETURN i; </span><br><span class=\"line\">END // </span><br><span class=\"line\">DELIMITER ;</span><br></pre></td></tr></table></figure>\n\n<p>创建函数，假如报错：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\">This function has <span class=\"literal\">none</span> of DETERMINISTIC<span class=\"params\">...</span><span class=\"params\">...</span></span><br></pre></td></tr></table></figure>\n\n<p>由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。</p>\n<p>主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。</p>\n<ul>\n<li>查看mysql是否允许创建函数：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">show variables like &#x27;log_bin_trust_function_creators&#x27;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>命令开启：允许创建函数设置：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>mysqld重启，上述参数又会消失。永久方法：</p>\n<ul>\n<li><p>windows下：my.ini[mysqld]加上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log_bin_trust_function_creators=1</span><br></pre></td></tr></table></figure></li>\n<li><p>linux下：/etc/my.cnf下my.cnf[mysqld]加上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    log_bin_trust_function_creators=1</span><br><span class=\"line\"></span><br><span class=\"line\">​\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">第3步：创建插入模拟数据的存储过程</span><br><span class=\"line\"></span><br><span class=\"line\">```mysql</span><br><span class=\"line\"># 存储过程1：创建插入课程表存储过程 </span><br><span class=\"line\">DELIMITER // </span><br><span class=\"line\">CREATE PROCEDURE insert_course( max_num INT ) </span><br><span class=\"line\">BEGIN </span><br><span class=\"line\">DECLARE i INT DEFAULT 0; </span><br><span class=\"line\">SET autocommit = 0; #设置手动提交事务 </span><br><span class=\"line\">REPEAT #循环 </span><br><span class=\"line\">SET i = i + 1; #赋值 </span><br><span class=\"line\">INSERT INTO course (course_id, course_name ) VALUES </span><br><span class=\"line\">(rand_num(10000,10100),rand_string(6)); </span><br><span class=\"line\">UNTIL i = max_num</span><br><span class=\"line\">END REPEAT; </span><br><span class=\"line\">COMMIT; #提交事务 </span><br><span class=\"line\">END // </span><br><span class=\"line\">DELIMITER ; </span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 存储过程2：创建插入学生信息表存储过程 </span><br><span class=\"line\">DELIMITER // </span><br><span class=\"line\">CREATE PROCEDURE insert_stu( max_num INT ) </span><br><span class=\"line\">BEGIN </span><br><span class=\"line\">DECLARE i INT DEFAULT 0; </span><br><span class=\"line\">SET autocommit = 0; #设置手动提交事务 </span><br><span class=\"line\">REPEAT #循环 </span><br><span class=\"line\">SET i = i + 1; #赋值 </span><br><span class=\"line\">INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES </span><br><span class=\"line\">(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6)); </span><br><span class=\"line\">UNTIL i = max_num </span><br><span class=\"line\">END REPEAT; </span><br><span class=\"line\">COMMIT; #提交事务 </span><br><span class=\"line\">END // </span><br><span class=\"line\">DELIMITER ; </span><br></pre></td></tr></table></figure>\n\n<p>第4步：调用存储过程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CALL insert_course(100); </span><br><span class=\"line\"></span><br><span class=\"line\">CALL insert_stu(1000000);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"哪些情况适合创建索引\"><a href=\"#哪些情况适合创建索引\" class=\"headerlink\" title=\"哪些情况适合创建索引\"></a>哪些情况适合创建索引</h2><h3 id=\"1-字段的数值有唯一性的限制\"><a href=\"#1-字段的数值有唯一性的限制\" class=\"headerlink\" title=\"1. 字段的数值有唯一性的限制\"></a><strong>1.</strong> <strong>字段的数值有唯一性的限制</strong></h3><blockquote>\n<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>\n</blockquote>\n<h3 id=\"2-频繁作为-WHERE-查询条件的字段\"><a href=\"#2-频繁作为-WHERE-查询条件的字段\" class=\"headerlink\" title=\"2. 频繁作为 WHERE 查询条件的字段\"></a><strong>2.</strong> <strong>频繁作为</strong> <strong>WHERE</strong> <strong>查询条件的字段</strong></h3><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>\n<p>比如student_info数据表（含100万条数据），假设我们想要查询 student_id=123110 的用户信息。</p>\n<h3 id=\"3-经常-GROUP-BY-和-ORDER-BY-的列\"><a href=\"#3-经常-GROUP-BY-和-ORDER-BY-的列\" class=\"headerlink\" title=\"3. 经常 GROUP BY 和 ORDER BY 的列\"></a><strong>3. 经常</strong> <strong>GROUP BY</strong> <strong>和</strong> <strong>ORDER BY</strong> 的列</h3><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。如果待排序的列有多个，那么可以在这些列上建立 组合索引 。</p>\n<h3 id=\"4-UPDATE、DELETE-的WHERE-条件列\"><a href=\"#4-UPDATE、DELETE-的WHERE-条件列\" class=\"headerlink\" title=\"4. UPDATE、DELETE 的WHERE 条件列\"></a><strong>4. UPDATE、DELETE 的WHERE</strong> <strong>条件列</strong></h3><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p>\n<h3 id=\"5-DISTINCT-字段需要创建索引\"><a href=\"#5-DISTINCT-字段需要创建索引\" class=\"headerlink\" title=\"5.DISTINCT 字段需要创建索引\"></a><strong>5.DISTINCT</strong> 字段需要创建索引</h3><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>\n<p>比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行SQL 语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果（600637 条记录，运行时间 0.683s ）：</p>\n<p>如果我们对 student_id 创建索引，再执行 SQL 语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT DISTINCT(student_id) FROM `student_info`;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果（600637 条记录，运行时间 0.010s ）：</p>\n<p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p>\n<h3 id=\"6-多表-JOIN-连接操作时，创建索引注意事项\"><a href=\"#6-多表-JOIN-连接操作时，创建索引注意事项\" class=\"headerlink\" title=\"6. 多表 JOIN 连接操作时，创建索引注意事项\"></a><strong>6.</strong> <strong>多表 JOIN 连接操作时，创建索引注意事项</strong></h3><p>首先， 连接表的数量尽量不要超过 3 张 ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p>\n<p>其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p>\n<p>最后， 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p>\n<p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT course_id, name, student_info.student_id, course_name </span><br><span class=\"line\">FROM student_info JOIN course </span><br><span class=\"line\">ON student_info.course_id = course.course_id </span><br><span class=\"line\">WHERE name = &#x27;462eed7ac6e791292a79&#x27;; </span><br></pre></td></tr></table></figure>\n\n<p>运行结果（1 条数据，运行时间 0.189s ）：</p>\n<p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。 </p>\n<h3 id=\"7-使用列的类型小的创建索引\"><a href=\"#7-使用列的类型小的创建索引\" class=\"headerlink\" title=\"7. 使用列的类型小的创建索引\"></a><strong>7.</strong> <strong>使用列的类型小的创建索引</strong></h3><h3 id=\"8-使用字符串前缀创建索引\"><a href=\"#8-使用字符串前缀创建索引\" class=\"headerlink\" title=\"8. 使用字符串前缀创建索引\"></a><strong>8.</strong> <strong>使用字符串前缀创建索引</strong></h3><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">create table shop(address varchar(120) not null); </span><br><span class=\"line\"></span><br><span class=\"line\">alter table shop add index(address(12));</span><br></pre></td></tr></table></figure>\n\n<p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。<strong>怎么计算不同的长度的选择性呢？</strong></p>\n<p>先看一下字段在全部数据中的选择度：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">select count(distinct address) / count(*) from shop;</span><br></pre></td></tr></table></figure>\n\n<p>通过不同长度去计算，与全表的选择性对比：</p>\n<p>公式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">count(distinct left(列名, 索引长度))/count(*)</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">select count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度 </span><br><span class=\"line\">count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度 </span><br><span class=\"line\">count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度 </span><br><span class=\"line\">count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度 </span><br><span class=\"line\">from shop; </span><br></pre></td></tr></table></figure>\n\n<p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p>\n<p><strong>拓展：Alibaba《Java开发手册》</strong></p>\n<p>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p>\n<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p>\n<h3 id=\"9-区分度高-散列性高-的列适合作为索引\"><a href=\"#9-区分度高-散列性高-的列适合作为索引\" class=\"headerlink\" title=\"9. 区分度高(散列性高)的列适合作为索引\"></a><strong>9.</strong> <strong>区分度高(散列性高)的列适合作为索引</strong></h3><h3 id=\"10-使用最频繁的列放到联合索引的左侧\"><a href=\"#10-使用最频繁的列放到联合索引的左侧\" class=\"headerlink\" title=\"10. 使用最频繁的列放到联合索引的左侧\"></a><strong>10. 使用最频繁的列放到联合索引的左侧</strong></h3><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率</p>\n<h3 id=\"11-在多个字段都要创建索引的情况下，联合索引优于单值索引\"><a href=\"#11-在多个字段都要创建索引的情况下，联合索引优于单值索引\" class=\"headerlink\" title=\"11. 在多个字段都要创建索引的情况下，联合索引优于单值索引\"></a><strong>11.</strong> <strong>在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></h3><h2 id=\"限制索引的数目\"><a href=\"#限制索引的数目\" class=\"headerlink\" title=\"限制索引的数目\"></a><strong>限制索引的数目</strong></h2><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过6个。原因:</p>\n<p>①每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。</p>\n<p>②索引会影响INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</p>\n<p>③优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</p>\n<h2 id=\"哪些情况不适合创建索引\"><a href=\"#哪些情况不适合创建索引\" class=\"headerlink\" title=\"哪些情况不适合创建索引\"></a><strong>哪些情况不适合创建索引</strong></h2><h3 id=\"1-在where中使用不到的字段，不要设置索引\"><a href=\"#1-在where中使用不到的字段，不要设置索引\" class=\"headerlink\" title=\"1. 在where中使用不到的字段，不要设置索引\"></a><strong>1.</strong> <strong>在where中使用不到的字段，不要设置索引</strong></h3><h3 id=\"2-数据量小的表最好不要使用索引\"><a href=\"#2-数据量小的表最好不要使用索引\" class=\"headerlink\" title=\"2. 数据量小的表最好不要使用索引\"></a><strong>2.</strong> <strong>数据量小的表最好不要使用索引</strong></h3><p>结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。</p>\n<h3 id=\"3-有大量重复数据的列上不要建立索引\"><a href=\"#3-有大量重复数据的列上不要建立索引\" class=\"headerlink\" title=\"3. 有大量重复数据的列上不要建立索引\"></a><strong>3.</strong> <strong>有大量重复数据的列上不要建立索引</strong></h3><p>举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p>\n<p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。</p>\n<p>学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE student_gender( </span><br><span class=\"line\">student_id INT(11) NOT NULL, </span><br><span class=\"line\">student_name VARCHAR(50) NOT NULL, </span><br><span class=\"line\">student_gender TINYINT(1) NOT NULL, </span><br><span class=\"line\">PRIMARY KEY(student_id) </span><br><span class=\"line\">)ENGINE = INNODB; </span><br></pre></td></tr></table></figure>\n\n<p>如果我们要筛选出这个学生表中的男性，可以使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM student_gender WHERE student_gender = 1</span><br></pre></td></tr></table></figure>\n\n<p>运行结果（10 条数据，运行时间 0.696s ）：</p>\n<blockquote>\n<p>结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引</p>\n</blockquote>\n<h3 id=\"4-避免对经常更新的表创建过多的索引\"><a href=\"#4-避免对经常更新的表创建过多的索引\" class=\"headerlink\" title=\"4. 避免对经常更新的表创建过多的索引\"></a><strong>4.</strong> <strong>避免对经常更新的表创建过多的索引</strong></h3><h3 id=\"5-不建议用无序的值作为索引\"><a href=\"#5-不建议用无序的值作为索引\" class=\"headerlink\" title=\"5. 不建议用无序的值作为索引\"></a><strong>5.</strong> <strong>不建议用无序的值作为索引</strong></h3><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>\n<h3 id=\"6-删除不再使用或者很少使用的索引\"><a href=\"#6-删除不再使用或者很少使用的索引\" class=\"headerlink\" title=\"6. 删除不再使用或者很少使用的索引\"></a><strong>6.</strong> <strong>删除不再使用或者很少使用的索引</strong></h3><h3 id=\"7-不要定义冗余或重复的索引\"><a href=\"#7-不要定义冗余或重复的索引\" class=\"headerlink\" title=\"7. 不要定义冗余或重复的索引\"></a><strong>7.</strong> <strong>不要定义冗余或重复的索引</strong></h3><p><strong>① 冗余索引</strong></p>\n<p>举例：建表语句如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE person_info( </span><br><span class=\"line\">id INT UNSIGNED NOT NULL AUTO_INCREMENT, </span><br><span class=\"line\">name VARCHAR(100) NOT NULL, </span><br><span class=\"line\">birthday DATE NOT NULL, </span><br><span class=\"line\">phone_number CHAR(11) NOT NULL, </span><br><span class=\"line\">country varchar(100) NOT NULL, </span><br><span class=\"line\">PRIMARY KEY (id), </span><br><span class=\"line\">KEY idx_name_birthday_phone_number (name(10), birthday, phone_number), </span><br><span class=\"line\">KEY idx_name (name(10)) </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一个专门针对 name 列的索引就算是一个 冗余索引 ，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p>\n<p><strong>② 重复索引</strong></p>\n<p>另一种情况，我们可能会对某个列 重复建立索引 ，比方说这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE repeat_index_demo ( </span><br><span class=\"line\">col1 INT PRIMARY KEY, </span><br><span class=\"line\">col2 INT, </span><br><span class=\"line\">UNIQUE uk_idx_c1 (col1), </span><br><span class=\"line\">INDEX idx_c1 (col1) </span><br><span class=\"line\">); </span><br></pre></td></tr></table></figure>\n\n<p>我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p>\n","categories":["MySQL高级","数据库"],"tags":["MySQL","数据库"]},{"title":"索引优化与查询优化","url":"/MySQL/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/","content":"<blockquote>\n<p>这里都是康师傅的MySQL笔记 写这些只是方便复习 不得不说康师傅讲的真好</p>\n</blockquote>\n<h1 id=\"索引失效案例\"><a href=\"#索引失效案例\" class=\"headerlink\" title=\"索引失效案例\"></a><strong>索引失效案例</strong></h1><h2 id=\"全值匹配我最爱\"><a href=\"#全值匹配我最爱\" class=\"headerlink\" title=\"全值匹配我最爱\"></a><strong>全值匹配我最爱</strong></h2><h2 id=\"最佳左前缀法则\"><a href=\"#最佳左前缀法则\" class=\"headerlink\" title=\"最佳左前缀法则\"></a><strong>最佳左前缀法则</strong></h2><blockquote>\n<p><strong>拓展：Alibaba《Java开发手册》</strong></p>\n<p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>\n</blockquote>\n<h2 id=\"主键插入顺序\"><a href=\"#主键插入顺序\" class=\"headerlink\" title=\"主键插入顺序\"></a><strong>主键插入顺序</strong></h2><p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/FRB7EL0M6T77KS.png\"></p>\n<p>如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/QT8MP2RAFMPNI2.png\"></p>\n<p>可这个数据页已经满了，再插进来咋办呢？我们需要把当前 页面分裂 成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着： 性能损耗 ！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的 主键值依次递增 ，这样就不会发生这样的性能损耗了。所以我们建议：让主键具有AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入 ，比如： person_info 表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE person_info( </span><br><span class=\"line\">id INT UNSIGNED NOT NULL AUTO_INCREMENT, </span><br><span class=\"line\">name VARCHAR(100) NOT NULL, </span><br><span class=\"line\">birthday DATE NOT NULL, </span><br><span class=\"line\">phone_number CHAR(11) NOT NULL, </span><br><span class=\"line\">country varchar(100) NOT NULL, </span><br><span class=\"line\">PRIMARY KEY (id), </span><br><span class=\"line\">KEY idx_name_birthday_phone_number (name(10), birthday, phone_number) </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>我们自定义的主键列 id 拥有 AUTO_INCREMENT 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p>\n<h2 id=\"计算、函数、类型转换-自动或手动-导致索引失效\"><a href=\"#计算、函数、类型转换-自动或手动-导致索引失效\" class=\"headerlink\" title=\"计算、函数、类型转换(自动或手动)导致索引失效\"></a><strong>计算、函数、类型转换(自动或手动)导致索引失效</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;; </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;; </span><br></pre></td></tr></table></figure>\n\n<p>创建索引</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE INDEX idx_name ON student(NAME);</span><br></pre></td></tr></table></figure>\n\n<p>第一种：索引优化生效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE &#x27;abc%&#x27;; </span><br><span class=\"line\">+---------+---------+--------+------+---------+ </span><br><span class=\"line\">| id | stuno | name | age | classId | </span><br><span class=\"line\">+---------+---------+--------+------+---------+ </span><br><span class=\"line\">| 5301379 | 1233401 | AbCHEa | 164 | 259 | </span><br><span class=\"line\">| 7170042 | 3102064 | ABcHeB | 199 | 161 | </span><br><span class=\"line\">| 1901614 | 1833636 | ABcHeC | 226 | 275 | </span><br><span class=\"line\">| 5195021 | 1127043 | abchEC | 486 | 72 | </span><br><span class=\"line\">| 4047089 | 3810031 | AbCHFd | 268 | 210 | </span><br><span class=\"line\">| 4917074 | 849096 | ABcHfD | 264 | 442 | </span><br><span class=\"line\">| 1540859 | 141979 | abchFF | 119 | 140 | </span><br><span class=\"line\">| 5121801 | 1053823 | AbCHFg | 412 | 327 | </span><br><span class=\"line\">| 2441254 | 2373276 | abchFJ | 170 | 362 | </span><br><span class=\"line\">| 7039146 | 2971168 | ABcHgI | 502 | 465 | </span><br><span class=\"line\">| 1636826 | 1580286 | ABcHgK | 71 | 262 | </span><br><span class=\"line\">| 374344 | 474345 | abchHL | 367 | 212 | </span><br><span class=\"line\">| 1596534 | 169191 | AbCHHl | 102 | 146 | </span><br><span class=\"line\">... </span><br><span class=\"line\">| 5266837 | 1198859 | abclXe | 292 | 298 | </span><br><span class=\"line\">| 8126968 | 4058990 | aBClxE | 316 | 150 | </span><br><span class=\"line\">| 4298305 | 399962 | AbCLXF | 72 | 423 | </span><br><span class=\"line\">| 5813628 | 1745650 | aBClxF | 356 | 323 | </span><br><span class=\"line\">| 6980448 | 2912470 | AbCLXF | 107 | 78 | </span><br><span class=\"line\">| 7881979 | 3814001 | AbCLXF | 89 | 497 | </span><br><span class=\"line\">| 4955576 | 887598 | ABcLxg | 121 | 385 | </span><br><span class=\"line\">| 3653460 | 3585482 | AbCLXJ | 130 | 174 | </span><br><span class=\"line\">| 1231990 | 1283439 | AbCLYH | 189 | 429 | </span><br><span class=\"line\">| 6110615 | 2042637 | ABcLyh | 157 | 40 | </span><br><span class=\"line\">+---------+---------+--------+------+---------+ </span><br><span class=\"line\">401 rows in set, 1 warning (0.01 sec) </span><br></pre></td></tr></table></figure>\n\n<p>第二种：索引优化失效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/7XD26AYKGDKWT4X9W.png\"></p>\n<p>type为“ALL”，表示没有使用到索引，查询时间为 3.62 秒，查询效率较之前低很多。</p>\n<p><strong>再举例：</strong></p>\n<ul>\n<li>student表的字段stuno上设置有索引</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE INDEX idx_sno ON student(stuno);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/7XD26AYKGDKWT4X9W.png\"></p>\n<ul>\n<li>索引优化生效</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno = 900000;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类型转换导致索引失效\"><a href=\"#类型转换导致索引失效\" class=\"headerlink\" title=\"类型转换导致索引失效\"></a><strong>类型转换导致索引失效</strong></h2><p>下列哪个sql语句可以用到索引。（假设name字段上设置有索引）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 未使用到索引 </span><br><span class=\"line\">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/7A87IQMI0V.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 使用到索引 EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/14YGTINIVHB5TV.png\"></p>\n<ul>\n<li>name=123发生类型转换，索引失效。</li>\n</ul>\n<h2 id=\"范围条件右边的列索引失效\"><a href=\"#范围条件右边的列索引失效\" class=\"headerlink\" title=\"范围条件右边的列索引失效\"></a><strong>范围条件右边的列索引失效</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ALTER TABLE student DROP INDEX idx_name; </span><br><span class=\"line\">ALTER TABLE student DROP INDEX idx_age; </span><br><span class=\"line\">ALTER TABLE student DROP INDEX idx_age_classid; </span><br><span class=\"line\"></span><br><span class=\"line\">EXPLAIN SELECT SQL_NO_CACHE * FROM student </span><br><span class=\"line\">WHERE student.age=30 AND student.classId&gt;20 AND  student.name = &#x27;abc&#x27; ; </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/PZ7DUR6OGZH.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">create index idx_age_name_classid on student(age,name,classid);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>将范围查询条件放置语句最后：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = &#x27;abc&#x27; AND student.classId&gt;20 ;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://nodeandimg.oss-cn-wulanchabu.aliyuncs.com/QVBZEGZFUG]IE6S5FJSF.png\"></p>\n<h2 id=\"不等于-或者-lt-gt-索引失效\"><a href=\"#不等于-或者-lt-gt-索引失效\" class=\"headerlink\" title=\"**不等于(!= **或者&lt;&gt;)索引失效\"></a>**不等于(!= **或者&lt;&gt;)索引失效</h2><h2 id=\"is-null可以使用索引，is-not-null无法使用索引\"><a href=\"#is-null可以使用索引，is-not-null无法使用索引\" class=\"headerlink\" title=\"is null可以使用索引，is not null无法使用索引\"></a><strong>is null可以使用索引，is not null无法使用索引</strong></h2><h2 id=\"like以通配符-开头索引失效\"><a href=\"#like以通配符-开头索引失效\" class=\"headerlink\" title=\"like以通配符%开头索引失效\"></a><strong>like以通配符%开头索引失效</strong></h2><blockquote>\n<p><strong>拓展：Alibaba《Java开发手册》</strong></p>\n<p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>\n</blockquote>\n<h2 id=\"OR-前后存在非索引的列，索引失效\"><a href=\"#OR-前后存在非索引的列，索引失效\" class=\"headerlink\" title=\"OR 前后存在非索引的列，索引失效\"></a><strong>OR</strong> <strong>前后存在非索引的列，索引失效</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 未使用到索引</span><br><span class=\"line\">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#使用到索引</span><br><span class=\"line\">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR name = &#x27;Abel&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据库和表的字符集统一使用utf8mb4\"><a href=\"#数据库和表的字符集统一使用utf8mb4\" class=\"headerlink\" title=\"数据库和表的字符集统一使用utf8mb4\"></a><strong>数据库和表的字符集统一使用utf8mb4</strong></h2><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的 字符集 进行比较前需要进行 转换 会造成索引失效。</p>\n","categories":["MySQL高级","数据库"],"tags":["MySQL","数据库"]}]